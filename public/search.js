window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "sims", "modulename": "sims", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "sims.base_sim", "modulename": "sims.base_sim", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "sims.base_sim.SimSync", "modulename": "sims.base_sim", "qualname": "SimSync", "kind": "class", "doc": "<p></p>\n"}, {"fullname": "sims.base_sim.SimSync.can_step", "modulename": "sims.base_sim", "qualname": "SimSync.can_step", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sims.base_sim.SimSync.did_step", "modulename": "sims.base_sim", "qualname": "SimSync.did_step", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sims.base_sim.SimSync.step", "modulename": "sims.base_sim", "qualname": "SimSync.step", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sims.base_sim.sleep", "modulename": "sims.base_sim", "qualname": "sleep", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">duration</span>,</span><span class=\"param\">\t<span class=\"n\">sim_sync</span><span class=\"p\">:</span> <span class=\"n\">sims</span><span class=\"o\">.</span><span class=\"n\">base_sim</span><span class=\"o\">.</span><span class=\"n\">SimSync</span>,</span><span class=\"param\">\t<span class=\"n\">model</span><span class=\"p\">:</span> <span class=\"n\">mujoco</span><span class=\"o\">.</span><span class=\"n\">_structs</span><span class=\"o\">.</span><span class=\"n\">MjModel</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sims.base_sim.BaseSim", "modulename": "sims.base_sim", "qualname": "BaseSim", "kind": "class", "doc": "<p>Abstract base class for MuJoCo robot simulations.</p>\n\n<p>This class serves as the foundational framework for simulating robots in MuJoCo. It defines\nkey properties and methods that must be implemented in subclasses, including access to\nthe simulation's dynamic data (<code>MjData</code>), the static model (<code>MjModel</code>), and control mechanisms.</p>\n\n<p>Child classes are responsible for implementing the control logic (<code>control_loop</code>) and handling\nuser inputs via the keyboard (<code>keyboard_callback</code>). The <code>run</code> method provides a basic structure\nfor running the main simulation loop, handling viewer synchronization, and processing user inputs\nin real-time.</p>\n\n<p>This base class includes functionality to issue warnings if important methods, such as the control\nloop or keyboard callback, are not implemented in a subclass.</p>\n", "bases": "abc.ABC"}, {"fullname": "sims.base_sim.BaseSim.tasks", "modulename": "sims.base_sim", "qualname": "BaseSim.tasks", "kind": "variable", "doc": "<p></p>\n", "annotation": ": List[Callable]"}, {"fullname": "sims.base_sim.BaseSim.data", "modulename": "sims.base_sim", "qualname": "BaseSim.data", "kind": "variable", "doc": "<p>Access the current simulation data.</p>\n\n<p>This property provides access to an instance of the <code>MjData</code> class, which contains the dynamic\nsimulation state. This includes quantities such as joint positions, velocities,\nactuator forces, and sensory information. The <code>MjData</code> object is updated at each simulation step\nand can be used to inspect the real-time state of said simulation.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>mj.MjData\n    An object representing the current dynamic state of the simulation.</p>\n", "annotation": ": mujoco._structs.MjData"}, {"fullname": "sims.base_sim.BaseSim.model", "modulename": "sims.base_sim", "qualname": "BaseSim.model", "kind": "variable", "doc": "<p>Access the model of the MuJoCo simulation.</p>\n\n<p>This property returns an instance of the <code>MjModel</code> class, which describes the physical and\nmechanical properties of the simulation. The <code>MjModel</code> object contains static information about the\nsimulation such as its kinematic trees, inertial properties, joint and actuator definitions, and geometry\nconfigurations. It is used to define the system's structure and behavior within the simulation.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>mj.MjModel\n    An object representing the static model of the system and overall MuJoCo simulation.</p>\n", "annotation": ": mujoco._structs.MjModel"}, {"fullname": "sims.base_sim.BaseSim.control_loop", "modulename": "sims.base_sim", "qualname": "BaseSim.control_loop", "kind": "function", "doc": "<p>Main control loop for the robot simulation.</p>\n\n<p>This method is intended to be overridden in the child class to implement the robot's control\nlogic. The control loop is typically responsible for computing control signals based on the\ncurrent state of the simulation (e.g., sensor data) and applying these signals to the robot's\nactuators. The frequency of the control loop matches the simulation step rate.</p>\n\n<p>If this method is not implemented in the child class, a warning will be issued.</p>\n\n<h2 id=\"raises\">Raises</h2>\n\n<p>UserWarning\n    If the method is not implemented in the child class.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "sims.base_sim.BaseSim.keyboard_callback", "modulename": "sims.base_sim", "qualname": "BaseSim.keyboard_callback", "kind": "function", "doc": "<p>Handle keyboard inputs during the simulation.</p>\n\n<p>This method is intended to be overridden in the child class to define how the simulation responds\nto specific keyboard inputs. The <code>key</code> parameter corresponds to the key pressed by the user,\nallowing for custom behavior (e.g., sending trajectories to robots' task queues, logging data\nor start/stopping processes).</p>\n\n<p>If this method is not implemented in the child class, a warning will be issued.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>key : int\n    The key pressed by the user represented by a key code.</p>\n\n<h2 id=\"raises\">Raises</h2>\n\n<p>UserWarning\n    If the method is not implemented in the child class.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">key</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "sims.base_sim.BaseSim.run", "modulename": "sims.base_sim", "qualname": "BaseSim.run", "kind": "function", "doc": "<p>Run the main simulation loop with or without the MuJoCo viewer.</p>\n\n<p>This method starts the simulation loop, either with the MuJoCo viewer or in headless mode,\ndepending on the <code>headless</code> argument. In non-headless mode, the viewer is launched to manage\nkeyboard events, synchronize with the simulation, and control the timing of each simulation step.\nThe camera view is rendered if enabled. In headless mode, the simulation runs in the background\nwithout any visual output, stepping through each simulation step while performing the control loop.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>headless : bool, optional\n    If True, the simulation runs without rendering or a viewer (default is False).</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>None</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">headless</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">limit_cycle_time</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">show_left_ui</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">show_right_ui</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "sims.cable_weaving", "modulename": "sims.cable_weaving", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "sims.cable_weaving.MjSim", "modulename": "sims.cable_weaving", "qualname": "MjSim", "kind": "class", "doc": "<p>Abstract base class for MuJoCo robot simulations.</p>\n\n<p>This class serves as the foundational framework for simulating robots in MuJoCo. It defines\nkey properties and methods that must be implemented in subclasses, including access to\nthe simulation's dynamic data (<code>MjData</code>), the static model (<code>MjModel</code>), and control mechanisms.</p>\n\n<p>Child classes are responsible for implementing the control logic (<code>control_loop</code>) and handling\nuser inputs via the keyboard (<code>keyboard_callback</code>). The <code>run</code> method provides a basic structure\nfor running the main simulation loop, handling viewer synchronization, and processing user inputs\nin real-time.</p>\n\n<p>This base class includes functionality to issue warnings if important methods, such as the control\nloop or keyboard callback, are not implemented in a subclass.</p>\n", "bases": "sims.base_sim.BaseSim"}, {"fullname": "sims.cable_weaving.MjSim.twof85", "modulename": "sims.cable_weaving", "qualname": "MjSim.twof85", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sims.cable_weaving.MjSim.mocap", "modulename": "sims.cable_weaving", "qualname": "MjSim.mocap", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sims.cable_weaving.MjSim.T_mocap_tcp", "modulename": "sims.cable_weaving", "qualname": "MjSim.T_mocap_tcp", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sims.cable_weaving.MjSim.spec", "modulename": "sims.cable_weaving", "qualname": "MjSim.spec", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sims.cable_weaving.MjSim.tasks", "modulename": "sims.cable_weaving", "qualname": "MjSim.tasks", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sims.cable_weaving.MjSim.h", "modulename": "sims.cable_weaving", "qualname": "MjSim.h", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sims.cable_weaving.MjSim.theta", "modulename": "sims.cable_weaving", "qualname": "MjSim.theta", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sims.cable_weaving.MjSim.delta", "modulename": "sims.cable_weaving", "qualname": "MjSim.delta", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sims.cable_weaving.MjSim.begin", "modulename": "sims.cable_weaving", "qualname": "MjSim.begin", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sims.cable_weaving.MjSim.init", "modulename": "sims.cable_weaving", "qualname": "MjSim.init", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sims.cable_weaving.MjSim.spin", "modulename": "sims.cable_weaving", "qualname": "MjSim.spin", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">ss</span><span class=\"p\">:</span> <span class=\"n\">sims</span><span class=\"o\">.</span><span class=\"n\">base_sim</span><span class=\"o\">.</span><span class=\"n\">SimSync</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sims.cable_weaving.MjSim.get_check_point_frames", "modulename": "sims.cable_weaving", "qualname": "MjSim.get_check_point_frames", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">spatialmath</span><span class=\"o\">.</span><span class=\"n\">pose3d</span><span class=\"o\">.</span><span class=\"n\">SE3</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "sims.cable_weaving.MjSim.weaving", "modulename": "sims.cable_weaving", "qualname": "MjSim.weaving", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">ss</span><span class=\"p\">:</span> <span class=\"n\">sims</span><span class=\"o\">.</span><span class=\"n\">base_sim</span><span class=\"o\">.</span><span class=\"n\">SimSync</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sims.cable_weaving.MjSim.data", "modulename": "sims.cable_weaving", "qualname": "MjSim.data", "kind": "variable", "doc": "<p>Access the current simulation data.</p>\n\n<p>This property provides access to an instance of the <code>MjData</code> class, which contains the dynamic\nsimulation state. This includes quantities such as joint positions, velocities,\nactuator forces, and sensory information. The <code>MjData</code> object is updated at each simulation step\nand can be used to inspect the real-time state of said simulation.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>mj.MjData\n    An object representing the current dynamic state of the simulation.</p>\n", "annotation": ": mujoco._structs.MjData"}, {"fullname": "sims.cable_weaving.MjSim.model", "modulename": "sims.cable_weaving", "qualname": "MjSim.model", "kind": "variable", "doc": "<p>Access the model of the MuJoCo simulation.</p>\n\n<p>This property returns an instance of the <code>MjModel</code> class, which describes the physical and\nmechanical properties of the simulation. The <code>MjModel</code> object contains static information about the\nsimulation such as its kinematic trees, inertial properties, joint and actuator definitions, and geometry\nconfigurations. It is used to define the system's structure and behavior within the simulation.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>mj.MjModel\n    An object representing the static model of the system and overall MuJoCo simulation.</p>\n", "annotation": ": mujoco._structs.MjModel"}, {"fullname": "sims.cable_weaving.MjSim.keyboard_callback", "modulename": "sims.cable_weaving", "qualname": "MjSim.keyboard_callback", "kind": "function", "doc": "<p>Handle keyboard inputs during the simulation.</p>\n\n<p>This method is intended to be overridden in the child class to define how the simulation responds\nto specific keyboard inputs. The <code>key</code> parameter corresponds to the key pressed by the user,\nallowing for custom behavior (e.g., sending trajectories to robots' task queues, logging data\nor start/stopping processes).</p>\n\n<p>If this method is not implemented in the child class, a warning will be issued.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>key : int\n    The key pressed by the user represented by a key code.</p>\n\n<h2 id=\"raises\">Raises</h2>\n\n<p>UserWarning\n    If the method is not implemented in the child class.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">key</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sims.cable_weaving.MjSim.init_orientation", "modulename": "sims.cable_weaving", "qualname": "MjSim.init_orientation", "kind": "function", "doc": "<p>Align the TCP's y-axis to point directly away from a specified object.</p>\n\n<p>Parameters:</p>\n\n<ul>\n<li>geom_name (str): Name of the geometry to align away from.</li>\n<li>vel (float): Desired rotation velocity in radians per second (currently unused).</li>\n<li>T_init (sm.SE3, optional): Initial pose of the TCP. If None, fetches the current TCP pose.</li>\n</ul>\n\n<p>Returns:</p>\n\n<ul>\n<li>sm.SE3: The target pose after rotation.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">geom_name</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">vel</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.3</span>,</span><span class=\"param\">\t<span class=\"n\">T_init</span><span class=\"p\">:</span> <span class=\"n\">spatialmath</span><span class=\"o\">.</span><span class=\"n\">pose3d</span><span class=\"o\">.</span><span class=\"n\">SE3</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sims.cable_weaving.MjSim.move_close", "modulename": "sims.cable_weaving", "qualname": "MjSim.move_close", "kind": "function", "doc": "<p>Move towards the object specified by geom_name until within a given radius.</p>\n\n<p>Parameters:</p>\n\n<ul>\n<li>geom_name: str, the name of the geometry to move towards.</li>\n<li>radius: float, the distance to maintain from the object.</li>\n<li>vel: float, the velocity of the movement.</li>\n</ul>\n\n<p>Returns:</p>\n\n<ul>\n<li>sm.SE3: Pose radius away from a geometry.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">geom_name</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">radius</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.06</span>,</span><span class=\"param\">\t<span class=\"n\">T_init</span><span class=\"p\">:</span> <span class=\"n\">spatialmath</span><span class=\"o\">.</span><span class=\"n\">pose3d</span><span class=\"o\">.</span><span class=\"n\">SE3</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">spatialmath</span><span class=\"o\">.</span><span class=\"n\">pose3d</span><span class=\"o\">.</span><span class=\"n\">SE3</span>:</span></span>", "funcdef": "def"}, {"fullname": "sims.cable_weaving.MjSim.angle_to_next_alignment", "modulename": "sims.cable_weaving", "qualname": "MjSim.angle_to_next_alignment", "kind": "function", "doc": "<p>Compute the angle to align the TCP with a tangent direction between two geometries.</p>\n\n<p>Parameters:</p>\n\n<ul>\n<li>geom_indx (int): Index of the geometry in the specification.</li>\n<li>current_geom_name (str): Name of the current geometry.</li>\n<li>next_geom_name (str): Name of the next geometry to align with.</li>\n<li>T_init (sm.SE3, optional): Initial pose of the TCP. If None, fetches the current TCP pose.</li>\n</ul>\n\n<p>Returns:</p>\n\n<ul>\n<li>float: The angle in radians for the alignment.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">geom_indx</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">current_geom_name</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">next_geom_name</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">T_init</span><span class=\"p\">:</span> <span class=\"n\">spatialmath</span><span class=\"o\">.</span><span class=\"n\">pose3d</span><span class=\"o\">.</span><span class=\"n\">SE3</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "sims.cable_weaving.MjSim.rotate_about", "modulename": "sims.cable_weaving", "qualname": "MjSim.rotate_about", "kind": "function", "doc": "<p>Generate a pose rotating the TCP relative to a specified geometry.</p>\n\n<p>Parameters:</p>\n\n<ul>\n<li>geom_name (str): Name of the geometry to rotate around.</li>\n<li>dir (str): Direction of rotation, \"ccw\" for counterclockwise or \"cw\" for clockwise.</li>\n<li>phi (float): Angle of rotation in radians.</li>\n<li>n_steps (int): Number of steps in the trajectory.</li>\n<li>T_init (sm.SE3, optional): Initial pose of the TCP. If None, fetches the current TCP pose.</li>\n</ul>\n\n<p>Returns:</p>\n\n<ul>\n<li>sm.SE3: Rotated pose.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">geom_name</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"nb\">dir</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">phi</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">n_steps</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">20</span>,</span><span class=\"param\">\t<span class=\"n\">T_init</span><span class=\"p\">:</span> <span class=\"n\">spatialmath</span><span class=\"o\">.</span><span class=\"n\">pose3d</span><span class=\"o\">.</span><span class=\"n\">SE3</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">spatialmath</span><span class=\"o\">.</span><span class=\"n\">pose3d</span><span class=\"o\">.</span><span class=\"n\">SE3</span>:</span></span>", "funcdef": "def"}, {"fullname": "sims.cable_weaving.MjSim.opp1", "modulename": "sims.cable_weaving", "qualname": "MjSim.opp1", "kind": "function", "doc": "<p>Generate a Cartesian pose from the end effector pose to a new pose above an obstacle.</p>\n\n<p>Parameters:</p>\n\n<ul>\n<li>h (float): Height offset above the obstacle.</li>\n<li>geom_name (str): Name of the obstacle geometry.</li>\n<li>T_init (sm.SE3, optional): Initial pose of the TCP. If None, fetches the current TCP pose.</li>\n</ul>\n\n<p>Returns:</p>\n\n<ul>\n<li>sm.SE3: Target pose above the obstacle.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">h</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">geom_name</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">T_init</span><span class=\"p\">:</span> <span class=\"n\">spatialmath</span><span class=\"o\">.</span><span class=\"n\">pose3d</span><span class=\"o\">.</span><span class=\"n\">SE3</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">spatialmath</span><span class=\"o\">.</span><span class=\"n\">pose3d</span><span class=\"o\">.</span><span class=\"n\">SE3</span>:</span></span>", "funcdef": "def"}, {"fullname": "sims.cable_weaving.MjSim.opp2", "modulename": "sims.cable_weaving", "qualname": "MjSim.opp2", "kind": "function", "doc": "<p>Generate a Cartesian pose rotated theta raltive to some obstacle.</p>\n\n<p>Parameters:</p>\n\n<ul>\n<li>theta (float): Angle of rotation in radians.</li>\n<li>dir (str): Direction of rotation, \"ccw\" or \"cw\".</li>\n<li>geom_name (str): Name of the obstacle geometry.</li>\n<li>T_init (sm.SE3, optional): Initial pose of the TCP. If None, fetches the current TCP pose.</li>\n</ul>\n\n<p>Returns:</p>\n\n<ul>\n<li>sm.SE3: Target pose after the rotation.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">theta</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"nb\">dir</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">geom_name</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">T_init</span><span class=\"p\">:</span> <span class=\"n\">spatialmath</span><span class=\"o\">.</span><span class=\"n\">pose3d</span><span class=\"o\">.</span><span class=\"n\">SE3</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">spatialmath</span><span class=\"o\">.</span><span class=\"n\">pose3d</span><span class=\"o\">.</span><span class=\"n\">SE3</span>:</span></span>", "funcdef": "def"}, {"fullname": "sims.cable_weaving.MjSim.opp3", "modulename": "sims.cable_weaving", "qualname": "MjSim.opp3", "kind": "function", "doc": "<p>Compute a target pose for the robot's end-effector based on positional and rotational offsets.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>delta : float\n    Distance offset from the current end-effector position towards the target geometry in the xy-plane.\ntheta : float\n    Angle of rotation around the z-axis (in radians).\ndir : str\n    Direction of rotation (\"ccw\" for counterclockwise, any other value for clockwise).\ngeom_name : str\n    Name of the target geometry to compute the offset and rotation with respect to.\nT_init : sm.SE3, optional\n    Initial pose of the end-effector. If None, the current pose is fetched from the robot, by default None.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>sm.SE3\n    The computed target pose in the world frame.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">delta</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">theta</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"nb\">dir</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">geom_name</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">T_init</span><span class=\"p\">:</span> <span class=\"n\">spatialmath</span><span class=\"o\">.</span><span class=\"n\">pose3d</span><span class=\"o\">.</span><span class=\"n\">SE3</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">spatialmath</span><span class=\"o\">.</span><span class=\"n\">pose3d</span><span class=\"o\">.</span><span class=\"n\">SE3</span>:</span></span>", "funcdef": "def"}, {"fullname": "sims.cable_weaving.MjSim.opp4", "modulename": "sims.cable_weaving", "qualname": "MjSim.opp4", "kind": "function", "doc": "<p>Compute a target pose for the robot's end-effector with a specified z-height.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>z_height : float\n    Desired height (z-coordinate) for the end-effector in the world frame.\nT_init : sm.SE3, optional\n    Initial pose of the end-effector. If None, the current pose is fetched from the robot, by default None.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>sm.SE3\n    The computed target pose with the specified z-height.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">z_height</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">T_init</span><span class=\"p\">:</span> <span class=\"n\">spatialmath</span><span class=\"o\">.</span><span class=\"n\">pose3d</span><span class=\"o\">.</span><span class=\"n\">SE3</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">spatialmath</span><span class=\"o\">.</span><span class=\"n\">pose3d</span><span class=\"o\">.</span><span class=\"n\">SE3</span>:</span></span>", "funcdef": "def"}, {"fullname": "sims.diffik_ur5e", "modulename": "sims.diffik_ur5e", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "sims.diffik_ur5e.MjSim", "modulename": "sims.diffik_ur5e", "qualname": "MjSim", "kind": "class", "doc": "<p>Abstract base class for MuJoCo robot simulations.</p>\n\n<p>This class serves as the foundational framework for simulating robots in MuJoCo. It defines\nkey properties and methods that must be implemented in subclasses, including access to\nthe simulation's dynamic data (<code>MjData</code>), the static model (<code>MjModel</code>), and control mechanisms.</p>\n\n<p>Child classes are responsible for implementing the control logic (<code>control_loop</code>) and handling\nuser inputs via the keyboard (<code>keyboard_callback</code>). The <code>run</code> method provides a basic structure\nfor running the main simulation loop, handling viewer synchronization, and processing user inputs\nin real-time.</p>\n\n<p>This base class includes functionality to issue warnings if important methods, such as the control\nloop or keyboard callback, are not implemented in a subclass.</p>\n", "bases": "sims.base_sim.BaseSim"}, {"fullname": "sims.diffik_ur5e.MjSim.ur5e", "modulename": "sims.diffik_ur5e", "qualname": "MjSim.ur5e", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sims.diffik_ur5e.MjSim.tasks", "modulename": "sims.diffik_ur5e", "qualname": "MjSim.tasks", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sims.diffik_ur5e.MjSim.init", "modulename": "sims.diffik_ur5e", "qualname": "MjSim.init", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">mujoco</span><span class=\"o\">.</span><span class=\"n\">_structs</span><span class=\"o\">.</span><span class=\"n\">MjModel</span><span class=\"p\">,</span> <span class=\"n\">mujoco</span><span class=\"o\">.</span><span class=\"n\">_structs</span><span class=\"o\">.</span><span class=\"n\">MjData</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "sims.diffik_ur5e.MjSim.move", "modulename": "sims.diffik_ur5e", "qualname": "MjSim.move", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">ss</span><span class=\"p\">:</span> <span class=\"n\">sims</span><span class=\"o\">.</span><span class=\"n\">base_sim</span><span class=\"o\">.</span><span class=\"n\">SimSync</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sims.diffik_ur5e.MjSim.log", "modulename": "sims.diffik_ur5e", "qualname": "MjSim.log", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">ss</span><span class=\"p\">:</span> <span class=\"n\">sims</span><span class=\"o\">.</span><span class=\"n\">base_sim</span><span class=\"o\">.</span><span class=\"n\">SimSync</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sims.diffik_ur5e.MjSim.spin", "modulename": "sims.diffik_ur5e", "qualname": "MjSim.spin", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">ss</span><span class=\"p\">:</span> <span class=\"n\">sims</span><span class=\"o\">.</span><span class=\"n\">base_sim</span><span class=\"o\">.</span><span class=\"n\">SimSync</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sims.diffik_ur5e.MjSim.data", "modulename": "sims.diffik_ur5e", "qualname": "MjSim.data", "kind": "variable", "doc": "<p>Access the current simulation data.</p>\n\n<p>This property provides access to an instance of the <code>MjData</code> class, which contains the dynamic\nsimulation state. This includes quantities such as joint positions, velocities,\nactuator forces, and sensory information. The <code>MjData</code> object is updated at each simulation step\nand can be used to inspect the real-time state of said simulation.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>mj.MjData\n    An object representing the current dynamic state of the simulation.</p>\n", "annotation": ": mujoco._structs.MjData"}, {"fullname": "sims.diffik_ur5e.MjSim.model", "modulename": "sims.diffik_ur5e", "qualname": "MjSim.model", "kind": "variable", "doc": "<p>Access the model of the MuJoCo simulation.</p>\n\n<p>This property returns an instance of the <code>MjModel</code> class, which describes the physical and\nmechanical properties of the simulation. The <code>MjModel</code> object contains static information about the\nsimulation such as its kinematic trees, inertial properties, joint and actuator definitions, and geometry\nconfigurations. It is used to define the system's structure and behavior within the simulation.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>mj.MjModel\n    An object representing the static model of the system and overall MuJoCo simulation.</p>\n", "annotation": ": mujoco._structs.MjModel"}, {"fullname": "sims.diffik_ur5e.MjSim.keyboard_callback", "modulename": "sims.diffik_ur5e", "qualname": "MjSim.keyboard_callback", "kind": "function", "doc": "<p>Handle keyboard inputs during the simulation.</p>\n\n<p>This method is intended to be overridden in the child class to define how the simulation responds\nto specific keyboard inputs. The <code>key</code> parameter corresponds to the key pressed by the user,\nallowing for custom behavior (e.g., sending trajectories to robots' task queues, logging data\nor start/stopping processes).</p>\n\n<p>If this method is not implemented in the child class, a warning will be issued.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>key : int\n    The key pressed by the user represented by a key code.</p>\n\n<h2 id=\"raises\">Raises</h2>\n\n<p>UserWarning\n    If the method is not implemented in the child class.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">key</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "sims.diffik_ur5e.setup_logging", "modulename": "sims.diffik_ur5e", "qualname": "setup_logging", "kind": "function", "doc": "<p>Setup basic logging</p>\n\n<p>Args:\n  loglevel (int): minimum loglevel for emitting messages</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">loglevel</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sims.diffik_ur5e.main", "modulename": "sims.diffik_ur5e", "qualname": "main", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sims.dmp_cartesian_ur5e", "modulename": "sims.dmp_cartesian_ur5e", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "sims.dmp_cartesian_ur5e.MjSim", "modulename": "sims.dmp_cartesian_ur5e", "qualname": "MjSim", "kind": "class", "doc": "<p>Abstract base class for MuJoCo robot simulations.</p>\n\n<p>This class serves as the foundational framework for simulating robots in MuJoCo. It defines\nkey properties and methods that must be implemented in subclasses, including access to\nthe simulation's dynamic data (<code>MjData</code>), the static model (<code>MjModel</code>), and control mechanisms.</p>\n\n<p>Child classes are responsible for implementing the control logic (<code>control_loop</code>) and handling\nuser inputs via the keyboard (<code>keyboard_callback</code>). The <code>run</code> method provides a basic structure\nfor running the main simulation loop, handling viewer synchronization, and processing user inputs\nin real-time.</p>\n\n<p>This base class includes functionality to issue warnings if important methods, such as the control\nloop or keyboard callback, are not implemented in a subclass.</p>\n", "bases": "sims.base_sim.BaseSim"}, {"fullname": "sims.dmp_cartesian_ur5e.MjSim.ur5e", "modulename": "sims.dmp_cartesian_ur5e", "qualname": "MjSim.ur5e", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sims.dmp_cartesian_ur5e.MjSim.dmp", "modulename": "sims.dmp_cartesian_ur5e", "qualname": "MjSim.dmp", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sims.dmp_cartesian_ur5e.MjSim.pose_matrices", "modulename": "sims.dmp_cartesian_ur5e", "qualname": "MjSim.pose_matrices", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sims.dmp_cartesian_ur5e.MjSim.dmp_poses", "modulename": "sims.dmp_cartesian_ur5e", "qualname": "MjSim.dmp_poses", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sims.dmp_cartesian_ur5e.MjSim.tasks", "modulename": "sims.dmp_cartesian_ur5e", "qualname": "MjSim.tasks", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sims.dmp_cartesian_ur5e.MjSim.df_2_se3", "modulename": "sims.dmp_cartesian_ur5e", "qualname": "MjSim.df_2_se3", "kind": "function", "doc": "<p>Converts pose columns in a DataFrame to a list of spatialmath SE3 matrices.</p>\n\n<p>Args:\n    df: DataFrame containing pose data.\n    pose_columns_prefix: The prefix of the pose columns (e.g., 'actual_TCP_pose' or 'target_TCP_pose').</p>\n\n<p>Returns:\n    A list of SE3 objects representing the poses.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">df</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>,</span><span class=\"param\">\t<span class=\"n\">pose_columns_prefix</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">spatialmath</span><span class=\"o\">.</span><span class=\"n\">pose3d</span><span class=\"o\">.</span><span class=\"n\">SE3</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "sims.dmp_cartesian_ur5e.MjSim.init", "modulename": "sims.dmp_cartesian_ur5e", "qualname": "MjSim.init", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">mujoco</span><span class=\"o\">.</span><span class=\"n\">_structs</span><span class=\"o\">.</span><span class=\"n\">MjModel</span><span class=\"p\">,</span> <span class=\"n\">mujoco</span><span class=\"o\">.</span><span class=\"n\">_structs</span><span class=\"o\">.</span><span class=\"n\">MjData</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "sims.dmp_cartesian_ur5e.MjSim.log", "modulename": "sims.dmp_cartesian_ur5e", "qualname": "MjSim.log", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">ss</span><span class=\"p\">:</span> <span class=\"n\">sims</span><span class=\"o\">.</span><span class=\"n\">base_sim</span><span class=\"o\">.</span><span class=\"n\">SimSync</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sims.dmp_cartesian_ur5e.MjSim.spin", "modulename": "sims.dmp_cartesian_ur5e", "qualname": "MjSim.spin", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">ss</span><span class=\"p\">:</span> <span class=\"n\">sims</span><span class=\"o\">.</span><span class=\"n\">base_sim</span><span class=\"o\">.</span><span class=\"n\">SimSync</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sims.dmp_cartesian_ur5e.MjSim.data", "modulename": "sims.dmp_cartesian_ur5e", "qualname": "MjSim.data", "kind": "variable", "doc": "<p>Access the current simulation data.</p>\n\n<p>This property provides access to an instance of the <code>MjData</code> class, which contains the dynamic\nsimulation state. This includes quantities such as joint positions, velocities,\nactuator forces, and sensory information. The <code>MjData</code> object is updated at each simulation step\nand can be used to inspect the real-time state of said simulation.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>mj.MjData\n    An object representing the current dynamic state of the simulation.</p>\n", "annotation": ": mujoco._structs.MjData"}, {"fullname": "sims.dmp_cartesian_ur5e.MjSim.model", "modulename": "sims.dmp_cartesian_ur5e", "qualname": "MjSim.model", "kind": "variable", "doc": "<p>Access the model of the MuJoCo simulation.</p>\n\n<p>This property returns an instance of the <code>MjModel</code> class, which describes the physical and\nmechanical properties of the simulation. The <code>MjModel</code> object contains static information about the\nsimulation such as its kinematic trees, inertial properties, joint and actuator definitions, and geometry\nconfigurations. It is used to define the system's structure and behavior within the simulation.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>mj.MjModel\n    An object representing the static model of the system and overall MuJoCo simulation.</p>\n", "annotation": ": mujoco._structs.MjModel"}, {"fullname": "sims.dmp_cartesian_ur5e.MjSim.keyboard_callback", "modulename": "sims.dmp_cartesian_ur5e", "qualname": "MjSim.keyboard_callback", "kind": "function", "doc": "<p>Handle keyboard inputs during the simulation.</p>\n\n<p>This method is intended to be overridden in the child class to define how the simulation responds\nto specific keyboard inputs. The <code>key</code> parameter corresponds to the key pressed by the user,\nallowing for custom behavior (e.g., sending trajectories to robots' task queues, logging data\nor start/stopping processes).</p>\n\n<p>If this method is not implemented in the child class, a warning will be issued.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>key : int\n    The key pressed by the user represented by a key code.</p>\n\n<h2 id=\"raises\">Raises</h2>\n\n<p>UserWarning\n    If the method is not implemented in the child class.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">key</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "sims.dmp_cartesian_ur5e.setup_logging", "modulename": "sims.dmp_cartesian_ur5e", "qualname": "setup_logging", "kind": "function", "doc": "<p>Setup basic logging</p>\n\n<p>Args:\n  loglevel (int): minimum loglevel for emitting messages</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">loglevel</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sims.dmp_cartesian_ur5e.main", "modulename": "sims.dmp_cartesian_ur5e", "qualname": "main", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sims.finger", "modulename": "sims.finger", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "sims.finger.MjSim", "modulename": "sims.finger", "qualname": "MjSim", "kind": "class", "doc": "<p>Abstract base class for MuJoCo robot simulations.</p>\n\n<p>This class serves as the foundational framework for simulating robots in MuJoCo. It defines\nkey properties and methods that must be implemented in subclasses, including access to\nthe simulation's dynamic data (<code>MjData</code>), the static model (<code>MjModel</code>), and control mechanisms.</p>\n\n<p>Child classes are responsible for implementing the control logic (<code>control_loop</code>) and handling\nuser inputs via the keyboard (<code>keyboard_callback</code>). The <code>run</code> method provides a basic structure\nfor running the main simulation loop, handling viewer synchronization, and processing user inputs\nin real-time.</p>\n\n<p>This base class includes functionality to issue warnings if important methods, such as the control\nloop or keyboard callback, are not implemented in a subclass.</p>\n", "bases": "sims.base_sim.BaseSim"}, {"fullname": "sims.finger.MjSim.tasks", "modulename": "sims.finger", "qualname": "MjSim.tasks", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sims.finger.MjSim.init", "modulename": "sims.finger", "qualname": "MjSim.init", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sims.finger.MjSim.spin", "modulename": "sims.finger", "qualname": "MjSim.spin", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">ss</span><span class=\"p\">:</span> <span class=\"n\">sims</span><span class=\"o\">.</span><span class=\"n\">base_sim</span><span class=\"o\">.</span><span class=\"n\">SimSync</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sims.finger.MjSim.log", "modulename": "sims.finger", "qualname": "MjSim.log", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">ss</span><span class=\"p\">:</span> <span class=\"n\">sims</span><span class=\"o\">.</span><span class=\"n\">base_sim</span><span class=\"o\">.</span><span class=\"n\">SimSync</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sims.finger.MjSim.data", "modulename": "sims.finger", "qualname": "MjSim.data", "kind": "variable", "doc": "<p>Access the current simulation data.</p>\n\n<p>This property provides access to an instance of the <code>MjData</code> class, which contains the dynamic\nsimulation state. This includes quantities such as joint positions, velocities,\nactuator forces, and sensory information. The <code>MjData</code> object is updated at each simulation step\nand can be used to inspect the real-time state of said simulation.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>mj.MjData\n    An object representing the current dynamic state of the simulation.</p>\n", "annotation": ": mujoco._structs.MjData"}, {"fullname": "sims.finger.MjSim.model", "modulename": "sims.finger", "qualname": "MjSim.model", "kind": "variable", "doc": "<p>Access the model of the MuJoCo simulation.</p>\n\n<p>This property returns an instance of the <code>MjModel</code> class, which describes the physical and\nmechanical properties of the simulation. The <code>MjModel</code> object contains static information about the\nsimulation such as its kinematic trees, inertial properties, joint and actuator definitions, and geometry\nconfigurations. It is used to define the system's structure and behavior within the simulation.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>mj.MjModel\n    An object representing the static model of the system and overall MuJoCo simulation.</p>\n", "annotation": ": mujoco._structs.MjModel"}, {"fullname": "sims.finger.MjSim.keyboard_callback", "modulename": "sims.finger", "qualname": "MjSim.keyboard_callback", "kind": "function", "doc": "<p>Handle keyboard inputs during the simulation.</p>\n\n<p>This method is intended to be overridden in the child class to define how the simulation responds\nto specific keyboard inputs. The <code>key</code> parameter corresponds to the key pressed by the user,\nallowing for custom behavior (e.g., sending trajectories to robots' task queues, logging data\nor start/stopping processes).</p>\n\n<p>If this method is not implemented in the child class, a warning will be issued.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>key : int\n    The key pressed by the user represented by a key code.</p>\n\n<h2 id=\"raises\">Raises</h2>\n\n<p>UserWarning\n    If the method is not implemented in the child class.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">key</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sims.finger_gating", "modulename": "sims.finger_gating", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "sims.finger_gating.MjSim", "modulename": "sims.finger_gating", "qualname": "MjSim", "kind": "class", "doc": "<p>Abstract base class for MuJoCo robot simulations.</p>\n\n<p>This class serves as the foundational framework for simulating robots in MuJoCo. It defines\nkey properties and methods that must be implemented in subclasses, including access to\nthe simulation's dynamic data (<code>MjData</code>), the static model (<code>MjModel</code>), and control mechanisms.</p>\n\n<p>Child classes are responsible for implementing the control logic (<code>control_loop</code>) and handling\nuser inputs via the keyboard (<code>keyboard_callback</code>). The <code>run</code> method provides a basic structure\nfor running the main simulation loop, handling viewer synchronization, and processing user inputs\nin real-time.</p>\n\n<p>This base class includes functionality to issue warnings if important methods, such as the control\nloop or keyboard callback, are not implemented in a subclass.</p>\n", "bases": "sims.base_sim.BaseSim"}, {"fullname": "sims.finger_gating.MjSim.sh", "modulename": "sims.finger_gating", "qualname": "MjSim.sh", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sims.finger_gating.MjSim.mocap", "modulename": "sims.finger_gating", "qualname": "MjSim.mocap", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sims.finger_gating.MjSim.tasks", "modulename": "sims.finger_gating", "qualname": "MjSim.tasks", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sims.finger_gating.MjSim.begin", "modulename": "sims.finger_gating", "qualname": "MjSim.begin", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sims.finger_gating.MjSim.init", "modulename": "sims.finger_gating", "qualname": "MjSim.init", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sims.finger_gating.MjSim.script", "modulename": "sims.finger_gating", "qualname": "MjSim.script", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">ss</span><span class=\"p\">:</span> <span class=\"n\">sims</span><span class=\"o\">.</span><span class=\"n\">base_sim</span><span class=\"o\">.</span><span class=\"n\">SimSync</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sims.finger_gating.MjSim.log", "modulename": "sims.finger_gating", "qualname": "MjSim.log", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">ss</span><span class=\"p\">:</span> <span class=\"n\">sims</span><span class=\"o\">.</span><span class=\"n\">base_sim</span><span class=\"o\">.</span><span class=\"n\">SimSync</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sims.finger_gating.MjSim.data", "modulename": "sims.finger_gating", "qualname": "MjSim.data", "kind": "variable", "doc": "<p>Access the current simulation data.</p>\n\n<p>This property provides access to an instance of the <code>MjData</code> class, which contains the dynamic\nsimulation state. This includes quantities such as joint positions, velocities,\nactuator forces, and sensory information. The <code>MjData</code> object is updated at each simulation step\nand can be used to inspect the real-time state of said simulation.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>mj.MjData\n    An object representing the current dynamic state of the simulation.</p>\n", "annotation": ": mujoco._structs.MjData"}, {"fullname": "sims.finger_gating.MjSim.model", "modulename": "sims.finger_gating", "qualname": "MjSim.model", "kind": "variable", "doc": "<p>Access the model of the MuJoCo simulation.</p>\n\n<p>This property returns an instance of the <code>MjModel</code> class, which describes the physical and\nmechanical properties of the simulation. The <code>MjModel</code> object contains static information about the\nsimulation such as its kinematic trees, inertial properties, joint and actuator definitions, and geometry\nconfigurations. It is used to define the system's structure and behavior within the simulation.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>mj.MjModel\n    An object representing the static model of the system and overall MuJoCo simulation.</p>\n", "annotation": ": mujoco._structs.MjModel"}, {"fullname": "sims.finger_gating.MjSim.keyboard_callback", "modulename": "sims.finger_gating", "qualname": "MjSim.keyboard_callback", "kind": "function", "doc": "<p>Handle keyboard inputs during the simulation.</p>\n\n<p>This method is intended to be overridden in the child class to define how the simulation responds\nto specific keyboard inputs. The <code>key</code> parameter corresponds to the key pressed by the user,\nallowing for custom behavior (e.g., sending trajectories to robots' task queues, logging data\nor start/stopping processes).</p>\n\n<p>If this method is not implemented in the child class, a warning will be issued.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>key : int\n    The key pressed by the user represented by a key code.</p>\n\n<h2 id=\"raises\">Raises</h2>\n\n<p>UserWarning\n    If the method is not implemented in the child class.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">key</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sims.finger_gating.MjSim.control_loop", "modulename": "sims.finger_gating", "qualname": "MjSim.control_loop", "kind": "function", "doc": "<p>Main control loop for the robot simulation.</p>\n\n<p>This method is intended to be overridden in the child class to implement the robot's control\nlogic. The control loop is typically responsible for computing control signals based on the\ncurrent state of the simulation (e.g., sensor data) and applying these signals to the robot's\nactuators. The frequency of the control loop matches the simulation step rate.</p>\n\n<p>If this method is not implemented in the child class, a warning will be issued.</p>\n\n<h2 id=\"raises\">Raises</h2>\n\n<p>UserWarning\n    If the method is not implemented in the child class.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sims.gelsight_mini", "modulename": "sims.gelsight_mini", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "sims.gelsight_mini.MjSim", "modulename": "sims.gelsight_mini", "qualname": "MjSim", "kind": "class", "doc": "<p>Abstract base class for MuJoCo robot simulations.</p>\n\n<p>This class serves as the foundational framework for simulating robots in MuJoCo. It defines\nkey properties and methods that must be implemented in subclasses, including access to\nthe simulation's dynamic data (<code>MjData</code>), the static model (<code>MjModel</code>), and control mechanisms.</p>\n\n<p>Child classes are responsible for implementing the control logic (<code>control_loop</code>) and handling\nuser inputs via the keyboard (<code>keyboard_callback</code>). The <code>run</code> method provides a basic structure\nfor running the main simulation loop, handling viewer synchronization, and processing user inputs\nin real-time.</p>\n\n<p>This base class includes functionality to issue warnings if important methods, such as the control\nloop or keyboard callback, are not implemented in a subclass.</p>\n", "bases": "sims.base_sim.BaseSim"}, {"fullname": "sims.gelsight_mini.MjSim.gs", "modulename": "sims.gelsight_mini", "qualname": "MjSim.gs", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sims.gelsight_mini.MjSim.tasks", "modulename": "sims.gelsight_mini", "qualname": "MjSim.tasks", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sims.gelsight_mini.MjSim.init", "modulename": "sims.gelsight_mini", "qualname": "MjSim.init", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sims.gelsight_mini.MjSim.spin", "modulename": "sims.gelsight_mini", "qualname": "MjSim.spin", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">ss</span><span class=\"p\">:</span> <span class=\"n\">sims</span><span class=\"o\">.</span><span class=\"n\">base_sim</span><span class=\"o\">.</span><span class=\"n\">SimSync</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sims.gelsight_mini.MjSim.data", "modulename": "sims.gelsight_mini", "qualname": "MjSim.data", "kind": "variable", "doc": "<p>Access the current simulation data.</p>\n\n<p>This property provides access to an instance of the <code>MjData</code> class, which contains the dynamic\nsimulation state. This includes quantities such as joint positions, velocities,\nactuator forces, and sensory information. The <code>MjData</code> object is updated at each simulation step\nand can be used to inspect the real-time state of said simulation.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>mj.MjData\n    An object representing the current dynamic state of the simulation.</p>\n", "annotation": ": mujoco._structs.MjData"}, {"fullname": "sims.gelsight_mini.MjSim.model", "modulename": "sims.gelsight_mini", "qualname": "MjSim.model", "kind": "variable", "doc": "<p>Access the model of the MuJoCo simulation.</p>\n\n<p>This property returns an instance of the <code>MjModel</code> class, which describes the physical and\nmechanical properties of the simulation. The <code>MjModel</code> object contains static information about the\nsimulation such as its kinematic trees, inertial properties, joint and actuator definitions, and geometry\nconfigurations. It is used to define the system's structure and behavior within the simulation.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>mj.MjModel\n    An object representing the static model of the system and overall MuJoCo simulation.</p>\n", "annotation": ": mujoco._structs.MjModel"}, {"fullname": "sims.gelsight_mini.MjSim.keyboard_callback", "modulename": "sims.gelsight_mini", "qualname": "MjSim.keyboard_callback", "kind": "function", "doc": "<p>Handle keyboard inputs during the simulation.</p>\n\n<p>This method is intended to be overridden in the child class to define how the simulation responds\nto specific keyboard inputs. The <code>key</code> parameter corresponds to the key pressed by the user,\nallowing for custom behavior (e.g., sending trajectories to robots' task queues, logging data\nor start/stopping processes).</p>\n\n<p>If this method is not implemented in the child class, a warning will be issued.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>key : int\n    The key pressed by the user represented by a key code.</p>\n\n<h2 id=\"raises\">Raises</h2>\n\n<p>UserWarning\n    If the method is not implemented in the child class.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">key</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sims.hande", "modulename": "sims.hande", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "sims.hande.HandE", "modulename": "sims.hande", "qualname": "HandE", "kind": "class", "doc": "<p>Base class for robot simulation in MuJoCo.</p>\n\n<p>This class provides a framework for simulating robots in MuJoCo environments. It defines\nkey properties and methods that should be implemented in child classes, including access\nto the robot's model, data, and control mechanisms.</p>\n", "bases": "robots.base_robot.BaseRobot"}, {"fullname": "sims.hande.HandE.__init__", "modulename": "sims.hande", "qualname": "HandE.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">model</span><span class=\"p\">:</span> <span class=\"n\">mujoco</span><span class=\"o\">.</span><span class=\"n\">_structs</span><span class=\"o\">.</span><span class=\"n\">MjModel</span>, </span><span class=\"param\"><span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"n\">mujoco</span><span class=\"o\">.</span><span class=\"n\">_structs</span><span class=\"o\">.</span><span class=\"n\">MjData</span></span>)</span>"}, {"fullname": "sims.hande.HandE.name", "modulename": "sims.hande", "qualname": "HandE.name", "kind": "variable", "doc": "<p>Get the name of the robot.</p>\n\n<p>This property returns the name of the robot as a string. The name is typically a unique identifier\nused to distinguish between different robots in the simulation environment.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>str\n    The name of the robot as a string.</p>\n", "annotation": ": str"}, {"fullname": "sims.hande.HandE.model", "modulename": "sims.hande", "qualname": "HandE.model", "kind": "variable", "doc": "<p>Access the model of the MuJoCo simulation.</p>\n\n<p>This property returns an instance of the <code>MjModel</code> class, which describes the physical and\nmechanical properties of the simulation. The <code>MjModel</code> object contains static information about the\nrobot such as its kinematic tree, inertial properties, joint and actuator definitions, and geometry\nconfigurations. It is used to define the robot's structure and behavior within the simulation.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>mj.MjModel\n    An object representing the static model of the robot and overall MuJoCo simulation.</p>\n", "annotation": ": mujoco._structs.MjModel"}, {"fullname": "sims.hande.HandE.data", "modulename": "sims.hande", "qualname": "HandE.data", "kind": "variable", "doc": "<p>Access the current simulation data.</p>\n\n<p>This property provides access to an instance of the <code>MjData</code> class, which contains the dynamic\nsimulation state. This includes quantities such as joint positions, velocities,\nactuator forces, and sensory information. The <code>MjData</code> object is updated at each simulation step\nand can be used to inspect the real-time state of the robot during the simulation.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>mj.MjData\n    An object representing the current dynamic state of the simulation.</p>\n", "annotation": ": mujoco._structs.MjData"}, {"fullname": "sims.hande.HandE.info", "modulename": "sims.hande", "qualname": "HandE.info", "kind": "variable", "doc": "<p>Get detailed information about the robot.</p>\n\n<p>This property returns an instance of the <code>RobotInfo</code> class, which provides comprehensive\ndetails about the robot's structure and components. This includes information on the robot's\nbodies, joints, actuators, and geometries, among other attributes. The <code>RobotInfo</code> instance\ncan be used to access various properties such as the number of joints, actuator limits, joint\nlimits, and more.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>RobotInfo\n    An object containing detailed information about the robot's configuration and components.</p>\n", "annotation": ": utils.mj.RobotInfo"}, {"fullname": "sims.hande.HandE.step", "modulename": "sims.hande", "qualname": "HandE.step", "kind": "variable", "doc": "<p>Perform a step in the controller.</p>\n\n<p>This method calls the <code>step()</code> method of the controller object and\nbefore doing so it checks if there are any tasks to be performed in\nthe robot task queue</p>\n", "annotation": ": None"}, {"fullname": "sims.hande.MjSim", "modulename": "sims.hande", "qualname": "MjSim", "kind": "class", "doc": "<p>Abstract base class for MuJoCo robot simulations.</p>\n\n<p>This class serves as the foundational framework for simulating robots in MuJoCo. It defines\nkey properties and methods that must be implemented in subclasses, including access to\nthe simulation's dynamic data (<code>MjData</code>), the static model (<code>MjModel</code>), and control mechanisms.</p>\n\n<p>Child classes are responsible for implementing the control logic (<code>control_loop</code>) and handling\nuser inputs via the keyboard (<code>keyboard_callback</code>). The <code>run</code> method provides a basic structure\nfor running the main simulation loop, handling viewer synchronization, and processing user inputs\nin real-time.</p>\n\n<p>This base class includes functionality to issue warnings if important methods, such as the control\nloop or keyboard callback, are not implemented in a subclass.</p>\n", "bases": "sims.base_sim.BaseSim"}, {"fullname": "sims.hande.MjSim.hande", "modulename": "sims.hande", "qualname": "MjSim.hande", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sims.hande.MjSim.tasks", "modulename": "sims.hande", "qualname": "MjSim.tasks", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sims.hande.MjSim.init", "modulename": "sims.hande", "qualname": "MjSim.init", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sims.hande.MjSim.spin", "modulename": "sims.hande", "qualname": "MjSim.spin", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">ss</span><span class=\"p\">:</span> <span class=\"n\">sims</span><span class=\"o\">.</span><span class=\"n\">base_sim</span><span class=\"o\">.</span><span class=\"n\">SimSync</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sims.hande.MjSim.data", "modulename": "sims.hande", "qualname": "MjSim.data", "kind": "variable", "doc": "<p>Access the current simulation data.</p>\n\n<p>This property provides access to an instance of the <code>MjData</code> class, which contains the dynamic\nsimulation state. This includes quantities such as joint positions, velocities,\nactuator forces, and sensory information. The <code>MjData</code> object is updated at each simulation step\nand can be used to inspect the real-time state of said simulation.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>mj.MjData\n    An object representing the current dynamic state of the simulation.</p>\n", "annotation": ": mujoco._structs.MjData"}, {"fullname": "sims.hande.MjSim.model", "modulename": "sims.hande", "qualname": "MjSim.model", "kind": "variable", "doc": "<p>Access the model of the MuJoCo simulation.</p>\n\n<p>This property returns an instance of the <code>MjModel</code> class, which describes the physical and\nmechanical properties of the simulation. The <code>MjModel</code> object contains static information about the\nsimulation such as its kinematic trees, inertial properties, joint and actuator definitions, and geometry\nconfigurations. It is used to define the system's structure and behavior within the simulation.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>mj.MjModel\n    An object representing the static model of the system and overall MuJoCo simulation.</p>\n", "annotation": ": mujoco._structs.MjModel"}, {"fullname": "sims.hande.MjSim.keyboard_callback", "modulename": "sims.hande", "qualname": "MjSim.keyboard_callback", "kind": "function", "doc": "<p>Handle keyboard inputs during the simulation.</p>\n\n<p>This method is intended to be overridden in the child class to define how the simulation responds\nto specific keyboard inputs. The <code>key</code> parameter corresponds to the key pressed by the user,\nallowing for custom behavior (e.g., sending trajectories to robots' task queues, logging data\nor start/stopping processes).</p>\n\n<p>If this method is not implemented in the child class, a warning will be issued.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>key : int\n    The key pressed by the user represented by a key code.</p>\n\n<h2 id=\"raises\">Raises</h2>\n\n<p>UserWarning\n    If the method is not implemented in the child class.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">key</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sims.mjx_in_hand_manipulation", "modulename": "sims.mjx_in_hand_manipulation", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "sims.mjx_in_hand_manipulation.tip_cfg", "modulename": "sims.mjx_in_hand_manipulation", "qualname": "tip_cfg", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"nb\">id</span><span class=\"p\">:</span> <span class=\"nb\">int</span>, </span><span class=\"param\"><span class=\"n\">thumb</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sims.mjx_in_hand_manipulation.N_SENSORS", "modulename": "sims.mjx_in_hand_manipulation", "qualname": "N_SENSORS", "kind": "variable", "doc": "<p></p>\n", "default_value": "17"}, {"fullname": "sims.mjx_in_hand_manipulation.MjSim", "modulename": "sims.mjx_in_hand_manipulation", "qualname": "MjSim", "kind": "class", "doc": "<p>Abstract base class for MuJoCo robot simulations.</p>\n\n<p>This class serves as the foundational framework for simulating robots in MuJoCo. It defines\nkey properties and methods that must be implemented in subclasses, including access to\nthe simulation's dynamic data (<code>MjData</code>), the static model (<code>MjModel</code>), and control mechanisms.</p>\n\n<p>Child classes are responsible for implementing the control logic (<code>control_loop</code>) and handling\nuser inputs via the keyboard (<code>keyboard_callback</code>). The <code>run</code> method provides a basic structure\nfor running the main simulation loop, handling viewer synchronization, and processing user inputs\nin real-time.</p>\n\n<p>This base class includes functionality to issue warnings if important methods, such as the control\nloop or keyboard callback, are not implemented in a subclass.</p>\n", "bases": "sims.base_sim.BaseSim"}, {"fullname": "sims.mjx_in_hand_manipulation.MjSim.sh", "modulename": "sims.mjx_in_hand_manipulation", "qualname": "MjSim.sh", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sims.mjx_in_hand_manipulation.MjSim.mocap", "modulename": "sims.mjx_in_hand_manipulation", "qualname": "MjSim.mocap", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sims.mjx_in_hand_manipulation.MjSim.tasks", "modulename": "sims.mjx_in_hand_manipulation", "qualname": "MjSim.tasks", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sims.mjx_in_hand_manipulation.MjSim.begin", "modulename": "sims.mjx_in_hand_manipulation", "qualname": "MjSim.begin", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sims.mjx_in_hand_manipulation.MjSim.N_SENSORS", "modulename": "sims.mjx_in_hand_manipulation", "qualname": "MjSim.N_SENSORS", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sims.mjx_in_hand_manipulation.MjSim.init", "modulename": "sims.mjx_in_hand_manipulation", "qualname": "MjSim.init", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sims.mjx_in_hand_manipulation.MjSim.script", "modulename": "sims.mjx_in_hand_manipulation", "qualname": "MjSim.script", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">ss</span><span class=\"p\">:</span> <span class=\"n\">sims</span><span class=\"o\">.</span><span class=\"n\">base_sim</span><span class=\"o\">.</span><span class=\"n\">SimSync</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sims.mjx_in_hand_manipulation.MjSim.log", "modulename": "sims.mjx_in_hand_manipulation", "qualname": "MjSim.log", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">ss</span><span class=\"p\">:</span> <span class=\"n\">sims</span><span class=\"o\">.</span><span class=\"n\">base_sim</span><span class=\"o\">.</span><span class=\"n\">SimSync</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sims.mjx_in_hand_manipulation.MjSim.spin", "modulename": "sims.mjx_in_hand_manipulation", "qualname": "MjSim.spin", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">ss</span><span class=\"p\">:</span> <span class=\"n\">sims</span><span class=\"o\">.</span><span class=\"n\">base_sim</span><span class=\"o\">.</span><span class=\"n\">SimSync</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "sims.mjx_in_hand_manipulation.MjSim.data", "modulename": "sims.mjx_in_hand_manipulation", "qualname": "MjSim.data", "kind": "variable", "doc": "<p>Access the current simulation data.</p>\n\n<p>This property provides access to an instance of the <code>MjData</code> class, which contains the dynamic\nsimulation state. This includes quantities such as joint positions, velocities,\nactuator forces, and sensory information. The <code>MjData</code> object is updated at each simulation step\nand can be used to inspect the real-time state of said simulation.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>mj.MjData\n    An object representing the current dynamic state of the simulation.</p>\n", "annotation": ": mujoco._structs.MjData"}, {"fullname": "sims.mjx_in_hand_manipulation.MjSim.model", "modulename": "sims.mjx_in_hand_manipulation", "qualname": "MjSim.model", "kind": "variable", "doc": "<p>Access the model of the MuJoCo simulation.</p>\n\n<p>This property returns an instance of the <code>MjModel</code> class, which describes the physical and\nmechanical properties of the simulation. The <code>MjModel</code> object contains static information about the\nsimulation such as its kinematic trees, inertial properties, joint and actuator definitions, and geometry\nconfigurations. It is used to define the system's structure and behavior within the simulation.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>mj.MjModel\n    An object representing the static model of the system and overall MuJoCo simulation.</p>\n", "annotation": ": mujoco._structs.MjModel"}, {"fullname": "sims.mjx_in_hand_manipulation.MjSim.keyboard_callback", "modulename": "sims.mjx_in_hand_manipulation", "qualname": "MjSim.keyboard_callback", "kind": "function", "doc": "<p>Handle keyboard inputs during the simulation.</p>\n\n<p>This method is intended to be overridden in the child class to define how the simulation responds\nto specific keyboard inputs. The <code>key</code> parameter corresponds to the key pressed by the user,\nallowing for custom behavior (e.g., sending trajectories to robots' task queues, logging data\nor start/stopping processes).</p>\n\n<p>If this method is not implemented in the child class, a warning will be issued.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>key : int\n    The key pressed by the user represented by a key code.</p>\n\n<h2 id=\"raises\">Raises</h2>\n\n<p>UserWarning\n    If the method is not implemented in the child class.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">key</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sims.mjx_in_hand_manipulation.MjSim.control_loop", "modulename": "sims.mjx_in_hand_manipulation", "qualname": "MjSim.control_loop", "kind": "function", "doc": "<p>Main control loop for the robot simulation.</p>\n\n<p>This method is intended to be overridden in the child class to implement the robot's control\nlogic. The control loop is typically responsible for computing control signals based on the\ncurrent state of the simulation (e.g., sensor data) and applying these signals to the robot's\nactuators. The frequency of the control loop matches the simulation step rate.</p>\n\n<p>If this method is not implemented in the child class, a warning will be issued.</p>\n\n<h2 id=\"raises\">Raises</h2>\n\n<p>UserWarning\n    If the method is not implemented in the child class.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sims.new_shadow_hand", "modulename": "sims.new_shadow_hand", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "sims.new_shadow_hand.tip_cfg", "modulename": "sims.new_shadow_hand", "qualname": "tip_cfg", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"nb\">id</span><span class=\"p\">:</span> <span class=\"nb\">int</span>, </span><span class=\"param\"><span class=\"n\">thumb</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sims.new_shadow_hand.N_SENSORS", "modulename": "sims.new_shadow_hand", "qualname": "N_SENSORS", "kind": "variable", "doc": "<p></p>\n", "default_value": "17"}, {"fullname": "sims.new_shadow_hand.MjSim", "modulename": "sims.new_shadow_hand", "qualname": "MjSim", "kind": "class", "doc": "<p>Abstract base class for MuJoCo robot simulations.</p>\n\n<p>This class serves as the foundational framework for simulating robots in MuJoCo. It defines\nkey properties and methods that must be implemented in subclasses, including access to\nthe simulation's dynamic data (<code>MjData</code>), the static model (<code>MjModel</code>), and control mechanisms.</p>\n\n<p>Child classes are responsible for implementing the control logic (<code>control_loop</code>) and handling\nuser inputs via the keyboard (<code>keyboard_callback</code>). The <code>run</code> method provides a basic structure\nfor running the main simulation loop, handling viewer synchronization, and processing user inputs\nin real-time.</p>\n\n<p>This base class includes functionality to issue warnings if important methods, such as the control\nloop or keyboard callback, are not implemented in a subclass.</p>\n", "bases": "sims.base_sim.BaseSim"}, {"fullname": "sims.new_shadow_hand.MjSim.sh", "modulename": "sims.new_shadow_hand", "qualname": "MjSim.sh", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sims.new_shadow_hand.MjSim.mocap", "modulename": "sims.new_shadow_hand", "qualname": "MjSim.mocap", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sims.new_shadow_hand.MjSim.tasks", "modulename": "sims.new_shadow_hand", "qualname": "MjSim.tasks", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sims.new_shadow_hand.MjSim.begin", "modulename": "sims.new_shadow_hand", "qualname": "MjSim.begin", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sims.new_shadow_hand.MjSim.N_SENSORS", "modulename": "sims.new_shadow_hand", "qualname": "MjSim.N_SENSORS", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sims.new_shadow_hand.MjSim.init", "modulename": "sims.new_shadow_hand", "qualname": "MjSim.init", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sims.new_shadow_hand.MjSim.script", "modulename": "sims.new_shadow_hand", "qualname": "MjSim.script", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">ss</span><span class=\"p\">:</span> <span class=\"n\">sims</span><span class=\"o\">.</span><span class=\"n\">base_sim</span><span class=\"o\">.</span><span class=\"n\">SimSync</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sims.new_shadow_hand.MjSim.log", "modulename": "sims.new_shadow_hand", "qualname": "MjSim.log", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">ss</span><span class=\"p\">:</span> <span class=\"n\">sims</span><span class=\"o\">.</span><span class=\"n\">base_sim</span><span class=\"o\">.</span><span class=\"n\">SimSync</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sims.new_shadow_hand.MjSim.data", "modulename": "sims.new_shadow_hand", "qualname": "MjSim.data", "kind": "variable", "doc": "<p>Access the current simulation data.</p>\n\n<p>This property provides access to an instance of the <code>MjData</code> class, which contains the dynamic\nsimulation state. This includes quantities such as joint positions, velocities,\nactuator forces, and sensory information. The <code>MjData</code> object is updated at each simulation step\nand can be used to inspect the real-time state of said simulation.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>mj.MjData\n    An object representing the current dynamic state of the simulation.</p>\n", "annotation": ": mujoco._structs.MjData"}, {"fullname": "sims.new_shadow_hand.MjSim.model", "modulename": "sims.new_shadow_hand", "qualname": "MjSim.model", "kind": "variable", "doc": "<p>Access the model of the MuJoCo simulation.</p>\n\n<p>This property returns an instance of the <code>MjModel</code> class, which describes the physical and\nmechanical properties of the simulation. The <code>MjModel</code> object contains static information about the\nsimulation such as its kinematic trees, inertial properties, joint and actuator definitions, and geometry\nconfigurations. It is used to define the system's structure and behavior within the simulation.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>mj.MjModel\n    An object representing the static model of the system and overall MuJoCo simulation.</p>\n", "annotation": ": mujoco._structs.MjModel"}, {"fullname": "sims.new_shadow_hand.MjSim.keyboard_callback", "modulename": "sims.new_shadow_hand", "qualname": "MjSim.keyboard_callback", "kind": "function", "doc": "<p>Handle keyboard inputs during the simulation.</p>\n\n<p>This method is intended to be overridden in the child class to define how the simulation responds\nto specific keyboard inputs. The <code>key</code> parameter corresponds to the key pressed by the user,\nallowing for custom behavior (e.g., sending trajectories to robots' task queues, logging data\nor start/stopping processes).</p>\n\n<p>If this method is not implemented in the child class, a warning will be issued.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>key : int\n    The key pressed by the user represented by a key code.</p>\n\n<h2 id=\"raises\">Raises</h2>\n\n<p>UserWarning\n    If the method is not implemented in the child class.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">key</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sims.new_shadow_hand.MjSim.control_loop", "modulename": "sims.new_shadow_hand", "qualname": "MjSim.control_loop", "kind": "function", "doc": "<p>Main control loop for the robot simulation.</p>\n\n<p>This method is intended to be overridden in the child class to implement the robot's control\nlogic. The control loop is typically responsible for computing control signals based on the\ncurrent state of the simulation (e.g., sensor data) and applying these signals to the robot's\nactuators. The frequency of the control loop matches the simulation step rate.</p>\n\n<p>If this method is not implemented in the child class, a warning will be issued.</p>\n\n<h2 id=\"raises\">Raises</h2>\n\n<p>UserWarning\n    If the method is not implemented in the child class.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sims.opspace_ur5e", "modulename": "sims.opspace_ur5e", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "sims.opspace_ur5e.MjSim", "modulename": "sims.opspace_ur5e", "qualname": "MjSim", "kind": "class", "doc": "<p>Abstract base class for MuJoCo robot simulations.</p>\n\n<p>This class serves as the foundational framework for simulating robots in MuJoCo. It defines\nkey properties and methods that must be implemented in subclasses, including access to\nthe simulation's dynamic data (<code>MjData</code>), the static model (<code>MjModel</code>), and control mechanisms.</p>\n\n<p>Child classes are responsible for implementing the control logic (<code>control_loop</code>) and handling\nuser inputs via the keyboard (<code>keyboard_callback</code>). The <code>run</code> method provides a basic structure\nfor running the main simulation loop, handling viewer synchronization, and processing user inputs\nin real-time.</p>\n\n<p>This base class includes functionality to issue warnings if important methods, such as the control\nloop or keyboard callback, are not implemented in a subclass.</p>\n", "bases": "sims.base_sim.BaseSim"}, {"fullname": "sims.opspace_ur5e.MjSim.ur5e", "modulename": "sims.opspace_ur5e", "qualname": "MjSim.ur5e", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sims.opspace_ur5e.MjSim.tasks", "modulename": "sims.opspace_ur5e", "qualname": "MjSim.tasks", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sims.opspace_ur5e.MjSim.init", "modulename": "sims.opspace_ur5e", "qualname": "MjSim.init", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">mujoco</span><span class=\"o\">.</span><span class=\"n\">_structs</span><span class=\"o\">.</span><span class=\"n\">MjModel</span><span class=\"p\">,</span> <span class=\"n\">mujoco</span><span class=\"o\">.</span><span class=\"n\">_structs</span><span class=\"o\">.</span><span class=\"n\">MjData</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "sims.opspace_ur5e.MjSim.move", "modulename": "sims.opspace_ur5e", "qualname": "MjSim.move", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">ss</span><span class=\"p\">:</span> <span class=\"n\">sims</span><span class=\"o\">.</span><span class=\"n\">base_sim</span><span class=\"o\">.</span><span class=\"n\">SimSync</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sims.opspace_ur5e.MjSim.log", "modulename": "sims.opspace_ur5e", "qualname": "MjSim.log", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">ss</span><span class=\"p\">:</span> <span class=\"n\">sims</span><span class=\"o\">.</span><span class=\"n\">base_sim</span><span class=\"o\">.</span><span class=\"n\">SimSync</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sims.opspace_ur5e.MjSim.spin", "modulename": "sims.opspace_ur5e", "qualname": "MjSim.spin", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">ss</span><span class=\"p\">:</span> <span class=\"n\">sims</span><span class=\"o\">.</span><span class=\"n\">base_sim</span><span class=\"o\">.</span><span class=\"n\">SimSync</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sims.opspace_ur5e.MjSim.data", "modulename": "sims.opspace_ur5e", "qualname": "MjSim.data", "kind": "variable", "doc": "<p>Access the current simulation data.</p>\n\n<p>This property provides access to an instance of the <code>MjData</code> class, which contains the dynamic\nsimulation state. This includes quantities such as joint positions, velocities,\nactuator forces, and sensory information. The <code>MjData</code> object is updated at each simulation step\nand can be used to inspect the real-time state of said simulation.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>mj.MjData\n    An object representing the current dynamic state of the simulation.</p>\n", "annotation": ": mujoco._structs.MjData"}, {"fullname": "sims.opspace_ur5e.MjSim.model", "modulename": "sims.opspace_ur5e", "qualname": "MjSim.model", "kind": "variable", "doc": "<p>Access the model of the MuJoCo simulation.</p>\n\n<p>This property returns an instance of the <code>MjModel</code> class, which describes the physical and\nmechanical properties of the simulation. The <code>MjModel</code> object contains static information about the\nsimulation such as its kinematic trees, inertial properties, joint and actuator definitions, and geometry\nconfigurations. It is used to define the system's structure and behavior within the simulation.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>mj.MjModel\n    An object representing the static model of the system and overall MuJoCo simulation.</p>\n", "annotation": ": mujoco._structs.MjModel"}, {"fullname": "sims.opspace_ur5e.MjSim.keyboard_callback", "modulename": "sims.opspace_ur5e", "qualname": "MjSim.keyboard_callback", "kind": "function", "doc": "<p>Handle keyboard inputs during the simulation.</p>\n\n<p>This method is intended to be overridden in the child class to define how the simulation responds\nto specific keyboard inputs. The <code>key</code> parameter corresponds to the key pressed by the user,\nallowing for custom behavior (e.g., sending trajectories to robots' task queues, logging data\nor start/stopping processes).</p>\n\n<p>If this method is not implemented in the child class, a warning will be issued.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>key : int\n    The key pressed by the user represented by a key code.</p>\n\n<h2 id=\"raises\">Raises</h2>\n\n<p>UserWarning\n    If the method is not implemented in the child class.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">key</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "sims.opspace_ur5e.setup_logging", "modulename": "sims.opspace_ur5e", "qualname": "setup_logging", "kind": "function", "doc": "<p>Setup basic logging</p>\n\n<p>Args:\n  loglevel (int): minimum loglevel for emitting messages</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">loglevel</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sims.opspace_ur5e.main", "modulename": "sims.opspace_ur5e", "qualname": "main", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sims.panda_cable_weaving", "modulename": "sims.panda_cable_weaving", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "sims.panda_cable_weaving.Gripper", "modulename": "sims.panda_cable_weaving", "qualname": "Gripper", "kind": "class", "doc": "<p>Base class for robot simulation in MuJoCo.</p>\n\n<p>This class provides a framework for simulating robots in MuJoCo environments. It defines\nkey properties and methods that should be implemented in child classes, including access\nto the robot's model, data, and control mechanisms.</p>\n", "bases": "robots.base_robot.BaseRobot"}, {"fullname": "sims.panda_cable_weaving.Gripper.__init__", "modulename": "sims.panda_cable_weaving", "qualname": "Gripper.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">model</span><span class=\"p\">:</span> <span class=\"n\">mujoco</span><span class=\"o\">.</span><span class=\"n\">_structs</span><span class=\"o\">.</span><span class=\"n\">MjModel</span>, </span><span class=\"param\"><span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"n\">mujoco</span><span class=\"o\">.</span><span class=\"n\">_structs</span><span class=\"o\">.</span><span class=\"n\">MjData</span></span>)</span>"}, {"fullname": "sims.panda_cable_weaving.Gripper.name", "modulename": "sims.panda_cable_weaving", "qualname": "Gripper.name", "kind": "variable", "doc": "<p>Get the name of the robot.</p>\n\n<p>This property returns the name of the robot as a string. The name is typically a unique identifier\nused to distinguish between different robots in the simulation environment.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>str\n    The name of the robot as a string.</p>\n", "annotation": ": str"}, {"fullname": "sims.panda_cable_weaving.Gripper.get_ee_pose", "modulename": "sims.panda_cable_weaving", "qualname": "Gripper.get_ee_pose", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">spatialmath</span><span class=\"o\">.</span><span class=\"n\">pose3d</span><span class=\"o\">.</span><span class=\"n\">SE3</span>:</span></span>", "funcdef": "def"}, {"fullname": "sims.panda_cable_weaving.Gripper.data", "modulename": "sims.panda_cable_weaving", "qualname": "Gripper.data", "kind": "variable", "doc": "<p>Access the current simulation data.</p>\n\n<p>This property provides access to an instance of the <code>MjData</code> class, which contains the dynamic\nsimulation state. This includes quantities such as joint positions, velocities,\nactuator forces, and sensory information. The <code>MjData</code> object is updated at each simulation step\nand can be used to inspect the real-time state of the robot during the simulation.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>mj.MjData\n    An object representing the current dynamic state of the simulation.</p>\n", "annotation": ": mujoco._structs.MjData"}, {"fullname": "sims.panda_cable_weaving.Gripper.model", "modulename": "sims.panda_cable_weaving", "qualname": "Gripper.model", "kind": "variable", "doc": "<p>Access the model of the MuJoCo simulation.</p>\n\n<p>This property returns an instance of the <code>MjModel</code> class, which describes the physical and\nmechanical properties of the simulation. The <code>MjModel</code> object contains static information about the\nrobot such as its kinematic tree, inertial properties, joint and actuator definitions, and geometry\nconfigurations. It is used to define the robot's structure and behavior within the simulation.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>mj.MjModel\n    An object representing the static model of the robot and overall MuJoCo simulation.</p>\n", "annotation": ": mujoco._structs.MjModel"}, {"fullname": "sims.panda_cable_weaving.Gripper.info", "modulename": "sims.panda_cable_weaving", "qualname": "Gripper.info", "kind": "variable", "doc": "<p>Get detailed information about the robot.</p>\n\n<p>This property returns an instance of the <code>RobotInfo</code> class, which provides comprehensive\ndetails about the robot's structure and components. This includes information on the robot's\nbodies, joints, actuators, and geometries, among other attributes. The <code>RobotInfo</code> instance\ncan be used to access various properties such as the number of joints, actuator limits, joint\nlimits, and more.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>RobotInfo\n    An object containing detailed information about the robot's configuration and components.</p>\n", "annotation": ": utils.mj.RobotInfo"}, {"fullname": "sims.panda_cable_weaving.Gripper.step", "modulename": "sims.panda_cable_weaving", "qualname": "Gripper.step", "kind": "function", "doc": "<p>Perform a step in the controller.</p>\n\n<p>This method calls the <code>step()</code> method of the controller object and\nbefore doing so it checks if there are any tasks to be performed in\nthe robot task queue</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sims.panda_cable_weaving.MjSim", "modulename": "sims.panda_cable_weaving", "qualname": "MjSim", "kind": "class", "doc": "<p>Abstract base class for MuJoCo robot simulations.</p>\n\n<p>This class serves as the foundational framework for simulating robots in MuJoCo. It defines\nkey properties and methods that must be implemented in subclasses, including access to\nthe simulation's dynamic data (<code>MjData</code>), the static model (<code>MjModel</code>), and control mechanisms.</p>\n\n<p>Child classes are responsible for implementing the control logic (<code>control_loop</code>) and handling\nuser inputs via the keyboard (<code>keyboard_callback</code>). The <code>run</code> method provides a basic structure\nfor running the main simulation loop, handling viewer synchronization, and processing user inputs\nin real-time.</p>\n\n<p>This base class includes functionality to issue warnings if important methods, such as the control\nloop or keyboard callback, are not implemented in a subclass.</p>\n", "bases": "sims.base_sim.BaseSim"}, {"fullname": "sims.panda_cable_weaving.MjSim.gripper", "modulename": "sims.panda_cable_weaving", "qualname": "MjSim.gripper", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sims.panda_cable_weaving.MjSim.mocap", "modulename": "sims.panda_cable_weaving", "qualname": "MjSim.mocap", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sims.panda_cable_weaving.MjSim.T_mocap_tcp", "modulename": "sims.panda_cable_weaving", "qualname": "MjSim.T_mocap_tcp", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sims.panda_cable_weaving.MjSim.spec", "modulename": "sims.panda_cable_weaving", "qualname": "MjSim.spec", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sims.panda_cable_weaving.MjSim.tasks", "modulename": "sims.panda_cable_weaving", "qualname": "MjSim.tasks", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sims.panda_cable_weaving.MjSim.h", "modulename": "sims.panda_cable_weaving", "qualname": "MjSim.h", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sims.panda_cable_weaving.MjSim.theta", "modulename": "sims.panda_cable_weaving", "qualname": "MjSim.theta", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sims.panda_cable_weaving.MjSim.delta", "modulename": "sims.panda_cable_weaving", "qualname": "MjSim.delta", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sims.panda_cable_weaving.MjSim.begin", "modulename": "sims.panda_cable_weaving", "qualname": "MjSim.begin", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sims.panda_cable_weaving.MjSim.init", "modulename": "sims.panda_cable_weaving", "qualname": "MjSim.init", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sims.panda_cable_weaving.MjSim.spin", "modulename": "sims.panda_cable_weaving", "qualname": "MjSim.spin", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">ss</span><span class=\"p\">:</span> <span class=\"n\">sims</span><span class=\"o\">.</span><span class=\"n\">base_sim</span><span class=\"o\">.</span><span class=\"n\">SimSync</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sims.panda_cable_weaving.MjSim.get_check_point_frames", "modulename": "sims.panda_cable_weaving", "qualname": "MjSim.get_check_point_frames", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">spatialmath</span><span class=\"o\">.</span><span class=\"n\">pose3d</span><span class=\"o\">.</span><span class=\"n\">SE3</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "sims.panda_cable_weaving.MjSim.weaving", "modulename": "sims.panda_cable_weaving", "qualname": "MjSim.weaving", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">ss</span><span class=\"p\">:</span> <span class=\"n\">sims</span><span class=\"o\">.</span><span class=\"n\">base_sim</span><span class=\"o\">.</span><span class=\"n\">SimSync</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sims.panda_cable_weaving.MjSim.data", "modulename": "sims.panda_cable_weaving", "qualname": "MjSim.data", "kind": "variable", "doc": "<p>Access the current simulation data.</p>\n\n<p>This property provides access to an instance of the <code>MjData</code> class, which contains the dynamic\nsimulation state. This includes quantities such as joint positions, velocities,\nactuator forces, and sensory information. The <code>MjData</code> object is updated at each simulation step\nand can be used to inspect the real-time state of said simulation.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>mj.MjData\n    An object representing the current dynamic state of the simulation.</p>\n", "annotation": ": mujoco._structs.MjData"}, {"fullname": "sims.panda_cable_weaving.MjSim.model", "modulename": "sims.panda_cable_weaving", "qualname": "MjSim.model", "kind": "variable", "doc": "<p>Access the model of the MuJoCo simulation.</p>\n\n<p>This property returns an instance of the <code>MjModel</code> class, which describes the physical and\nmechanical properties of the simulation. The <code>MjModel</code> object contains static information about the\nsimulation such as its kinematic trees, inertial properties, joint and actuator definitions, and geometry\nconfigurations. It is used to define the system's structure and behavior within the simulation.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>mj.MjModel\n    An object representing the static model of the system and overall MuJoCo simulation.</p>\n", "annotation": ": mujoco._structs.MjModel"}, {"fullname": "sims.panda_cable_weaving.MjSim.keyboard_callback", "modulename": "sims.panda_cable_weaving", "qualname": "MjSim.keyboard_callback", "kind": "function", "doc": "<p>Handle keyboard inputs during the simulation.</p>\n\n<p>This method is intended to be overridden in the child class to define how the simulation responds\nto specific keyboard inputs. The <code>key</code> parameter corresponds to the key pressed by the user,\nallowing for custom behavior (e.g., sending trajectories to robots' task queues, logging data\nor start/stopping processes).</p>\n\n<p>If this method is not implemented in the child class, a warning will be issued.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>key : int\n    The key pressed by the user represented by a key code.</p>\n\n<h2 id=\"raises\">Raises</h2>\n\n<p>UserWarning\n    If the method is not implemented in the child class.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">key</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sims.panda_cable_weaving.MjSim.init_orientation", "modulename": "sims.panda_cable_weaving", "qualname": "MjSim.init_orientation", "kind": "function", "doc": "<p>Align the TCP's y-axis to point directly away from a specified object.</p>\n\n<p>Parameters:</p>\n\n<ul>\n<li>geom_name (str): Name of the geometry to align away from.</li>\n<li>vel (float): Desired rotation velocity in radians per second (currently unused).</li>\n<li>T_init (sm.SE3, optional): Initial pose of the TCP. If None, fetches the current TCP pose.</li>\n</ul>\n\n<p>Returns:</p>\n\n<ul>\n<li>sm.SE3: The target pose after rotation.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">geom_name</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">vel</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.3</span>,</span><span class=\"param\">\t<span class=\"n\">T_init</span><span class=\"p\">:</span> <span class=\"n\">spatialmath</span><span class=\"o\">.</span><span class=\"n\">pose3d</span><span class=\"o\">.</span><span class=\"n\">SE3</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sims.panda_cable_weaving.MjSim.move_close", "modulename": "sims.panda_cable_weaving", "qualname": "MjSim.move_close", "kind": "function", "doc": "<p>Move towards the object specified by geom_name until within a given radius.</p>\n\n<p>Parameters:</p>\n\n<ul>\n<li>geom_name: str, the name of the geometry to move towards.</li>\n<li>radius: float, the distance to maintain from the object.</li>\n<li>vel: float, the velocity of the movement.</li>\n</ul>\n\n<p>Returns:</p>\n\n<ul>\n<li>sm.SE3: Pose radius away from a geometry.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">geom_name</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">radius</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.06</span>,</span><span class=\"param\">\t<span class=\"n\">T_init</span><span class=\"p\">:</span> <span class=\"n\">spatialmath</span><span class=\"o\">.</span><span class=\"n\">pose3d</span><span class=\"o\">.</span><span class=\"n\">SE3</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">spatialmath</span><span class=\"o\">.</span><span class=\"n\">pose3d</span><span class=\"o\">.</span><span class=\"n\">SE3</span>:</span></span>", "funcdef": "def"}, {"fullname": "sims.panda_cable_weaving.MjSim.angle_to_next_alignment", "modulename": "sims.panda_cable_weaving", "qualname": "MjSim.angle_to_next_alignment", "kind": "function", "doc": "<p>Compute the angle to align the TCP with a tangent direction between two geometries.</p>\n\n<p>Parameters:</p>\n\n<ul>\n<li>geom_indx (int): Index of the geometry in the specification.</li>\n<li>current_geom_name (str): Name of the current geometry.</li>\n<li>next_geom_name (str): Name of the next geometry to align with.</li>\n<li>T_init (sm.SE3, optional): Initial pose of the TCP. If None, fetches the current TCP pose.</li>\n</ul>\n\n<p>Returns:</p>\n\n<ul>\n<li>float: The angle in radians for the alignment.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">geom_indx</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">current_geom_name</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">next_geom_name</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">T_init</span><span class=\"p\">:</span> <span class=\"n\">spatialmath</span><span class=\"o\">.</span><span class=\"n\">pose3d</span><span class=\"o\">.</span><span class=\"n\">SE3</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "sims.panda_cable_weaving.MjSim.rotate_about", "modulename": "sims.panda_cable_weaving", "qualname": "MjSim.rotate_about", "kind": "function", "doc": "<p>Generate a pose rotating the TCP relative to a specified geometry.</p>\n\n<p>Parameters:</p>\n\n<ul>\n<li>geom_name (str): Name of the geometry to rotate around.</li>\n<li>dir (str): Direction of rotation, \"ccw\" for counterclockwise or \"cw\" for clockwise.</li>\n<li>phi (float): Angle of rotation in radians.</li>\n<li>n_steps (int): Number of steps in the trajectory.</li>\n<li>T_init (sm.SE3, optional): Initial pose of the TCP. If None, fetches the current TCP pose.</li>\n</ul>\n\n<p>Returns:</p>\n\n<ul>\n<li>sm.SE3: Rotated pose.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">geom_name</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"nb\">dir</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">phi</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">n_steps</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">20</span>,</span><span class=\"param\">\t<span class=\"n\">T_init</span><span class=\"p\">:</span> <span class=\"n\">spatialmath</span><span class=\"o\">.</span><span class=\"n\">pose3d</span><span class=\"o\">.</span><span class=\"n\">SE3</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">spatialmath</span><span class=\"o\">.</span><span class=\"n\">pose3d</span><span class=\"o\">.</span><span class=\"n\">SE3</span>:</span></span>", "funcdef": "def"}, {"fullname": "sims.panda_cable_weaving.MjSim.opp1", "modulename": "sims.panda_cable_weaving", "qualname": "MjSim.opp1", "kind": "function", "doc": "<p>Generate a Cartesian pose from the end effector pose to a new pose above an obstacle.</p>\n\n<p>Parameters:</p>\n\n<ul>\n<li>h (float): Height offset above the obstacle.</li>\n<li>geom_name (str): Name of the obstacle geometry.</li>\n<li>T_init (sm.SE3, optional): Initial pose of the TCP. If None, fetches the current TCP pose.</li>\n</ul>\n\n<p>Returns:</p>\n\n<ul>\n<li>sm.SE3: Target pose above the obstacle.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">h</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">geom_name</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">T_init</span><span class=\"p\">:</span> <span class=\"n\">spatialmath</span><span class=\"o\">.</span><span class=\"n\">pose3d</span><span class=\"o\">.</span><span class=\"n\">SE3</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">spatialmath</span><span class=\"o\">.</span><span class=\"n\">pose3d</span><span class=\"o\">.</span><span class=\"n\">SE3</span>:</span></span>", "funcdef": "def"}, {"fullname": "sims.panda_cable_weaving.MjSim.opp2", "modulename": "sims.panda_cable_weaving", "qualname": "MjSim.opp2", "kind": "function", "doc": "<p>Generate a Cartesian pose rotated theta raltive to some obstacle.</p>\n\n<p>Parameters:</p>\n\n<ul>\n<li>theta (float): Angle of rotation in radians.</li>\n<li>dir (str): Direction of rotation, \"ccw\" or \"cw\".</li>\n<li>geom_name (str): Name of the obstacle geometry.</li>\n<li>T_init (sm.SE3, optional): Initial pose of the TCP. If None, fetches the current TCP pose.</li>\n</ul>\n\n<p>Returns:</p>\n\n<ul>\n<li>sm.SE3: Target pose after the rotation.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">theta</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"nb\">dir</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">geom_name</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">T_init</span><span class=\"p\">:</span> <span class=\"n\">spatialmath</span><span class=\"o\">.</span><span class=\"n\">pose3d</span><span class=\"o\">.</span><span class=\"n\">SE3</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">spatialmath</span><span class=\"o\">.</span><span class=\"n\">pose3d</span><span class=\"o\">.</span><span class=\"n\">SE3</span>:</span></span>", "funcdef": "def"}, {"fullname": "sims.panda_cable_weaving.MjSim.opp3", "modulename": "sims.panda_cable_weaving", "qualname": "MjSim.opp3", "kind": "function", "doc": "<p>Compute a target pose for the robot's end-effector based on positional and rotational offsets.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>delta : float\n    Distance offset from the current end-effector position towards the target geometry in the xy-plane.\ntheta : float\n    Angle of rotation around the z-axis (in radians).\ndir : str\n    Direction of rotation (\"ccw\" for counterclockwise, any other value for clockwise).\ngeom_name : str\n    Name of the target geometry to compute the offset and rotation with respect to.\nT_init : sm.SE3, optional\n    Initial pose of the end-effector. If None, the current pose is fetched from the robot, by default None.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>sm.SE3\n    The computed target pose in the world frame.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">delta</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">theta</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"nb\">dir</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">geom_name</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">T_init</span><span class=\"p\">:</span> <span class=\"n\">spatialmath</span><span class=\"o\">.</span><span class=\"n\">pose3d</span><span class=\"o\">.</span><span class=\"n\">SE3</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">spatialmath</span><span class=\"o\">.</span><span class=\"n\">pose3d</span><span class=\"o\">.</span><span class=\"n\">SE3</span>:</span></span>", "funcdef": "def"}, {"fullname": "sims.panda_cable_weaving.MjSim.opp4", "modulename": "sims.panda_cable_weaving", "qualname": "MjSim.opp4", "kind": "function", "doc": "<p>Compute a target pose for the robot's end-effector with a specified z-height.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>z_height : float\n    Desired height (z-coordinate) for the end-effector in the world frame.\nT_init : sm.SE3, optional\n    Initial pose of the end-effector. If None, the current pose is fetched from the robot, by default None.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>sm.SE3\n    The computed target pose with the specified z-height.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">z_height</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">T_init</span><span class=\"p\">:</span> <span class=\"n\">spatialmath</span><span class=\"o\">.</span><span class=\"n\">pose3d</span><span class=\"o\">.</span><span class=\"n\">SE3</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">spatialmath</span><span class=\"o\">.</span><span class=\"n\">pose3d</span><span class=\"o\">.</span><span class=\"n\">SE3</span>:</span></span>", "funcdef": "def"}, {"fullname": "sims.pick_and_place_ur5e", "modulename": "sims.pick_and_place_ur5e", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "sims.pick_and_place_ur5e.MjSim", "modulename": "sims.pick_and_place_ur5e", "qualname": "MjSim", "kind": "class", "doc": "<p>Abstract base class for MuJoCo robot simulations.</p>\n\n<p>This class serves as the foundational framework for simulating robots in MuJoCo. It defines\nkey properties and methods that must be implemented in subclasses, including access to\nthe simulation's dynamic data (<code>MjData</code>), the static model (<code>MjModel</code>), and control mechanisms.</p>\n\n<p>Child classes are responsible for implementing the control logic (<code>control_loop</code>) and handling\nuser inputs via the keyboard (<code>keyboard_callback</code>). The <code>run</code> method provides a basic structure\nfor running the main simulation loop, handling viewer synchronization, and processing user inputs\nin real-time.</p>\n\n<p>This base class includes functionality to issue warnings if important methods, such as the control\nloop or keyboard callback, are not implemented in a subclass.</p>\n", "bases": "sims.base_sim.BaseSim"}, {"fullname": "sims.shadow_hand_cable_following", "modulename": "sims.shadow_hand_cable_following", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "sims.shadow_hand_cable_following.MjSim", "modulename": "sims.shadow_hand_cable_following", "qualname": "MjSim", "kind": "class", "doc": "<p>Abstract base class for MuJoCo robot simulations.</p>\n\n<p>This class serves as the foundational framework for simulating robots in MuJoCo. It defines\nkey properties and methods that must be implemented in subclasses, including access to\nthe simulation's dynamic data (<code>MjData</code>), the static model (<code>MjModel</code>), and control mechanisms.</p>\n\n<p>Child classes are responsible for implementing the control logic (<code>control_loop</code>) and handling\nuser inputs via the keyboard (<code>keyboard_callback</code>). The <code>run</code> method provides a basic structure\nfor running the main simulation loop, handling viewer synchronization, and processing user inputs\nin real-time.</p>\n\n<p>This base class includes functionality to issue warnings if important methods, such as the control\nloop or keyboard callback, are not implemented in a subclass.</p>\n", "bases": "sims.base_sim.BaseSim"}, {"fullname": "sims.shadow_hand_cable_following.MjSim.sh", "modulename": "sims.shadow_hand_cable_following", "qualname": "MjSim.sh", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sims.shadow_hand_cable_following.MjSim.mocap", "modulename": "sims.shadow_hand_cable_following", "qualname": "MjSim.mocap", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sims.shadow_hand_cable_following.MjSim.tasks", "modulename": "sims.shadow_hand_cable_following", "qualname": "MjSim.tasks", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sims.shadow_hand_cable_following.MjSim.begin", "modulename": "sims.shadow_hand_cable_following", "qualname": "MjSim.begin", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sims.shadow_hand_cable_following.MjSim.init", "modulename": "sims.shadow_hand_cable_following", "qualname": "MjSim.init", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sims.shadow_hand_cable_following.MjSim.script", "modulename": "sims.shadow_hand_cable_following", "qualname": "MjSim.script", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">ss</span><span class=\"p\">:</span> <span class=\"n\">sims</span><span class=\"o\">.</span><span class=\"n\">base_sim</span><span class=\"o\">.</span><span class=\"n\">SimSync</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sims.shadow_hand_cable_following.MjSim.log", "modulename": "sims.shadow_hand_cable_following", "qualname": "MjSim.log", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">ss</span><span class=\"p\">:</span> <span class=\"n\">sims</span><span class=\"o\">.</span><span class=\"n\">base_sim</span><span class=\"o\">.</span><span class=\"n\">SimSync</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sims.shadow_hand_cable_following.MjSim.spin", "modulename": "sims.shadow_hand_cable_following", "qualname": "MjSim.spin", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">ss</span><span class=\"p\">:</span> <span class=\"n\">sims</span><span class=\"o\">.</span><span class=\"n\">base_sim</span><span class=\"o\">.</span><span class=\"n\">SimSync</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sims.shadow_hand_cable_following.MjSim.data", "modulename": "sims.shadow_hand_cable_following", "qualname": "MjSim.data", "kind": "variable", "doc": "<p>Access the current simulation data.</p>\n\n<p>This property provides access to an instance of the <code>MjData</code> class, which contains the dynamic\nsimulation state. This includes quantities such as joint positions, velocities,\nactuator forces, and sensory information. The <code>MjData</code> object is updated at each simulation step\nand can be used to inspect the real-time state of said simulation.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>mj.MjData\n    An object representing the current dynamic state of the simulation.</p>\n", "annotation": ": mujoco._structs.MjData"}, {"fullname": "sims.shadow_hand_cable_following.MjSim.model", "modulename": "sims.shadow_hand_cable_following", "qualname": "MjSim.model", "kind": "variable", "doc": "<p>Access the model of the MuJoCo simulation.</p>\n\n<p>This property returns an instance of the <code>MjModel</code> class, which describes the physical and\nmechanical properties of the simulation. The <code>MjModel</code> object contains static information about the\nsimulation such as its kinematic trees, inertial properties, joint and actuator definitions, and geometry\nconfigurations. It is used to define the system's structure and behavior within the simulation.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>mj.MjModel\n    An object representing the static model of the system and overall MuJoCo simulation.</p>\n", "annotation": ": mujoco._structs.MjModel"}, {"fullname": "sims.shadow_hand_cable_following.MjSim.keyboard_callback", "modulename": "sims.shadow_hand_cable_following", "qualname": "MjSim.keyboard_callback", "kind": "function", "doc": "<p>Handle keyboard inputs during the simulation.</p>\n\n<p>This method is intended to be overridden in the child class to define how the simulation responds\nto specific keyboard inputs. The <code>key</code> parameter corresponds to the key pressed by the user,\nallowing for custom behavior (e.g., sending trajectories to robots' task queues, logging data\nor start/stopping processes).</p>\n\n<p>If this method is not implemented in the child class, a warning will be issued.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>key : int\n    The key pressed by the user represented by a key code.</p>\n\n<h2 id=\"raises\">Raises</h2>\n\n<p>UserWarning\n    If the method is not implemented in the child class.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">key</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sims.shadow_hand_cable_following.MjSim.control_loop", "modulename": "sims.shadow_hand_cable_following", "qualname": "MjSim.control_loop", "kind": "function", "doc": "<p>Main control loop for the robot simulation.</p>\n\n<p>This method is intended to be overridden in the child class to implement the robot's control\nlogic. The control loop is typically responsible for computing control signals based on the\ncurrent state of the simulation (e.g., sensor data) and applying these signals to the robot's\nactuators. The frequency of the control loop matches the simulation step rate.</p>\n\n<p>If this method is not implemented in the child class, a warning will be issued.</p>\n\n<h2 id=\"raises\">Raises</h2>\n\n<p>UserWarning\n    If the method is not implemented in the child class.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sims.shadow_hand_ik", "modulename": "sims.shadow_hand_ik", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "sims.shadow_hand_ik.ShadowFinger", "modulename": "sims.shadow_hand_ik", "qualname": "ShadowFinger", "kind": "class", "doc": "<p>Base class for robot simulation in MuJoCo.</p>\n\n<p>This class provides a framework for simulating robots in MuJoCo environments. It defines\nkey properties and methods that should be implemented in child classes, including access\nto the robot's model, data, and control mechanisms.</p>\n", "bases": "robots.base_robot.BaseRobot"}, {"fullname": "sims.shadow_hand_ik.ShadowFinger.__init__", "modulename": "sims.shadow_hand_ik", "qualname": "ShadowFinger.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">sh</span><span class=\"p\">:</span> <span class=\"n\">robots</span><span class=\"o\">.</span><span class=\"n\">shadow_hand</span><span class=\"o\">.</span><span class=\"n\">ShadowHand</span>,</span><span class=\"param\">\t<span class=\"nb\">type</span><span class=\"p\">:</span> <span class=\"n\">sims</span><span class=\"o\">.</span><span class=\"n\">shadow_hand_ik</span><span class=\"o\">.</span><span class=\"n\">ShadowFinger</span><span class=\"o\">.</span><span class=\"n\">FingerType</span></span>)</span>"}, {"fullname": "sims.shadow_hand_ik.ShadowFinger.FingerType", "modulename": "sims.shadow_hand_ik", "qualname": "ShadowFinger.FingerType", "kind": "class", "doc": "<p></p>\n", "bases": "enum.Enum"}, {"fullname": "sims.shadow_hand_ik.ShadowFinger.FingerType.FF", "modulename": "sims.shadow_hand_ik", "qualname": "ShadowFinger.FingerType.FF", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;FingerType.FF: &#x27;FF&#x27;&gt;"}, {"fullname": "sims.shadow_hand_ik.ShadowFinger.FingerType.MF", "modulename": "sims.shadow_hand_ik", "qualname": "ShadowFinger.FingerType.MF", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;FingerType.MF: &#x27;MF&#x27;&gt;"}, {"fullname": "sims.shadow_hand_ik.ShadowFinger.FingerType.RF", "modulename": "sims.shadow_hand_ik", "qualname": "ShadowFinger.FingerType.RF", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;FingerType.RF: &#x27;RF&#x27;&gt;"}, {"fullname": "sims.shadow_hand_ik.ShadowFinger.FingerType.LF", "modulename": "sims.shadow_hand_ik", "qualname": "ShadowFinger.FingerType.LF", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;FingerType.LF: &#x27;LF&#x27;&gt;"}, {"fullname": "sims.shadow_hand_ik.ShadowFinger.FingerType.TH", "modulename": "sims.shadow_hand_ik", "qualname": "ShadowFinger.FingerType.TH", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;FingerType.TH: &#x27;TH&#x27;&gt;"}, {"fullname": "sims.shadow_hand_ik.ShadowFinger.sh", "modulename": "sims.shadow_hand_ik", "qualname": "ShadowFinger.sh", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sims.shadow_hand_ik.ShadowFinger.J", "modulename": "sims.shadow_hand_ik", "qualname": "ShadowFinger.J", "kind": "variable", "doc": "<p>Get the full Jacobian in base frame.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<pre><code>    Full Jacobian as a numpy array.\n</code></pre>\n", "annotation": ": numpy.ndarray"}, {"fullname": "sims.shadow_hand_ik.ShadowFinger.data", "modulename": "sims.shadow_hand_ik", "qualname": "ShadowFinger.data", "kind": "variable", "doc": "<p>Access the current simulation data.</p>\n\n<p>This property provides access to an instance of the <code>MjData</code> class, which contains the dynamic\nsimulation state. This includes quantities such as joint positions, velocities,\nactuator forces, and sensory information. The <code>MjData</code> object is updated at each simulation step\nand can be used to inspect the real-time state of the robot during the simulation.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>mj.MjData\n    An object representing the current dynamic state of the simulation.</p>\n", "annotation": ": mujoco._structs.MjData"}, {"fullname": "sims.shadow_hand_ik.ShadowFinger.model", "modulename": "sims.shadow_hand_ik", "qualname": "ShadowFinger.model", "kind": "variable", "doc": "<p>Access the model of the MuJoCo simulation.</p>\n\n<p>This property returns an instance of the <code>MjModel</code> class, which describes the physical and\nmechanical properties of the simulation. The <code>MjModel</code> object contains static information about the\nrobot such as its kinematic tree, inertial properties, joint and actuator definitions, and geometry\nconfigurations. It is used to define the robot's structure and behavior within the simulation.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>mj.MjModel\n    An object representing the static model of the robot and overall MuJoCo simulation.</p>\n", "annotation": ": mujoco._structs.MjModel"}, {"fullname": "sims.shadow_hand_ik.ShadowFinger.info", "modulename": "sims.shadow_hand_ik", "qualname": "ShadowFinger.info", "kind": "variable", "doc": "<p>Get detailed information about the robot.</p>\n\n<p>This property returns an instance of the <code>RobotInfo</code> class, which provides comprehensive\ndetails about the robot's structure and components. This includes information on the robot's\nbodies, joints, actuators, and geometries, among other attributes. The <code>RobotInfo</code> instance\ncan be used to access various properties such as the number of joints, actuator limits, joint\nlimits, and more.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>RobotInfo\n    An object containing detailed information about the robot's configuration and components.</p>\n", "annotation": ": utils.mj.RobotInfo"}, {"fullname": "sims.shadow_hand_ik.ShadowFinger.name", "modulename": "sims.shadow_hand_ik", "qualname": "ShadowFinger.name", "kind": "variable", "doc": "<p>Get the name of the robot.</p>\n\n<p>This property returns the name of the robot as a string. The name is typically a unique identifier\nused to distinguish between different robots in the simulation environment.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>str\n    The name of the robot as a string.</p>\n", "annotation": ": str"}, {"fullname": "sims.shadow_hand_ik.ShadowFinger.step", "modulename": "sims.shadow_hand_ik", "qualname": "ShadowFinger.step", "kind": "variable", "doc": "<p>Perform a step in the controller.</p>\n\n<p>This method calls the <code>step()</code> method of the controller object and\nbefore doing so it checks if there are any tasks to be performed in\nthe robot task queue</p>\n", "annotation": ": None"}, {"fullname": "sims.shadow_hand_ik.MjSim", "modulename": "sims.shadow_hand_ik", "qualname": "MjSim", "kind": "class", "doc": "<p>Abstract base class for MuJoCo robot simulations.</p>\n\n<p>This class serves as the foundational framework for simulating robots in MuJoCo. It defines\nkey properties and methods that must be implemented in subclasses, including access to\nthe simulation's dynamic data (<code>MjData</code>), the static model (<code>MjModel</code>), and control mechanisms.</p>\n\n<p>Child classes are responsible for implementing the control logic (<code>control_loop</code>) and handling\nuser inputs via the keyboard (<code>keyboard_callback</code>). The <code>run</code> method provides a basic structure\nfor running the main simulation loop, handling viewer synchronization, and processing user inputs\nin real-time.</p>\n\n<p>This base class includes functionality to issue warnings if important methods, such as the control\nloop or keyboard callback, are not implemented in a subclass.</p>\n", "bases": "sims.base_sim.BaseSim"}, {"fullname": "sims.shadow_hand_ik.MjSim.sh", "modulename": "sims.shadow_hand_ik", "qualname": "MjSim.sh", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sims.shadow_hand_ik.MjSim.mocap", "modulename": "sims.shadow_hand_ik", "qualname": "MjSim.mocap", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sims.shadow_hand_ik.MjSim.tasks", "modulename": "sims.shadow_hand_ik", "qualname": "MjSim.tasks", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sims.shadow_hand_ik.MjSim.init", "modulename": "sims.shadow_hand_ik", "qualname": "MjSim.init", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sims.shadow_hand_ik.MjSim.script", "modulename": "sims.shadow_hand_ik", "qualname": "MjSim.script", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">ss</span><span class=\"p\">:</span> <span class=\"n\">sims</span><span class=\"o\">.</span><span class=\"n\">base_sim</span><span class=\"o\">.</span><span class=\"n\">SimSync</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sims.shadow_hand_ik.MjSim.log", "modulename": "sims.shadow_hand_ik", "qualname": "MjSim.log", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">ss</span><span class=\"p\">:</span> <span class=\"n\">sims</span><span class=\"o\">.</span><span class=\"n\">base_sim</span><span class=\"o\">.</span><span class=\"n\">SimSync</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sims.shadow_hand_ik.MjSim.data", "modulename": "sims.shadow_hand_ik", "qualname": "MjSim.data", "kind": "variable", "doc": "<p>Access the current simulation data.</p>\n\n<p>This property provides access to an instance of the <code>MjData</code> class, which contains the dynamic\nsimulation state. This includes quantities such as joint positions, velocities,\nactuator forces, and sensory information. The <code>MjData</code> object is updated at each simulation step\nand can be used to inspect the real-time state of said simulation.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>mj.MjData\n    An object representing the current dynamic state of the simulation.</p>\n", "annotation": ": mujoco._structs.MjData"}, {"fullname": "sims.shadow_hand_ik.MjSim.model", "modulename": "sims.shadow_hand_ik", "qualname": "MjSim.model", "kind": "variable", "doc": "<p>Access the model of the MuJoCo simulation.</p>\n\n<p>This property returns an instance of the <code>MjModel</code> class, which describes the physical and\nmechanical properties of the simulation. The <code>MjModel</code> object contains static information about the\nsimulation such as its kinematic trees, inertial properties, joint and actuator definitions, and geometry\nconfigurations. It is used to define the system's structure and behavior within the simulation.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>mj.MjModel\n    An object representing the static model of the system and overall MuJoCo simulation.</p>\n", "annotation": ": mujoco._structs.MjModel"}, {"fullname": "sims.shadow_hand_ik.MjSim.keyboard_callback", "modulename": "sims.shadow_hand_ik", "qualname": "MjSim.keyboard_callback", "kind": "function", "doc": "<p>Handle keyboard inputs during the simulation.</p>\n\n<p>This method is intended to be overridden in the child class to define how the simulation responds\nto specific keyboard inputs. The <code>key</code> parameter corresponds to the key pressed by the user,\nallowing for custom behavior (e.g., sending trajectories to robots' task queues, logging data\nor start/stopping processes).</p>\n\n<p>If this method is not implemented in the child class, a warning will be issued.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>key : int\n    The key pressed by the user represented by a key code.</p>\n\n<h2 id=\"raises\">Raises</h2>\n\n<p>UserWarning\n    If the method is not implemented in the child class.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">key</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sims.shadow_hand_ik.MjSim.control_loop", "modulename": "sims.shadow_hand_ik", "qualname": "MjSim.control_loop", "kind": "function", "doc": "<p>Main control loop for the robot simulation.</p>\n\n<p>This method is intended to be overridden in the child class to implement the robot's control\nlogic. The control loop is typically responsible for computing control signals based on the\ncurrent state of the simulation (e.g., sensor data) and applying these signals to the robot's\nactuators. The frequency of the control loop matches the simulation step rate.</p>\n\n<p>If this method is not implemented in the child class, a warning will be issued.</p>\n\n<h2 id=\"raises\">Raises</h2>\n\n<p>UserWarning\n    If the method is not implemented in the child class.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sims.shadow_hand_pick_and_place", "modulename": "sims.shadow_hand_pick_and_place", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "sims.shadow_hand_pick_and_place.MjSim", "modulename": "sims.shadow_hand_pick_and_place", "qualname": "MjSim", "kind": "class", "doc": "<p>Abstract base class for MuJoCo robot simulations.</p>\n\n<p>This class serves as the foundational framework for simulating robots in MuJoCo. It defines\nkey properties and methods that must be implemented in subclasses, including access to\nthe simulation's dynamic data (<code>MjData</code>), the static model (<code>MjModel</code>), and control mechanisms.</p>\n\n<p>Child classes are responsible for implementing the control logic (<code>control_loop</code>) and handling\nuser inputs via the keyboard (<code>keyboard_callback</code>). The <code>run</code> method provides a basic structure\nfor running the main simulation loop, handling viewer synchronization, and processing user inputs\nin real-time.</p>\n\n<p>This base class includes functionality to issue warnings if important methods, such as the control\nloop or keyboard callback, are not implemented in a subclass.</p>\n", "bases": "sims.base_sim.BaseSim"}, {"fullname": "sims.shadow_hand_pick_and_place.MjSim.sh", "modulename": "sims.shadow_hand_pick_and_place", "qualname": "MjSim.sh", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sims.shadow_hand_pick_and_place.MjSim.mocap", "modulename": "sims.shadow_hand_pick_and_place", "qualname": "MjSim.mocap", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sims.shadow_hand_pick_and_place.MjSim.tasks", "modulename": "sims.shadow_hand_pick_and_place", "qualname": "MjSim.tasks", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sims.shadow_hand_pick_and_place.MjSim.init", "modulename": "sims.shadow_hand_pick_and_place", "qualname": "MjSim.init", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sims.shadow_hand_pick_and_place.MjSim.spin", "modulename": "sims.shadow_hand_pick_and_place", "qualname": "MjSim.spin", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">ss</span><span class=\"p\">:</span> <span class=\"n\">sims</span><span class=\"o\">.</span><span class=\"n\">base_sim</span><span class=\"o\">.</span><span class=\"n\">SimSync</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sims.shadow_hand_pick_and_place.MjSim.script", "modulename": "sims.shadow_hand_pick_and_place", "qualname": "MjSim.script", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">ss</span><span class=\"p\">:</span> <span class=\"n\">sims</span><span class=\"o\">.</span><span class=\"n\">base_sim</span><span class=\"o\">.</span><span class=\"n\">SimSync</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sims.shadow_hand_pick_and_place.MjSim.log", "modulename": "sims.shadow_hand_pick_and_place", "qualname": "MjSim.log", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">ss</span><span class=\"p\">:</span> <span class=\"n\">sims</span><span class=\"o\">.</span><span class=\"n\">base_sim</span><span class=\"o\">.</span><span class=\"n\">SimSync</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sims.shadow_hand_pick_and_place.MjSim.data", "modulename": "sims.shadow_hand_pick_and_place", "qualname": "MjSim.data", "kind": "variable", "doc": "<p>Access the current simulation data.</p>\n\n<p>This property provides access to an instance of the <code>MjData</code> class, which contains the dynamic\nsimulation state. This includes quantities such as joint positions, velocities,\nactuator forces, and sensory information. The <code>MjData</code> object is updated at each simulation step\nand can be used to inspect the real-time state of said simulation.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>mj.MjData\n    An object representing the current dynamic state of the simulation.</p>\n", "annotation": ": mujoco._structs.MjData"}, {"fullname": "sims.shadow_hand_pick_and_place.MjSim.model", "modulename": "sims.shadow_hand_pick_and_place", "qualname": "MjSim.model", "kind": "variable", "doc": "<p>Access the model of the MuJoCo simulation.</p>\n\n<p>This property returns an instance of the <code>MjModel</code> class, which describes the physical and\nmechanical properties of the simulation. The <code>MjModel</code> object contains static information about the\nsimulation such as its kinematic trees, inertial properties, joint and actuator definitions, and geometry\nconfigurations. It is used to define the system's structure and behavior within the simulation.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>mj.MjModel\n    An object representing the static model of the system and overall MuJoCo simulation.</p>\n", "annotation": ": mujoco._structs.MjModel"}, {"fullname": "sims.shadow_hand_pick_and_place.MjSim.keyboard_callback", "modulename": "sims.shadow_hand_pick_and_place", "qualname": "MjSim.keyboard_callback", "kind": "function", "doc": "<p>Handle keyboard inputs during the simulation.</p>\n\n<p>This method is intended to be overridden in the child class to define how the simulation responds\nto specific keyboard inputs. The <code>key</code> parameter corresponds to the key pressed by the user,\nallowing for custom behavior (e.g., sending trajectories to robots' task queues, logging data\nor start/stopping processes).</p>\n\n<p>If this method is not implemented in the child class, a warning will be issued.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>key : int\n    The key pressed by the user represented by a key code.</p>\n\n<h2 id=\"raises\">Raises</h2>\n\n<p>UserWarning\n    If the method is not implemented in the child class.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">key</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ctrl", "modulename": "ctrl", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "ctrl.base_ctrl", "modulename": "ctrl.base_ctrl", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "ctrl.base_ctrl.BaseController", "modulename": "ctrl.base_ctrl", "qualname": "BaseController", "kind": "class", "doc": "<p></p>\n"}, {"fullname": "ctrl.base_ctrl.BaseController.step", "modulename": "ctrl.base_ctrl", "qualname": "BaseController.step", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "ctrl.dmp_cartesian", "modulename": "ctrl.dmp_cartesian", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "ctrl.dmp_cartesian.canonical_system", "modulename": "ctrl.dmp_cartesian.canonical_system", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "ctrl.dmp_cartesian.canonical_system.CanonicalSystem", "modulename": "ctrl.dmp_cartesian.canonical_system", "qualname": "CanonicalSystem", "kind": "class", "doc": "<p></p>\n"}, {"fullname": "ctrl.dmp_cartesian.canonical_system.CanonicalSystem.__init__", "modulename": "ctrl.dmp_cartesian.canonical_system", "qualname": "CanonicalSystem.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">alpha</span><span class=\"p\">:</span> <span class=\"nb\">float</span></span>)</span>"}, {"fullname": "ctrl.dmp_cartesian.canonical_system.CanonicalSystem.alpha", "modulename": "ctrl.dmp_cartesian.canonical_system", "qualname": "CanonicalSystem.alpha", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "ctrl.dmp_cartesian.canonical_system.CanonicalSystem.step_vectorized", "modulename": "ctrl.dmp_cartesian.canonical_system", "qualname": "CanonicalSystem.step_vectorized", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "ctrl.dmp_cartesian.canonical_system.CanonicalSystem.x", "modulename": "ctrl.dmp_cartesian.canonical_system", "qualname": "CanonicalSystem.x", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "ctrl.dmp_cartesian.canonical_system.CanonicalSystem.step", "modulename": "ctrl.dmp_cartesian.canonical_system", "qualname": "CanonicalSystem.step", "kind": "function", "doc": "<p>Solve the canonical system at next time step t+dt.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>dt : float\n    Time step.\ntau : float\n    Temporal scaling factor.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">dt</span><span class=\"p\">:</span> <span class=\"nb\">float</span>, </span><span class=\"param\"><span class=\"n\">tau</span><span class=\"p\">:</span> <span class=\"nb\">float</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ctrl.dmp_cartesian.canonical_system.CanonicalSystem.rollout", "modulename": "ctrl.dmp_cartesian.canonical_system", "qualname": "CanonicalSystem.rollout", "kind": "function", "doc": "<p>Solve the canonical system.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>t : array_like\n    Time points for which to evaluate the integral.\ntau : array_like\n    Temporal scaling factor (scalar constant or same length as t).</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">t</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">]</span>, </span><span class=\"param\"><span class=\"n\">tau</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">]]</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ctrl.dmp_cartesian.canonical_system.CanonicalSystem.reset", "modulename": "ctrl.dmp_cartesian.canonical_system", "qualname": "CanonicalSystem.reset", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ctrl.dmp_cartesian.dmp_cartesian", "modulename": "ctrl.dmp_cartesian.dmp_cartesian", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "ctrl.dmp_cartesian.dmp_cartesian.DMPCartesian", "modulename": "ctrl.dmp_cartesian.dmp_cartesian", "qualname": "DMPCartesian", "kind": "class", "doc": "<p></p>\n"}, {"fullname": "ctrl.dmp_cartesian.dmp_cartesian.DMPCartesian.__init__", "modulename": "ctrl.dmp_cartesian.dmp_cartesian", "qualname": "DMPCartesian.__init__", "kind": "function", "doc": "<p>Initialize the DMPCartesian object.</p>\n\n<p>Parameters:\nn_bfs (int): Number of basis functions.\nalpha (float): Alpha parameter for DMP.\nbeta (Optional[float]): Beta parameter for DMP. Defaults to alpha / 4 if not provided.\ncs_alpha (Optional[float]): Alpha parameter for the canonical system.\ncs (Optional[CanonicalSystem]): Custom canonical system.\nroto_dilatation (bool): Flag for roto-dilatation.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">n_bfs</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">100</span>,</span><span class=\"param\">\t<span class=\"n\">alpha</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mi\">100</span>,</span><span class=\"param\">\t<span class=\"n\">beta</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">cs_alpha</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mf\">9.210340371976182</span>,</span><span class=\"param\">\t<span class=\"n\">cs</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">ctrl</span><span class=\"o\">.</span><span class=\"n\">dmp_cartesian</span><span class=\"o\">.</span><span class=\"n\">canonical_system</span><span class=\"o\">.</span><span class=\"n\">CanonicalSystem</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">roto_dilatation</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span>)</span>"}, {"fullname": "ctrl.dmp_cartesian.dmp_cartesian.DMPCartesian.n_bfs", "modulename": "ctrl.dmp_cartesian.dmp_cartesian", "qualname": "DMPCartesian.n_bfs", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "ctrl.dmp_cartesian.dmp_cartesian.DMPCartesian.cs", "modulename": "ctrl.dmp_cartesian.dmp_cartesian", "qualname": "DMPCartesian.cs", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "ctrl.dmp_cartesian.dmp_cartesian.DMPCartesian.position_dmp", "modulename": "ctrl.dmp_cartesian.dmp_cartesian", "qualname": "DMPCartesian.position_dmp", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "ctrl.dmp_cartesian.dmp_cartesian.DMPCartesian.quaternion_dmp", "modulename": "ctrl.dmp_cartesian.dmp_cartesian", "qualname": "DMPCartesian.quaternion_dmp", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "ctrl.dmp_cartesian.dmp_cartesian.DMPCartesian.dt", "modulename": "ctrl.dmp_cartesian.dmp_cartesian", "qualname": "DMPCartesian.dt", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "ctrl.dmp_cartesian.dmp_cartesian.DMPCartesian.tau", "modulename": "ctrl.dmp_cartesian.dmp_cartesian", "qualname": "DMPCartesian.tau", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "ctrl.dmp_cartesian.dmp_cartesian.DMPCartesian.ts", "modulename": "ctrl.dmp_cartesian.dmp_cartesian", "qualname": "DMPCartesian.ts", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "ctrl.dmp_cartesian.dmp_cartesian.DMPCartesian.trained", "modulename": "ctrl.dmp_cartesian.dmp_cartesian", "qualname": "DMPCartesian.trained", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "ctrl.dmp_cartesian.dmp_cartesian.DMPCartesian.step", "modulename": "ctrl.dmp_cartesian.dmp_cartesian", "qualname": "DMPCartesian.step", "kind": "function", "doc": "<p>Perform a single DMP step.</p>\n\n<p>Parameters:</p>\n\n<ul>\n<li>x (float): Phase variable.</li>\n<li>dt (float): Time step.</li>\n<li>tau (float): Temporal scaling factor.</li>\n<li>force_disturbance (np.ndarray): External force disturbance.</li>\n<li>torque_disturbance (np.ndarray): External torque disturbance.</li>\n</ul>\n\n<p>Returns:\nTuple[np.ndarray, np.ndarray, np.ndarray, np.quaternion, np.ndarray, np.ndarray]:\n    Position, velocity, and acceleration of position DMP.\n    Orientation, angular velocity, and angular acceleration of quaternion DMP.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">x</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">dt</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">tau</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">force_disturbance</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span> <span class=\"o\">=</span> <span class=\"n\">array</span><span class=\"p\">([</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">])</span>,</span><span class=\"param\">\t<span class=\"n\">torque_disturbance</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span> <span class=\"o\">=</span> <span class=\"n\">array</span><span class=\"p\">([</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">])</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"n\">quaternion</span><span class=\"o\">.</span><span class=\"n\">quaternion</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "ctrl.dmp_cartesian.dmp_cartesian.DMPCartesian.rollout", "modulename": "ctrl.dmp_cartesian.dmp_cartesian", "qualname": "DMPCartesian.rollout", "kind": "function", "doc": "<p>Perform a DMP rollout over time.</p>\n\n<p>Parameters:</p>\n\n<ul>\n<li>ts (np.ndarray): Time steps.</li>\n<li>tau (float): Temporal scaling factor.</li>\n</ul>\n\n<p>Returns:\nTuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray, np.ndarray, np.ndarray]:\n    Position, velocity, and acceleration of position DMP.\n    Orientation, angular velocity, and angular acceleration of quaternion DMP.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">ts</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">tau</span><span class=\"p\">:</span> <span class=\"nb\">float</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "ctrl.dmp_cartesian.dmp_cartesian.DMPCartesian.reset", "modulename": "ctrl.dmp_cartesian.dmp_cartesian", "qualname": "DMPCartesian.reset", "kind": "function", "doc": "<p>Reset the DMP to its initial state.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "ctrl.dmp_cartesian.dmp_cartesian.DMPCartesian.train", "modulename": "ctrl.dmp_cartesian.dmp_cartesian", "qualname": "DMPCartesian.train", "kind": "function", "doc": "<p>Train the DMP with given positions and quaternions.</p>\n\n<p>Parameters:</p>\n\n<ul>\n<li>positions (np.ndarray): Training positions.</li>\n<li>quaternions (np.ndarray): Training orientations as quaternions.</li>\n<li>ts (np.ndarray): Time steps.</li>\n<li>tau (float): Temporal scaling factor.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">positions</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">quaternions</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">ts</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">tau</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">T</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">spatialmath</span><span class=\"o\">.</span><span class=\"n\">pose3d</span><span class=\"o\">.</span><span class=\"n\">SE3</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "ctrl.dmp_cartesian.dmp_cartesian.DMPCartesian.load", "modulename": "ctrl.dmp_cartesian.dmp_cartesian", "qualname": "DMPCartesian.load", "kind": "function", "doc": "<p>Load and train the DMP with a trajectory.</p>\n\n<p>Parameters:</p>\n\n<ul>\n<li>Traj (sm.SE3): Trajectory as an SE3 object.</li>\n<li>dt (float): Time step size.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">Traj</span><span class=\"p\">:</span> <span class=\"n\">spatialmath</span><span class=\"o\">.</span><span class=\"n\">pose3d</span><span class=\"o\">.</span><span class=\"n\">SE3</span>, </span><span class=\"param\"><span class=\"n\">dt</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.05</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "ctrl.dmp_cartesian.dmp_cartesian.DMPCartesian.is_trained", "modulename": "ctrl.dmp_cartesian.dmp_cartesian", "qualname": "DMPCartesian.is_trained", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "ctrl.dmp_position", "modulename": "ctrl.dmp_position", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "ctrl.dmp_position.canonical_system", "modulename": "ctrl.dmp_position.canonical_system", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "ctrl.dmp_position.canonical_system.CanonicalSystem", "modulename": "ctrl.dmp_position.canonical_system", "qualname": "CanonicalSystem", "kind": "class", "doc": "<p></p>\n"}, {"fullname": "ctrl.dmp_position.canonical_system.CanonicalSystem.__init__", "modulename": "ctrl.dmp_position.canonical_system", "qualname": "CanonicalSystem.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">alpha</span><span class=\"p\">:</span> <span class=\"nb\">float</span></span>)</span>"}, {"fullname": "ctrl.dmp_position.canonical_system.CanonicalSystem.alpha", "modulename": "ctrl.dmp_position.canonical_system", "qualname": "CanonicalSystem.alpha", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "ctrl.dmp_position.canonical_system.CanonicalSystem.step_vectorized", "modulename": "ctrl.dmp_position.canonical_system", "qualname": "CanonicalSystem.step_vectorized", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "ctrl.dmp_position.canonical_system.CanonicalSystem.x", "modulename": "ctrl.dmp_position.canonical_system", "qualname": "CanonicalSystem.x", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "ctrl.dmp_position.canonical_system.CanonicalSystem.step", "modulename": "ctrl.dmp_position.canonical_system", "qualname": "CanonicalSystem.step", "kind": "function", "doc": "<p>Solve the canonical system at next time step t+dt.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>dt : float\n    Time step.\ntau : float\n    Temporal scaling factor.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">dt</span><span class=\"p\">:</span> <span class=\"nb\">float</span>, </span><span class=\"param\"><span class=\"n\">tau</span><span class=\"p\">:</span> <span class=\"nb\">float</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ctrl.dmp_position.canonical_system.CanonicalSystem.rollout", "modulename": "ctrl.dmp_position.canonical_system", "qualname": "CanonicalSystem.rollout", "kind": "function", "doc": "<p>Solve the canonical system.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>t : array_like\n    Time points for which to evaluate the integral.\ntau : array_like\n    Temporal scaling factor (scalar constant or same length as t).</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">t</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">]</span>, </span><span class=\"param\"><span class=\"n\">tau</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">]]</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ctrl.dmp_position.canonical_system.CanonicalSystem.reset", "modulename": "ctrl.dmp_position.canonical_system", "qualname": "CanonicalSystem.reset", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "ctrl.dmp_position.dmp_position", "modulename": "ctrl.dmp_position.dmp_position", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "ctrl.dmp_position.dmp_position.DMPPosition", "modulename": "ctrl.dmp_position.dmp_position", "qualname": "DMPPosition", "kind": "class", "doc": "<p></p>\n"}, {"fullname": "ctrl.dmp_position.dmp_position.DMPPosition.__init__", "modulename": "ctrl.dmp_position.dmp_position", "qualname": "DMPPosition.__init__", "kind": "function", "doc": "<p>Initialize the DMPPosition controller.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<ul>\n<li>n_bfs (int): Number of basis functions.</li>\n<li>alpha (float): Scaling factor for the spring-damper system.</li>\n<li>beta (float): Damping factor.</li>\n<li>cs_alpha: Alpha parameter for the canonical system.</li>\n<li>cs: Canonical system object.</li>\n<li>roto_dilatation (bool): Flag to enable rotation dilatation.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">n_bfs</span><span class=\"o\">=</span><span class=\"mi\">100</span>,</span><span class=\"param\">\t<span class=\"n\">alpha</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mi\">100</span>,</span><span class=\"param\">\t<span class=\"n\">beta</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">cs_alpha</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">cs</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">roto_dilatation</span><span class=\"o\">=</span><span class=\"kc\">False</span></span>)</span>"}, {"fullname": "ctrl.dmp_position.dmp_position.DMPPosition.n_bfs", "modulename": "ctrl.dmp_position.dmp_position", "qualname": "DMPPosition.n_bfs", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "ctrl.dmp_position.dmp_position.DMPPosition.alpha", "modulename": "ctrl.dmp_position.dmp_position", "qualname": "DMPPosition.alpha", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "ctrl.dmp_position.dmp_position.DMPPosition.beta", "modulename": "ctrl.dmp_position.dmp_position", "qualname": "DMPPosition.beta", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "ctrl.dmp_position.dmp_position.DMPPosition.cs", "modulename": "ctrl.dmp_position.dmp_position", "qualname": "DMPPosition.cs", "kind": "variable", "doc": "<p></p>\n", "annotation": ": ctrl.dmp_position.canonical_system.CanonicalSystem"}, {"fullname": "ctrl.dmp_position.dmp_position.DMPPosition.c", "modulename": "ctrl.dmp_position.dmp_position", "qualname": "DMPPosition.c", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "ctrl.dmp_position.dmp_position.DMPPosition.h", "modulename": "ctrl.dmp_position.dmp_position", "qualname": "DMPPosition.h", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "ctrl.dmp_position.dmp_position.DMPPosition.Dp", "modulename": "ctrl.dmp_position.dmp_position", "qualname": "DMPPosition.Dp", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "ctrl.dmp_position.dmp_position.DMPPosition.w", "modulename": "ctrl.dmp_position.dmp_position", "qualname": "DMPPosition.w", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "ctrl.dmp_position.dmp_position.DMPPosition.p", "modulename": "ctrl.dmp_position.dmp_position", "qualname": "DMPPosition.p", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "ctrl.dmp_position.dmp_position.DMPPosition.dp", "modulename": "ctrl.dmp_position.dmp_position", "qualname": "DMPPosition.dp", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "ctrl.dmp_position.dmp_position.DMPPosition.ddp", "modulename": "ctrl.dmp_position.dmp_position", "qualname": "DMPPosition.ddp", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "ctrl.dmp_position.dmp_position.DMPPosition.train_p", "modulename": "ctrl.dmp_position.dmp_position", "qualname": "DMPPosition.train_p", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "ctrl.dmp_position.dmp_position.DMPPosition.train_d_p", "modulename": "ctrl.dmp_position.dmp_position", "qualname": "DMPPosition.train_d_p", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "ctrl.dmp_position.dmp_position.DMPPosition.train_dd_p", "modulename": "ctrl.dmp_position.dmp_position", "qualname": "DMPPosition.train_dd_p", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "ctrl.dmp_position.dmp_position.DMPPosition.dt", "modulename": "ctrl.dmp_position.dmp_position", "qualname": "DMPPosition.dt", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "ctrl.dmp_position.dmp_position.DMPPosition.tau", "modulename": "ctrl.dmp_position.dmp_position", "qualname": "DMPPosition.tau", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "ctrl.dmp_position.dmp_position.DMPPosition.ts", "modulename": "ctrl.dmp_position.dmp_position", "qualname": "DMPPosition.ts", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "ctrl.dmp_position.dmp_position.DMPPosition.step", "modulename": "ctrl.dmp_position.dmp_position", "qualname": "DMPPosition.step", "kind": "function", "doc": "<p>Perform a single step of the DMP controller.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<ul>\n<li>x: Phase variable.</li>\n<li>dt: Time step size.</li>\n<li>tau: Movement duration scaling factor.</li>\n<li>force_disturbance: External force disturbance.</li>\n</ul>\n\n<h2 id=\"returns\">Returns</h2>\n\n<ul>\n<li>Tuple[np.ndarray, np.ndarray, np.ndarray]: Tuple containing position, velocity, and acceleration.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">x</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">dt</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">tau</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">force_disturbance</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span> <span class=\"o\">=</span> <span class=\"n\">array</span><span class=\"p\">([</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">])</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "ctrl.dmp_position.dmp_position.DMPPosition.rollout", "modulename": "ctrl.dmp_position.dmp_position", "qualname": "DMPPosition.rollout", "kind": "function", "doc": "<p>Perform a rollout of the DMP trajectory.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<ul>\n<li>ts: Time vector.</li>\n<li>tau: Movement duration scaling factor.</li>\n</ul>\n\n<h2 id=\"returns\">Returns</h2>\n\n<ul>\n<li>Tuple[np.ndarray, np.ndarray, np.ndarray]: Tuple containing positions, velocities, and accelerations.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">ts</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">tau</span><span class=\"p\">:</span> <span class=\"nb\">float</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "ctrl.dmp_position.dmp_position.DMPPosition.reset", "modulename": "ctrl.dmp_position.dmp_position", "qualname": "DMPPosition.reset", "kind": "function", "doc": "<p>Reset the DMP to the initial state.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "ctrl.dmp_position.dmp_position.DMPPosition.train", "modulename": "ctrl.dmp_position.dmp_position", "qualname": "DMPPosition.train", "kind": "function", "doc": "<p>Train the DMP with a given trajectory.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<ul>\n<li>positions (np.ndarray): Positions of the trajectory.</li>\n<li>ts (np.ndarray): Time vector.</li>\n<li>tau (float): Movement duration scaling factor.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">positions</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">ts</span><span class=\"p\">:</span> <span class=\"nb\">float</span>, </span><span class=\"param\"><span class=\"n\">tau</span><span class=\"p\">:</span> <span class=\"nb\">float</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "ctrl.dmp_position.dmp_position.DMPPosition.set_trained", "modulename": "ctrl.dmp_position.dmp_position", "qualname": "DMPPosition.set_trained", "kind": "function", "doc": "<p>Set the trained parameters of the DMP.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<ul>\n<li>w (np.ndarray): Weights for the forcing term.</li>\n<li>c (np.ndarray): Centres of the Gaussian basis functions.</li>\n<li>h (np.ndarray): Variance of the Gaussian basis functions.</li>\n<li>y0 (np.ndarray): Initial position.</li>\n<li>g (np.ndarray): Goal position.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">w</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">c</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">h</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">y0</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">g</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "ctrl.dmp_position.dmp_position.DMPPosition.gp", "modulename": "ctrl.dmp_position.dmp_position", "qualname": "DMPPosition.gp", "kind": "variable", "doc": "<p>Get the goal position.</p>\n", "annotation": ": numpy.ndarray"}, {"fullname": "ctrl.dmp_position.dmp_position.DMPPosition.p0", "modulename": "ctrl.dmp_position.dmp_position", "qualname": "DMPPosition.p0", "kind": "variable", "doc": "<p>Get the initial position.</p>\n", "annotation": ": numpy.ndarray"}, {"fullname": "ctrl.dmp_position.dmp_position.DMPPosition.load", "modulename": "ctrl.dmp_position.dmp_position", "qualname": "DMPPosition.load", "kind": "function", "doc": "<p>Load and train the DMP with a trajectory.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<ul>\n<li>Traj (sm.SE3): Trajectory as an SE3 object.</li>\n<li>dt (float): Time step size.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">Traj</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">spatialmath</span><span class=\"o\">.</span><span class=\"n\">pose3d</span><span class=\"o\">.</span><span class=\"n\">SE3</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">dt</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.05</span>,</span><span class=\"param\">\t<span class=\"n\">csv_headers</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"s1\">&#39;target_TCP_pose_0&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;target_TCP_pose_1&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;target_TCP_pose_2&#39;</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "ctrl.dmp_position.dmp_position.DMPPosition.is_trained", "modulename": "ctrl.dmp_position.dmp_position", "qualname": "DMPPosition.is_trained", "kind": "function", "doc": "<p>Check if the DMP has been trained.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<ul>\n<li>bool: True if the DMP has been trained, False otherwise.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "ctrl.dmp_quaternion", "modulename": "ctrl.dmp_quaternion", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "ctrl.dmp_quaternion.canonical_system", "modulename": "ctrl.dmp_quaternion.canonical_system", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "ctrl.dmp_quaternion.canonical_system.CanonicalSystem", "modulename": "ctrl.dmp_quaternion.canonical_system", "qualname": "CanonicalSystem", "kind": "class", "doc": "<p></p>\n"}, {"fullname": "ctrl.dmp_quaternion.canonical_system.CanonicalSystem.__init__", "modulename": "ctrl.dmp_quaternion.canonical_system", "qualname": "CanonicalSystem.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">alpha</span><span class=\"p\">:</span> <span class=\"nb\">float</span></span>)</span>"}, {"fullname": "ctrl.dmp_quaternion.canonical_system.CanonicalSystem.alpha", "modulename": "ctrl.dmp_quaternion.canonical_system", "qualname": "CanonicalSystem.alpha", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "ctrl.dmp_quaternion.canonical_system.CanonicalSystem.step_vectorized", "modulename": "ctrl.dmp_quaternion.canonical_system", "qualname": "CanonicalSystem.step_vectorized", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "ctrl.dmp_quaternion.canonical_system.CanonicalSystem.x", "modulename": "ctrl.dmp_quaternion.canonical_system", "qualname": "CanonicalSystem.x", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "ctrl.dmp_quaternion.canonical_system.CanonicalSystem.step", "modulename": "ctrl.dmp_quaternion.canonical_system", "qualname": "CanonicalSystem.step", "kind": "function", "doc": "<p>Solve the canonical system at next time step t+dt.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>dt : float\n    Time step.\ntau : float\n    Temporal scaling factor.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">dt</span><span class=\"p\">:</span> <span class=\"nb\">float</span>, </span><span class=\"param\"><span class=\"n\">tau</span><span class=\"p\">:</span> <span class=\"nb\">float</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ctrl.dmp_quaternion.canonical_system.CanonicalSystem.rollout", "modulename": "ctrl.dmp_quaternion.canonical_system", "qualname": "CanonicalSystem.rollout", "kind": "function", "doc": "<p>Solve the canonical system.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>t : array_like\n    Time points for which to evaluate the integral.\ntau : array_like\n    Temporal scaling factor (scalar constant or same length as t).</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">t</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">]</span>, </span><span class=\"param\"><span class=\"n\">tau</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">]]</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ctrl.dmp_quaternion.canonical_system.CanonicalSystem.reset", "modulename": "ctrl.dmp_quaternion.canonical_system", "qualname": "CanonicalSystem.reset", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ctrl.dmp_quaternion.dmp_quaternion", "modulename": "ctrl.dmp_quaternion.dmp_quaternion", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "ctrl.dmp_quaternion.dmp_quaternion.DMPQuaternion", "modulename": "ctrl.dmp_quaternion.dmp_quaternion", "qualname": "DMPQuaternion", "kind": "class", "doc": "<p>Dynamic Movement Primitives (DMP) for orientation in Cartesian space using quaternions.</p>\n\n<p>Based on:\n[1] A. Ude, B. Nemec, T. Petric, and J. Morimoto, \"Orientation in Cartesian\nspace dynamic movement primitives\", in 2014 IEEE International Conference on\nRobotics and Automation (ICRA), 2014, no. 3, pp 2997-3004.</p>\n"}, {"fullname": "ctrl.dmp_quaternion.dmp_quaternion.DMPQuaternion.__init__", "modulename": "ctrl.dmp_quaternion.dmp_quaternion", "qualname": "DMPQuaternion.__init__", "kind": "function", "doc": "<p>Initialize the DMPQuaternion.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>n_bfs : int\n    Number of basis functions.\nalpha : float\n    Filter constant.\nbeta : Optional[float]\n    Filter constant. If None, set to alpha / 4.\ncs_alpha : Optional[float]\n    Alpha value for the canonical system. If None, set to alpha / 2.\ncs : Optional[CanonicalSystem]\n    Canonical system instance. If None, create a new one with cs_alpha.\nroto_dilatation : bool\n    Flag to enable roto-dilatation.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">n_bfs</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">10</span>,</span><span class=\"param\">\t<span class=\"n\">alpha</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">48.0</span>,</span><span class=\"param\">\t<span class=\"n\">beta</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">cs_alpha</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">cs</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">ctrl</span><span class=\"o\">.</span><span class=\"n\">dmp_cartesian</span><span class=\"o\">.</span><span class=\"n\">canonical_system</span><span class=\"o\">.</span><span class=\"n\">CanonicalSystem</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">roto_dilatation</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span>)</span>"}, {"fullname": "ctrl.dmp_quaternion.dmp_quaternion.DMPQuaternion.n_bfs", "modulename": "ctrl.dmp_quaternion.dmp_quaternion", "qualname": "DMPQuaternion.n_bfs", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "ctrl.dmp_quaternion.dmp_quaternion.DMPQuaternion.alpha", "modulename": "ctrl.dmp_quaternion.dmp_quaternion", "qualname": "DMPQuaternion.alpha", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "ctrl.dmp_quaternion.dmp_quaternion.DMPQuaternion.beta", "modulename": "ctrl.dmp_quaternion.dmp_quaternion", "qualname": "DMPQuaternion.beta", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "ctrl.dmp_quaternion.dmp_quaternion.DMPQuaternion.cs", "modulename": "ctrl.dmp_quaternion.dmp_quaternion", "qualname": "DMPQuaternion.cs", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "ctrl.dmp_quaternion.dmp_quaternion.DMPQuaternion.c", "modulename": "ctrl.dmp_quaternion.dmp_quaternion", "qualname": "DMPQuaternion.c", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "ctrl.dmp_quaternion.dmp_quaternion.DMPQuaternion.h", "modulename": "ctrl.dmp_quaternion.dmp_quaternion", "qualname": "DMPQuaternion.h", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "ctrl.dmp_quaternion.dmp_quaternion.DMPQuaternion.Do", "modulename": "ctrl.dmp_quaternion.dmp_quaternion", "qualname": "DMPQuaternion.Do", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "ctrl.dmp_quaternion.dmp_quaternion.DMPQuaternion.w", "modulename": "ctrl.dmp_quaternion.dmp_quaternion", "qualname": "DMPQuaternion.w", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "ctrl.dmp_quaternion.dmp_quaternion.DMPQuaternion.q", "modulename": "ctrl.dmp_quaternion.dmp_quaternion", "qualname": "DMPQuaternion.q", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "ctrl.dmp_quaternion.dmp_quaternion.DMPQuaternion.omega", "modulename": "ctrl.dmp_quaternion.dmp_quaternion", "qualname": "DMPQuaternion.omega", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "ctrl.dmp_quaternion.dmp_quaternion.DMPQuaternion.d_omega", "modulename": "ctrl.dmp_quaternion.dmp_quaternion", "qualname": "DMPQuaternion.d_omega", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "ctrl.dmp_quaternion.dmp_quaternion.DMPQuaternion.train_quats", "modulename": "ctrl.dmp_quaternion.dmp_quaternion", "qualname": "DMPQuaternion.train_quats", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "ctrl.dmp_quaternion.dmp_quaternion.DMPQuaternion.train_omega", "modulename": "ctrl.dmp_quaternion.dmp_quaternion", "qualname": "DMPQuaternion.train_omega", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "ctrl.dmp_quaternion.dmp_quaternion.DMPQuaternion.train_d_omega", "modulename": "ctrl.dmp_quaternion.dmp_quaternion", "qualname": "DMPQuaternion.train_d_omega", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "ctrl.dmp_quaternion.dmp_quaternion.DMPQuaternion.step", "modulename": "ctrl.dmp_quaternion.dmp_quaternion", "qualname": "DMPQuaternion.step", "kind": "function", "doc": "<p>Perform a single DMP step.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>x : float\n    Phase variable.\ndt : float\n    Time step.\ntau : float\n    Temporal scaling factor.\ntorque_disturbance : np.ndarray, optional\n    External torque disturbance, by default np.array([0, 0, 0]).</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>Tuple[quaternion.quaternion, np.ndarray, np.ndarray]\n    Current quaternion, angular velocity, and angular acceleration.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">x</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">dt</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">tau</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">torque_disturbance</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span> <span class=\"o\">=</span> <span class=\"n\">array</span><span class=\"p\">([</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">])</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">quaternion</span><span class=\"o\">.</span><span class=\"n\">quaternion</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "ctrl.dmp_quaternion.dmp_quaternion.DMPQuaternion.rollout", "modulename": "ctrl.dmp_quaternion.dmp_quaternion", "qualname": "DMPQuaternion.rollout", "kind": "function", "doc": "<p>Perform a DMP rollout over the given time steps.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>ts : np.ndarray\n    Array of time steps.\ntau : Union[float, np.ndarray]\n    Temporal scaling factor.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>Tuple[np.ndarray, np.ndarray, np.ndarray]\n    Arrays of quaternions, angular velocities, and angular accelerations.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">ts</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">tau</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "ctrl.dmp_quaternion.dmp_quaternion.DMPQuaternion.reset", "modulename": "ctrl.dmp_quaternion.dmp_quaternion", "qualname": "DMPQuaternion.reset", "kind": "function", "doc": "<p>Reset the DMP state.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "ctrl.dmp_quaternion.dmp_quaternion.DMPQuaternion.train", "modulename": "ctrl.dmp_quaternion.dmp_quaternion", "qualname": "DMPQuaternion.train", "kind": "function", "doc": "<p>Train the DMP with given quaternion trajectory.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>quaternions : np.ndarray\n    Array of quaternions.\nts : np.ndarray\n    Array of time steps.\ntau : float\n    Temporal scaling factor.</p>\n\n<h2 id=\"raises\">Raises</h2>\n\n<p>RuntimeError\n    If the length of quaternions does not match the length of time steps.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">quaternions</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">ts</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">tau</span><span class=\"p\">:</span> <span class=\"nb\">float</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "ctrl.dmp_quaternion.dmp_quaternion.DMPQuaternion.set_trained", "modulename": "ctrl.dmp_quaternion.dmp_quaternion", "qualname": "DMPQuaternion.set_trained", "kind": "function", "doc": "<p>Set trained parameters for the DMP.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>w : np.ndarray\n    Weight matrix.\nc : np.ndarray\n    Centers of the Gaussian basis functions.\nh : np.ndarray\n    Variances of the Gaussian basis functions.\nq0 : quaternion.quaternion\n    Initial quaternion.\ngo : quaternion.quaternion\n    Goal quaternion.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">w</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">c</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">h</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">q0</span><span class=\"p\">:</span> <span class=\"n\">quaternion</span><span class=\"o\">.</span><span class=\"n\">quaternion</span>,</span><span class=\"param\">\t<span class=\"n\">go</span><span class=\"p\">:</span> <span class=\"n\">quaternion</span><span class=\"o\">.</span><span class=\"n\">quaternion</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "ctrl.dmp_quaternion.dmp_quaternion.DMPQuaternion.go", "modulename": "ctrl.dmp_quaternion.dmp_quaternion", "qualname": "DMPQuaternion.go", "kind": "variable", "doc": "<p>Get the goal quaternion.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>quaternion.quaternion\n    Goal quaternion.</p>\n", "annotation": ": quaternion.quaternion"}, {"fullname": "ctrl.dmp_quaternion.dmp_quaternion.DMPQuaternion.q0", "modulename": "ctrl.dmp_quaternion.dmp_quaternion", "qualname": "DMPQuaternion.q0", "kind": "variable", "doc": "<p>Get the initial quaternion.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>quaternion.quaternion\n    Initial quaternion.</p>\n", "annotation": ": quaternion.quaternion"}, {"fullname": "learning", "modulename": "learning", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "learning.envs", "modulename": "learning.envs", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "learning.envs.barkour", "modulename": "learning.envs.barkour", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "learning.envs.barkour.get_config", "modulename": "learning.envs.barkour", "qualname": "get_config", "kind": "function", "doc": "<p>Returns reward config for barkour quadruped environment.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "learning.envs.barkour.BarkourEnv", "modulename": "learning.envs.barkour", "qualname": "BarkourEnv", "kind": "class", "doc": "<p>Environment for training the barkour quadruped joystick policy in MJX.</p>\n", "bases": "brax.envs.base.PipelineEnv"}, {"fullname": "learning.envs.barkour.BarkourEnv.__init__", "modulename": "learning.envs.barkour", "qualname": "BarkourEnv.__init__", "kind": "function", "doc": "<p>Initializes PipelineEnv.</p>\n\n<p>Args:\n  sys: system defining the kinematic tree and other properties\n  backend: string specifying the physics pipeline\n  n_frames: the number of times to step the physics pipeline for each\n    environment step\n  debug: whether to get debug info from the pipeline init/step</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">obs_noise</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.05</span>,</span><span class=\"param\">\t<span class=\"n\">action_scale</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.3</span>,</span><span class=\"param\">\t<span class=\"n\">kick_vel</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.05</span>,</span><span class=\"param\">\t<span class=\"n\">scene_file</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;scene_mjx.xml&#39;</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">kwargs</span></span>)</span>"}, {"fullname": "learning.envs.barkour.BarkourEnv.reward_config", "modulename": "learning.envs.barkour", "qualname": "BarkourEnv.reward_config", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "learning.envs.barkour.BarkourEnv.lowers", "modulename": "learning.envs.barkour", "qualname": "BarkourEnv.lowers", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "learning.envs.barkour.BarkourEnv.uppers", "modulename": "learning.envs.barkour", "qualname": "BarkourEnv.uppers", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "learning.envs.barkour.BarkourEnv.sample_command", "modulename": "learning.envs.barkour", "qualname": "BarkourEnv.sample_command", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">rng</span><span class=\"p\">:</span> <span class=\"n\">jax</span><span class=\"o\">.</span><span class=\"n\">Array</span></span><span class=\"return-annotation\">) -> <span class=\"n\">jax</span><span class=\"o\">.</span><span class=\"n\">Array</span>:</span></span>", "funcdef": "def"}, {"fullname": "learning.envs.barkour.BarkourEnv.reset", "modulename": "learning.envs.barkour", "qualname": "BarkourEnv.reset", "kind": "function", "doc": "<p>Resets the environment to an initial state.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">rng</span><span class=\"p\">:</span> <span class=\"n\">jax</span><span class=\"o\">.</span><span class=\"n\">Array</span></span><span class=\"return-annotation\">) -> <span class=\"n\">brax</span><span class=\"o\">.</span><span class=\"n\">envs</span><span class=\"o\">.</span><span class=\"n\">base</span><span class=\"o\">.</span><span class=\"n\">State</span>:</span></span>", "funcdef": "def"}, {"fullname": "learning.envs.barkour.BarkourEnv.step", "modulename": "learning.envs.barkour", "qualname": "BarkourEnv.step", "kind": "function", "doc": "<p>Run one timestep of the environment's dynamics.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">state</span><span class=\"p\">:</span> <span class=\"n\">brax</span><span class=\"o\">.</span><span class=\"n\">envs</span><span class=\"o\">.</span><span class=\"n\">base</span><span class=\"o\">.</span><span class=\"n\">State</span>,</span><span class=\"param\">\t<span class=\"n\">action</span><span class=\"p\">:</span> <span class=\"n\">jax</span><span class=\"o\">.</span><span class=\"n\">Array</span></span><span class=\"return-annotation\">) -> <span class=\"n\">brax</span><span class=\"o\">.</span><span class=\"n\">envs</span><span class=\"o\">.</span><span class=\"n\">base</span><span class=\"o\">.</span><span class=\"n\">State</span>:</span></span>", "funcdef": "def"}, {"fullname": "learning.envs.barkour.BarkourEnv.render", "modulename": "learning.envs.barkour", "qualname": "BarkourEnv.render", "kind": "function", "doc": "<p>Renders a trajectory using the MuJoCo renderer.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">trajectory</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">brax</span><span class=\"o\">.</span><span class=\"n\">base</span><span class=\"o\">.</span><span class=\"n\">State</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">camera</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">|</span> <span class=\"kc\">None</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">width</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">320</span>,</span><span class=\"param\">\t<span class=\"n\">height</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">240</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Sequence</span><span class=\"p\">[</span><span class=\"n\">jax</span><span class=\"o\">.</span><span class=\"n\">Array</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "learning.envs.barkour.BarkourEnv.get_demo_video", "modulename": "learning.envs.barkour", "qualname": "BarkourEnv.get_demo_video", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">make_inference_fn</span><span class=\"p\">:</span> <span class=\"n\">Callable</span>,</span><span class=\"param\">\t<span class=\"n\">params</span><span class=\"p\">:</span> <span class=\"nb\">tuple</span>,</span><span class=\"param\">\t<span class=\"n\">eval_env</span><span class=\"p\">:</span> <span class=\"n\">learning</span><span class=\"o\">.</span><span class=\"n\">envs</span><span class=\"o\">.</span><span class=\"n\">barkour</span><span class=\"o\">.</span><span class=\"n\">BarkourEnv</span>,</span><span class=\"param\">\t<span class=\"n\">n_steps</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">500</span>,</span><span class=\"param\">\t<span class=\"n\">render_every</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">2</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "learning.envs.cable_weaving_primitive", "modulename": "learning.envs.cable_weaving_primitive", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "learning.envs.cable_weaving_primitive.CableWeavingPrimitive", "modulename": "learning.envs.cable_weaving_primitive", "qualname": "CableWeavingPrimitive", "kind": "class", "doc": "<p>API for driving a brax system for training and inference.</p>\n", "bases": "brax.envs.base.PipelineEnv"}, {"fullname": "learning.envs.cable_weaving_primitive.CableWeavingPrimitive.__init__", "modulename": "learning.envs.cable_weaving_primitive", "qualname": "CableWeavingPrimitive.__init__", "kind": "function", "doc": "<p>Initializes PipelineEnv.</p>\n\n<p>Args:\n  sys: system defining the kinematic tree and other properties\n  backend: string specifying the physics pipeline\n  n_frames: the number of times to step the physics pipeline for each\n    environment step\n  debug: whether to get debug info from the pipeline init/step</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span>)</span>"}, {"fullname": "learning.envs.cable_weaving_primitive.CableWeavingPrimitive.twof85", "modulename": "learning.envs.cable_weaving_primitive", "qualname": "CableWeavingPrimitive.twof85", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "learning.envs.cable_weaving_primitive.CableWeavingPrimitive.spec", "modulename": "learning.envs.cable_weaving_primitive", "qualname": "CableWeavingPrimitive.spec", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "learning.envs.cable_weaving_primitive.CableWeavingPrimitive.d_min", "modulename": "learning.envs.cable_weaving_primitive", "qualname": "CableWeavingPrimitive.d_min", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "learning.envs.cable_weaving_primitive.CableWeavingPrimitive.d_max", "modulename": "learning.envs.cable_weaving_primitive", "qualname": "CableWeavingPrimitive.d_max", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "learning.envs.cable_weaving_primitive.CableWeavingPrimitive.which_spec", "modulename": "learning.envs.cable_weaving_primitive", "qualname": "CableWeavingPrimitive.which_spec", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "learning.envs.cable_weaving_primitive.CableWeavingPrimitive.reference_paths", "modulename": "learning.envs.cable_weaving_primitive", "qualname": "CableWeavingPrimitive.reference_paths", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "learning.envs.cable_weaving_primitive.CableWeavingPrimitive.episode_timeout", "modulename": "learning.envs.cable_weaving_primitive", "qualname": "CableWeavingPrimitive.episode_timeout", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "learning.envs.cable_weaving_primitive.CableWeavingPrimitive.dmp_0", "modulename": "learning.envs.cable_weaving_primitive", "qualname": "CableWeavingPrimitive.dmp_0", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "learning.envs.cable_weaving_primitive.CableWeavingPrimitive.dmp_1", "modulename": "learning.envs.cable_weaving_primitive", "qualname": "CableWeavingPrimitive.dmp_1", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "learning.envs.cable_weaving_primitive.CableWeavingPrimitive.init", "modulename": "learning.envs.cable_weaving_primitive", "qualname": "CableWeavingPrimitive.init", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">brax</span><span class=\"o\">.</span><span class=\"n\">base</span><span class=\"o\">.</span><span class=\"n\">System</span>:</span></span>", "funcdef": "def"}, {"fullname": "learning.envs.cable_weaving_primitive.CableWeavingPrimitive.reset", "modulename": "learning.envs.cable_weaving_primitive", "qualname": "CableWeavingPrimitive.reset", "kind": "function", "doc": "<p>Resets the environment to an initial state.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">rng</span><span class=\"p\">:</span> <span class=\"n\">jax</span><span class=\"o\">.</span><span class=\"n\">Array</span></span><span class=\"return-annotation\">) -> <span class=\"n\">brax</span><span class=\"o\">.</span><span class=\"n\">envs</span><span class=\"o\">.</span><span class=\"n\">base</span><span class=\"o\">.</span><span class=\"n\">State</span>:</span></span>", "funcdef": "def"}, {"fullname": "learning.envs.cable_weaving_primitive.CableWeavingPrimitive.step", "modulename": "learning.envs.cable_weaving_primitive", "qualname": "CableWeavingPrimitive.step", "kind": "function", "doc": "<p>Runs one timestep of the environment's dynamics.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">state</span><span class=\"p\">:</span> <span class=\"n\">brax</span><span class=\"o\">.</span><span class=\"n\">envs</span><span class=\"o\">.</span><span class=\"n\">base</span><span class=\"o\">.</span><span class=\"n\">State</span>,</span><span class=\"param\">\t<span class=\"n\">action</span><span class=\"p\">:</span> <span class=\"n\">jax</span><span class=\"o\">.</span><span class=\"n\">Array</span></span><span class=\"return-annotation\">) -> <span class=\"n\">brax</span><span class=\"o\">.</span><span class=\"n\">envs</span><span class=\"o\">.</span><span class=\"n\">base</span><span class=\"o\">.</span><span class=\"n\">State</span>:</span></span>", "funcdef": "def"}, {"fullname": "learning.envs.cable_weaving_primitive.CableWeavingPrimitive.get_done", "modulename": "learning.envs.cable_weaving_primitive", "qualname": "CableWeavingPrimitive.get_done", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"n\">mujoco</span><span class=\"o\">.</span><span class=\"n\">mjx</span><span class=\"o\">.</span><span class=\"n\">_src</span><span class=\"o\">.</span><span class=\"n\">types</span><span class=\"o\">.</span><span class=\"n\">Data</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "learning.envs.cable_weaving_primitive.CableWeavingPrimitive.get_reward", "modulename": "learning.envs.cable_weaving_primitive", "qualname": "CableWeavingPrimitive.get_reward", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"n\">mujoco</span><span class=\"o\">.</span><span class=\"n\">mjx</span><span class=\"o\">.</span><span class=\"n\">_src</span><span class=\"o\">.</span><span class=\"n\">types</span><span class=\"o\">.</span><span class=\"n\">Data</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "learning.envs.cable_weaving_primitive.CableWeavingPrimitive.get_obs", "modulename": "learning.envs.cable_weaving_primitive", "qualname": "CableWeavingPrimitive.get_obs", "kind": "function", "doc": "<p>Placeholder function.</p>\n\n<p>Returns:\n    np.ndarray: An array.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"n\">mujoco</span><span class=\"o\">.</span><span class=\"n\">mjx</span><span class=\"o\">.</span><span class=\"n\">_src</span><span class=\"o\">.</span><span class=\"n\">types</span><span class=\"o\">.</span><span class=\"n\">Data</span>, </span><span class=\"param\"><span class=\"n\">action</span><span class=\"p\">:</span> <span class=\"n\">jax</span><span class=\"o\">.</span><span class=\"n\">Array</span></span><span class=\"return-annotation\">) -> <span class=\"n\">jax</span><span class=\"o\">.</span><span class=\"n\">Array</span>:</span></span>", "funcdef": "def"}, {"fullname": "learning.envs.humanoid_running", "modulename": "learning.envs.humanoid_running", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "learning.envs.humanoid_running.HumanoidRunning", "modulename": "learning.envs.humanoid_running", "qualname": "HumanoidRunning", "kind": "class", "doc": "<p>API for driving a brax system for training and inference.</p>\n", "bases": "brax.envs.base.PipelineEnv"}, {"fullname": "learning.envs.humanoid_running.HumanoidRunning.__init__", "modulename": "learning.envs.humanoid_running", "qualname": "HumanoidRunning.__init__", "kind": "function", "doc": "<p>HumanoidRunning is a simulation environment for a humanoid robot running task.</p>\n\n<p>Attributes:\n    _forward_reward_weight (float): Weight for the forward reward.\n    _ctrl_cost_weight (float): Weight for the control cost penalty.\n    _healthy_reward (float): Reward given when the humanoid is in a healthy state.\n    _terminate_when_unhealthy (bool): Whether to terminate the episode when unhealthy.\n    _healthy_z_range (tuple[float, float]): Range of z-axis values considered healthy.\n    _reset_noise_scale (float): Magnitude of random noise added during reset.\n    _exclude_current_positions_from_observation (bool): Whether to exclude current positions\n                                                        from observations.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span>)</span>"}, {"fullname": "learning.envs.humanoid_running.HumanoidRunning.reset", "modulename": "learning.envs.humanoid_running", "qualname": "HumanoidRunning.reset", "kind": "function", "doc": "<p>Resets the environment to an initial state.</p>\n\n<p>Args:\n    rng (jp.ndarray): Random key for initializing the environment.</p>\n\n<p>Returns:\n    State: Initial environment state.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">rng</span><span class=\"p\">:</span> <span class=\"n\">jax</span><span class=\"o\">.</span><span class=\"n\">Array</span></span><span class=\"return-annotation\">) -> <span class=\"n\">brax</span><span class=\"o\">.</span><span class=\"n\">envs</span><span class=\"o\">.</span><span class=\"n\">base</span><span class=\"o\">.</span><span class=\"n\">State</span>:</span></span>", "funcdef": "def"}, {"fullname": "learning.envs.humanoid_running.HumanoidRunning.step", "modulename": "learning.envs.humanoid_running", "qualname": "HumanoidRunning.step", "kind": "function", "doc": "<p>Runs one timestep of the environment's dynamics.</p>\n\n<p>Args:\n    state (State): Current state of the environment.\n    action (jp.ndarray): Action to be applied.</p>\n\n<p>Returns:\n    State: Updated state after applying the action.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">state</span><span class=\"p\">:</span> <span class=\"n\">brax</span><span class=\"o\">.</span><span class=\"n\">envs</span><span class=\"o\">.</span><span class=\"n\">base</span><span class=\"o\">.</span><span class=\"n\">State</span>,</span><span class=\"param\">\t<span class=\"n\">action</span><span class=\"p\">:</span> <span class=\"n\">jax</span><span class=\"o\">.</span><span class=\"n\">Array</span></span><span class=\"return-annotation\">) -> <span class=\"n\">brax</span><span class=\"o\">.</span><span class=\"n\">envs</span><span class=\"o\">.</span><span class=\"n\">base</span><span class=\"o\">.</span><span class=\"n\">State</span>:</span></span>", "funcdef": "def"}, {"fullname": "learning.envs.humanoid_running.HumanoidRunning.reward", "modulename": "learning.envs.humanoid_running", "qualname": "HumanoidRunning.reward", "kind": "function", "doc": "<p>Computes the reward for the current state transition.</p>\n\n<p>Args:\n    state (State): Current state.\n    data0 (State): Previous state data.\n    data (State): Current state data.\n    action (jp.ndarray): Action applied.</p>\n\n<p>Returns:\n    float: Computed reward.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">state</span><span class=\"p\">:</span> <span class=\"n\">brax</span><span class=\"o\">.</span><span class=\"n\">envs</span><span class=\"o\">.</span><span class=\"n\">base</span><span class=\"o\">.</span><span class=\"n\">State</span>,</span><span class=\"param\">\t<span class=\"n\">data0</span><span class=\"p\">:</span> <span class=\"n\">brax</span><span class=\"o\">.</span><span class=\"n\">envs</span><span class=\"o\">.</span><span class=\"n\">base</span><span class=\"o\">.</span><span class=\"n\">State</span>,</span><span class=\"param\">\t<span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"n\">brax</span><span class=\"o\">.</span><span class=\"n\">envs</span><span class=\"o\">.</span><span class=\"n\">base</span><span class=\"o\">.</span><span class=\"n\">State</span>,</span><span class=\"param\">\t<span class=\"n\">action</span><span class=\"p\">:</span> <span class=\"n\">jax</span><span class=\"o\">.</span><span class=\"n\">Array</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "learning.envs.humanoid_running.HumanoidRunning.render", "modulename": "learning.envs.humanoid_running", "qualname": "HumanoidRunning.render", "kind": "function", "doc": "<p>Renders a trajectory using the MuJoCo renderer.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">trajectory</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">brax</span><span class=\"o\">.</span><span class=\"n\">base</span><span class=\"o\">.</span><span class=\"n\">State</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">camera</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">|</span> <span class=\"kc\">None</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">width</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">320</span>,</span><span class=\"param\">\t<span class=\"n\">height</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">240</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Sequence</span><span class=\"p\">[</span><span class=\"n\">jax</span><span class=\"o\">.</span><span class=\"n\">Array</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "learning.envs.humanoid_running.HumanoidRunning.get_demo_video", "modulename": "learning.envs.humanoid_running", "qualname": "HumanoidRunning.get_demo_video", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">make_inference_fn</span><span class=\"p\">:</span> <span class=\"n\">Callable</span>,</span><span class=\"param\">\t<span class=\"n\">params</span><span class=\"p\">:</span> <span class=\"nb\">tuple</span>,</span><span class=\"param\">\t<span class=\"n\">n_steps</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">500</span>,</span><span class=\"param\">\t<span class=\"n\">render_every</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">2</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "learning.envs.in_hand_manipulation", "modulename": "learning.envs.in_hand_manipulation", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "learning.envs.in_hand_manipulation.InHandManipulation", "modulename": "learning.envs.in_hand_manipulation", "qualname": "InHandManipulation", "kind": "class", "doc": "<p>API for driving a brax system for training and inference.</p>\n", "bases": "brax.envs.base.PipelineEnv"}, {"fullname": "learning.envs.in_hand_manipulation.InHandManipulation.__init__", "modulename": "learning.envs.in_hand_manipulation", "qualname": "InHandManipulation.__init__", "kind": "function", "doc": "<p>Initializes PipelineEnv.</p>\n\n<p>Args:\n  sys: system defining the kinematic tree and other properties\n  backend: string specifying the physics pipeline\n  n_frames: the number of times to step the physics pipeline for each\n    environment step\n  debug: whether to get debug info from the pipeline init/step</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span>)</span>"}, {"fullname": "learning.envs.in_hand_manipulation.InHandManipulation.sys", "modulename": "learning.envs.in_hand_manipulation", "qualname": "InHandManipulation.sys", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "learning.envs.in_hand_manipulation.InHandManipulation.mj_model", "modulename": "learning.envs.in_hand_manipulation", "qualname": "InHandManipulation.mj_model", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "learning.envs.in_hand_manipulation.InHandManipulation.t_w_goal_cube", "modulename": "learning.envs.in_hand_manipulation", "qualname": "InHandManipulation.t_w_goal_cube", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "learning.envs.in_hand_manipulation.InHandManipulation.q_w_goal_cube", "modulename": "learning.envs.in_hand_manipulation", "qualname": "InHandManipulation.q_w_goal_cube", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "learning.envs.in_hand_manipulation.InHandManipulation.T_w_goal_cube", "modulename": "learning.envs.in_hand_manipulation", "qualname": "InHandManipulation.T_w_goal_cube", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "learning.envs.in_hand_manipulation.InHandManipulation.init", "modulename": "learning.envs.in_hand_manipulation", "qualname": "InHandManipulation.init", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">brax</span><span class=\"o\">.</span><span class=\"n\">base</span><span class=\"o\">.</span><span class=\"n\">System</span>:</span></span>", "funcdef": "def"}, {"fullname": "learning.envs.in_hand_manipulation.InHandManipulation.reset", "modulename": "learning.envs.in_hand_manipulation", "qualname": "InHandManipulation.reset", "kind": "function", "doc": "<p>Resets the environment to an initial state.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">rng</span><span class=\"p\">:</span> <span class=\"n\">jax</span><span class=\"o\">.</span><span class=\"n\">Array</span></span><span class=\"return-annotation\">) -> <span class=\"n\">brax</span><span class=\"o\">.</span><span class=\"n\">envs</span><span class=\"o\">.</span><span class=\"n\">base</span><span class=\"o\">.</span><span class=\"n\">State</span>:</span></span>", "funcdef": "def"}, {"fullname": "learning.envs.in_hand_manipulation.InHandManipulation.step", "modulename": "learning.envs.in_hand_manipulation", "qualname": "InHandManipulation.step", "kind": "function", "doc": "<p>Runs one timestep of the environment's dynamics.</p>\n\n<p>Args:\n    state (State): Current state of the environment.\n    action (jp.ndarray): Action to be applied.</p>\n\n<p>Returns:\n    State: Updated state after applying the action.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">state</span><span class=\"p\">:</span> <span class=\"n\">brax</span><span class=\"o\">.</span><span class=\"n\">envs</span><span class=\"o\">.</span><span class=\"n\">base</span><span class=\"o\">.</span><span class=\"n\">State</span>,</span><span class=\"param\">\t<span class=\"n\">action</span><span class=\"p\">:</span> <span class=\"n\">jax</span><span class=\"o\">.</span><span class=\"n\">Array</span></span><span class=\"return-annotation\">) -> <span class=\"n\">brax</span><span class=\"o\">.</span><span class=\"n\">envs</span><span class=\"o\">.</span><span class=\"n\">base</span><span class=\"o\">.</span><span class=\"n\">State</span>:</span></span>", "funcdef": "def"}, {"fullname": "learning.envs.panda_bring_to_target", "modulename": "learning.envs.panda_bring_to_target", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "learning.envs.panda_bring_to_target.default_config", "modulename": "learning.envs.panda_bring_to_target", "qualname": "default_config", "kind": "function", "doc": "<p>Returns reward config for the environment.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">) -> <span class=\"n\">ml_collections</span><span class=\"o\">.</span><span class=\"n\">config_dict</span><span class=\"o\">.</span><span class=\"n\">config_dict</span><span class=\"o\">.</span><span class=\"n\">ConfigDict</span>:</span></span>", "funcdef": "def"}, {"fullname": "learning.envs.panda_bring_to_target.PandaBringToTarget", "modulename": "learning.envs.panda_bring_to_target", "qualname": "PandaBringToTarget", "kind": "class", "doc": "<p>Environment for training franka panda to bring an object to target.</p>\n", "bases": "brax.envs.base.PipelineEnv"}, {"fullname": "learning.envs.panda_bring_to_target.PandaBringToTarget.__init__", "modulename": "learning.envs.panda_bring_to_target", "qualname": "PandaBringToTarget.__init__", "kind": "function", "doc": "<p>Initializes PipelineEnv.</p>\n\n<p>Args:\n  sys: system defining the kinematic tree and other properties\n  backend: string specifying the physics pipeline\n  n_frames: the number of times to step the physics pipeline for each\n    environment step\n  debug: whether to get debug info from the pipeline init/step</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span>)</span>"}, {"fullname": "learning.envs.panda_bring_to_target.PandaBringToTarget.camera_name", "modulename": "learning.envs.panda_bring_to_target", "qualname": "PandaBringToTarget.camera_name", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "learning.envs.panda_bring_to_target.PandaBringToTarget.reset", "modulename": "learning.envs.panda_bring_to_target", "qualname": "PandaBringToTarget.reset", "kind": "function", "doc": "<p>Resets the environment to an initial state.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">rng</span><span class=\"p\">:</span> <span class=\"n\">jax</span><span class=\"o\">.</span><span class=\"n\">Array</span></span><span class=\"return-annotation\">) -> <span class=\"n\">brax</span><span class=\"o\">.</span><span class=\"n\">envs</span><span class=\"o\">.</span><span class=\"n\">base</span><span class=\"o\">.</span><span class=\"n\">State</span>:</span></span>", "funcdef": "def"}, {"fullname": "learning.envs.panda_bring_to_target.PandaBringToTarget.step", "modulename": "learning.envs.panda_bring_to_target", "qualname": "PandaBringToTarget.step", "kind": "function", "doc": "<p>Run one timestep of the environment's dynamics.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">state</span><span class=\"p\">:</span> <span class=\"n\">brax</span><span class=\"o\">.</span><span class=\"n\">envs</span><span class=\"o\">.</span><span class=\"n\">base</span><span class=\"o\">.</span><span class=\"n\">State</span>,</span><span class=\"param\">\t<span class=\"n\">action</span><span class=\"p\">:</span> <span class=\"n\">jax</span><span class=\"o\">.</span><span class=\"n\">Array</span></span><span class=\"return-annotation\">) -> <span class=\"n\">brax</span><span class=\"o\">.</span><span class=\"n\">envs</span><span class=\"o\">.</span><span class=\"n\">base</span><span class=\"o\">.</span><span class=\"n\">State</span>:</span></span>", "funcdef": "def"}, {"fullname": "learning.envs.panda_bring_to_target.PandaBringToTarget.get_demo_video", "modulename": "learning.envs.panda_bring_to_target", "qualname": "PandaBringToTarget.get_demo_video", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">make_inference_fn</span><span class=\"p\">:</span> <span class=\"n\">Callable</span>,</span><span class=\"param\">\t<span class=\"n\">params</span><span class=\"p\">:</span> <span class=\"nb\">tuple</span>,</span><span class=\"param\">\t<span class=\"n\">n_steps</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">500</span>,</span><span class=\"param\">\t<span class=\"n\">render_every</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">2</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "learning.envs.panda_cable_weaving_primitive", "modulename": "learning.envs.panda_cable_weaving_primitive", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "learning.envs.panda_cable_weaving_primitive.Gripper", "modulename": "learning.envs.panda_cable_weaving_primitive", "qualname": "Gripper", "kind": "class", "doc": "<p>Base class for robot simulation in MuJoCo.</p>\n\n<p>This class provides a framework for simulating robots in MuJoCo environments. It defines\nkey properties and methods that should be implemented in child classes, including access\nto the robot's model, data, and control mechanisms.</p>\n", "bases": "robots.base_robot.BaseRobot"}, {"fullname": "learning.envs.panda_cable_weaving_primitive.Gripper.__init__", "modulename": "learning.envs.panda_cable_weaving_primitive", "qualname": "Gripper.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">model</span><span class=\"p\">:</span> <span class=\"n\">mujoco</span><span class=\"o\">.</span><span class=\"n\">_structs</span><span class=\"o\">.</span><span class=\"n\">MjModel</span></span>)</span>"}, {"fullname": "learning.envs.panda_cable_weaving_primitive.Gripper.name", "modulename": "learning.envs.panda_cable_weaving_primitive", "qualname": "Gripper.name", "kind": "variable", "doc": "<p>Get the name of the robot.</p>\n\n<p>This property returns the name of the robot as a string. The name is typically a unique identifier\nused to distinguish between different robots in the simulation environment.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>str\n    The name of the robot as a string.</p>\n", "annotation": ": str"}, {"fullname": "learning.envs.panda_cable_weaving_primitive.Gripper.get_ee_pose", "modulename": "learning.envs.panda_cable_weaving_primitive", "qualname": "Gripper.get_ee_pose", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"n\">mujoco</span><span class=\"o\">.</span><span class=\"n\">mjx</span><span class=\"o\">.</span><span class=\"n\">_src</span><span class=\"o\">.</span><span class=\"n\">types</span><span class=\"o\">.</span><span class=\"n\">Data</span></span><span class=\"return-annotation\">) -> <span class=\"n\">jaxlie</span><span class=\"o\">.</span><span class=\"n\">_se3</span><span class=\"o\">.</span><span class=\"n\">SE3</span>:</span></span>", "funcdef": "def"}, {"fullname": "learning.envs.panda_cable_weaving_primitive.Gripper.data", "modulename": "learning.envs.panda_cable_weaving_primitive", "qualname": "Gripper.data", "kind": "variable", "doc": "<p>Access the current simulation data.</p>\n\n<p>This property provides access to an instance of the <code>MjData</code> class, which contains the dynamic\nsimulation state. This includes quantities such as joint positions, velocities,\nactuator forces, and sensory information. The <code>MjData</code> object is updated at each simulation step\nand can be used to inspect the real-time state of the robot during the simulation.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>mj.MjData\n    An object representing the current dynamic state of the simulation.</p>\n", "annotation": ": mujoco._structs.MjData"}, {"fullname": "learning.envs.panda_cable_weaving_primitive.Gripper.model", "modulename": "learning.envs.panda_cable_weaving_primitive", "qualname": "Gripper.model", "kind": "variable", "doc": "<p>Access the model of the MuJoCo simulation.</p>\n\n<p>This property returns an instance of the <code>MjModel</code> class, which describes the physical and\nmechanical properties of the simulation. The <code>MjModel</code> object contains static information about the\nrobot such as its kinematic tree, inertial properties, joint and actuator definitions, and geometry\nconfigurations. It is used to define the robot's structure and behavior within the simulation.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>mj.MjModel\n    An object representing the static model of the robot and overall MuJoCo simulation.</p>\n", "annotation": ": mujoco._structs.MjModel"}, {"fullname": "learning.envs.panda_cable_weaving_primitive.Gripper.info", "modulename": "learning.envs.panda_cable_weaving_primitive", "qualname": "Gripper.info", "kind": "variable", "doc": "<p>Get detailed information about the robot.</p>\n\n<p>This property returns an instance of the <code>RobotInfo</code> class, which provides comprehensive\ndetails about the robot's structure and components. This includes information on the robot's\nbodies, joints, actuators, and geometries, among other attributes. The <code>RobotInfo</code> instance\ncan be used to access various properties such as the number of joints, actuator limits, joint\nlimits, and more.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>RobotInfo\n    An object containing detailed information about the robot's configuration and components.</p>\n", "annotation": ": utils.mj.RobotInfo"}, {"fullname": "learning.envs.panda_cable_weaving_primitive.Gripper.step", "modulename": "learning.envs.panda_cable_weaving_primitive", "qualname": "Gripper.step", "kind": "function", "doc": "<p>Perform a step in the controller.</p>\n\n<p>This method calls the <code>step()</code> method of the controller object and\nbefore doing so it checks if there are any tasks to be performed in\nthe robot task queue</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "learning.envs.panda_cable_weaving_primitive.PandaCableWeavingPrimitive", "modulename": "learning.envs.panda_cable_weaving_primitive", "qualname": "PandaCableWeavingPrimitive", "kind": "class", "doc": "<p>API for driving a brax system for training and inference.</p>\n", "bases": "brax.envs.base.PipelineEnv"}, {"fullname": "learning.envs.panda_cable_weaving_primitive.PandaCableWeavingPrimitive.__init__", "modulename": "learning.envs.panda_cable_weaving_primitive", "qualname": "PandaCableWeavingPrimitive.__init__", "kind": "function", "doc": "<p>Initializes PipelineEnv.</p>\n\n<p>Args:\n  sys: system defining the kinematic tree and other properties\n  backend: string specifying the physics pipeline\n  n_frames: the number of times to step the physics pipeline for each\n    environment step\n  debug: whether to get debug info from the pipeline init/step</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span>)</span>"}, {"fullname": "learning.envs.panda_cable_weaving_primitive.PandaCableWeavingPrimitive.sys", "modulename": "learning.envs.panda_cable_weaving_primitive", "qualname": "PandaCableWeavingPrimitive.sys", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "learning.envs.panda_cable_weaving_primitive.PandaCableWeavingPrimitive.mj_model", "modulename": "learning.envs.panda_cable_weaving_primitive", "qualname": "PandaCableWeavingPrimitive.mj_model", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "learning.envs.panda_cable_weaving_primitive.PandaCableWeavingPrimitive.gripper", "modulename": "learning.envs.panda_cable_weaving_primitive", "qualname": "PandaCableWeavingPrimitive.gripper", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "learning.envs.panda_cable_weaving_primitive.PandaCableWeavingPrimitive.spec", "modulename": "learning.envs.panda_cable_weaving_primitive", "qualname": "PandaCableWeavingPrimitive.spec", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "learning.envs.panda_cable_weaving_primitive.PandaCableWeavingPrimitive.d_min", "modulename": "learning.envs.panda_cable_weaving_primitive", "qualname": "PandaCableWeavingPrimitive.d_min", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "learning.envs.panda_cable_weaving_primitive.PandaCableWeavingPrimitive.d_max", "modulename": "learning.envs.panda_cable_weaving_primitive", "qualname": "PandaCableWeavingPrimitive.d_max", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "learning.envs.panda_cable_weaving_primitive.PandaCableWeavingPrimitive.which_spec", "modulename": "learning.envs.panda_cable_weaving_primitive", "qualname": "PandaCableWeavingPrimitive.which_spec", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "learning.envs.panda_cable_weaving_primitive.PandaCableWeavingPrimitive.reference_paths", "modulename": "learning.envs.panda_cable_weaving_primitive", "qualname": "PandaCableWeavingPrimitive.reference_paths", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "learning.envs.panda_cable_weaving_primitive.PandaCableWeavingPrimitive.episode_timeout", "modulename": "learning.envs.panda_cable_weaving_primitive", "qualname": "PandaCableWeavingPrimitive.episode_timeout", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "learning.envs.panda_cable_weaving_primitive.PandaCableWeavingPrimitive.dmp_0", "modulename": "learning.envs.panda_cable_weaving_primitive", "qualname": "PandaCableWeavingPrimitive.dmp_0", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "learning.envs.panda_cable_weaving_primitive.PandaCableWeavingPrimitive.dmp_1", "modulename": "learning.envs.panda_cable_weaving_primitive", "qualname": "PandaCableWeavingPrimitive.dmp_1", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "learning.envs.panda_cable_weaving_primitive.PandaCableWeavingPrimitive.n_key_frames", "modulename": "learning.envs.panda_cable_weaving_primitive", "qualname": "PandaCableWeavingPrimitive.n_key_frames", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "learning.envs.panda_cable_weaving_primitive.PandaCableWeavingPrimitive.all_keyframe_names", "modulename": "learning.envs.panda_cable_weaving_primitive", "qualname": "PandaCableWeavingPrimitive.all_keyframe_names", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "learning.envs.panda_cable_weaving_primitive.PandaCableWeavingPrimitive.key_frame_names", "modulename": "learning.envs.panda_cable_weaving_primitive", "qualname": "PandaCableWeavingPrimitive.key_frame_names", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "learning.envs.panda_cable_weaving_primitive.PandaCableWeavingPrimitive.key_frame_ids", "modulename": "learning.envs.panda_cable_weaving_primitive", "qualname": "PandaCableWeavingPrimitive.key_frame_ids", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "learning.envs.panda_cable_weaving_primitive.PandaCableWeavingPrimitive.all_geom_names", "modulename": "learning.envs.panda_cable_weaving_primitive", "qualname": "PandaCableWeavingPrimitive.all_geom_names", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "learning.envs.panda_cable_weaving_primitive.PandaCableWeavingPrimitive.cable_names", "modulename": "learning.envs.panda_cable_weaving_primitive", "qualname": "PandaCableWeavingPrimitive.cable_names", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "learning.envs.panda_cable_weaving_primitive.PandaCableWeavingPrimitive.init", "modulename": "learning.envs.panda_cable_weaving_primitive", "qualname": "PandaCableWeavingPrimitive.init", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">brax</span><span class=\"o\">.</span><span class=\"n\">base</span><span class=\"o\">.</span><span class=\"n\">System</span>:</span></span>", "funcdef": "def"}, {"fullname": "learning.envs.panda_cable_weaving_primitive.PandaCableWeavingPrimitive.reset", "modulename": "learning.envs.panda_cable_weaving_primitive", "qualname": "PandaCableWeavingPrimitive.reset", "kind": "function", "doc": "<p>Resets the environment to an initial state.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">rng</span><span class=\"p\">:</span> <span class=\"n\">jax</span><span class=\"o\">.</span><span class=\"n\">Array</span></span><span class=\"return-annotation\">) -> <span class=\"n\">brax</span><span class=\"o\">.</span><span class=\"n\">envs</span><span class=\"o\">.</span><span class=\"n\">base</span><span class=\"o\">.</span><span class=\"n\">State</span>:</span></span>", "funcdef": "def"}, {"fullname": "learning.envs.panda_cable_weaving_primitive.PandaCableWeavingPrimitive.step", "modulename": "learning.envs.panda_cable_weaving_primitive", "qualname": "PandaCableWeavingPrimitive.step", "kind": "function", "doc": "<p>Run one timestep of the environment's dynamics.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">state</span><span class=\"p\">:</span> <span class=\"n\">brax</span><span class=\"o\">.</span><span class=\"n\">envs</span><span class=\"o\">.</span><span class=\"n\">base</span><span class=\"o\">.</span><span class=\"n\">State</span>,</span><span class=\"param\">\t<span class=\"n\">action</span><span class=\"p\">:</span> <span class=\"n\">jax</span><span class=\"o\">.</span><span class=\"n\">Array</span></span><span class=\"return-annotation\">) -> <span class=\"n\">brax</span><span class=\"o\">.</span><span class=\"n\">envs</span><span class=\"o\">.</span><span class=\"n\">base</span><span class=\"o\">.</span><span class=\"n\">State</span>:</span></span>", "funcdef": "def"}, {"fullname": "learning.envs.panda_cable_weaving_primitive.PandaCableWeavingPrimitive.get_done", "modulename": "learning.envs.panda_cable_weaving_primitive", "qualname": "PandaCableWeavingPrimitive.get_done", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"n\">mujoco</span><span class=\"o\">.</span><span class=\"n\">mjx</span><span class=\"o\">.</span><span class=\"n\">_src</span><span class=\"o\">.</span><span class=\"n\">types</span><span class=\"o\">.</span><span class=\"n\">Data</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "learning.envs.panda_cable_weaving_primitive.PandaCableWeavingPrimitive.get_reward", "modulename": "learning.envs.panda_cable_weaving_primitive", "qualname": "PandaCableWeavingPrimitive.get_reward", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"n\">mujoco</span><span class=\"o\">.</span><span class=\"n\">mjx</span><span class=\"o\">.</span><span class=\"n\">_src</span><span class=\"o\">.</span><span class=\"n\">types</span><span class=\"o\">.</span><span class=\"n\">Data</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "learning.envs.panda_cable_weaving_primitive.PandaCableWeavingPrimitive.get_obs", "modulename": "learning.envs.panda_cable_weaving_primitive", "qualname": "PandaCableWeavingPrimitive.get_obs", "kind": "function", "doc": "<p>Placeholder function.</p>\n\n<p>Returns:\n    np.ndarray: An array.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"n\">mujoco</span><span class=\"o\">.</span><span class=\"n\">mjx</span><span class=\"o\">.</span><span class=\"n\">_src</span><span class=\"o\">.</span><span class=\"n\">types</span><span class=\"o\">.</span><span class=\"n\">Data</span>, </span><span class=\"param\"><span class=\"n\">action</span><span class=\"p\">:</span> <span class=\"n\">jax</span><span class=\"o\">.</span><span class=\"n\">Array</span></span><span class=\"return-annotation\">) -> <span class=\"n\">jax</span><span class=\"o\">.</span><span class=\"n\">Array</span>:</span></span>", "funcdef": "def"}, {"fullname": "learning.envs.test", "modulename": "learning.envs.test", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "learning.envs.test.TestEnv", "modulename": "learning.envs.test", "qualname": "TestEnv", "kind": "class", "doc": "<p>A pure physics simulation of a falling box using Brax.</p>\n"}, {"fullname": "learning.envs.test.TestEnv.sys", "modulename": "learning.envs.test", "qualname": "TestEnv.sys", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "learning.envs.test.TestEnv.init", "modulename": "learning.envs.test", "qualname": "TestEnv.init", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">brax</span><span class=\"o\">.</span><span class=\"n\">base</span><span class=\"o\">.</span><span class=\"n\">System</span>:</span></span>", "funcdef": "def"}, {"fullname": "learning.envs.test.TestEnv.reset", "modulename": "learning.envs.test", "qualname": "TestEnv.reset", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">rng</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "learning.envs.test.TestEnv.step", "modulename": "learning.envs.test", "qualname": "TestEnv.step", "kind": "function", "doc": "<p>Advances the simulation by one step.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">qp</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "robots", "modulename": "robots", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "robots.base_robot", "modulename": "robots.base_robot", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "robots.base_robot.BaseRobot", "modulename": "robots.base_robot", "qualname": "BaseRobot", "kind": "class", "doc": "<p>Base class for robot simulation in MuJoCo.</p>\n\n<p>This class provides a framework for simulating robots in MuJoCo environments. It defines\nkey properties and methods that should be implemented in child classes, including access\nto the robot's model, data, and control mechanisms.</p>\n", "bases": "abc.ABC"}, {"fullname": "robots.base_robot.BaseRobot.name", "modulename": "robots.base_robot", "qualname": "BaseRobot.name", "kind": "variable", "doc": "<p>Get the name of the robot.</p>\n\n<p>This property returns the name of the robot as a string. The name is typically a unique identifier\nused to distinguish between different robots in the simulation environment.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>str\n    The name of the robot as a string.</p>\n", "annotation": ": str"}, {"fullname": "robots.base_robot.BaseRobot.data", "modulename": "robots.base_robot", "qualname": "BaseRobot.data", "kind": "variable", "doc": "<p>Access the current simulation data.</p>\n\n<p>This property provides access to an instance of the <code>MjData</code> class, which contains the dynamic\nsimulation state. This includes quantities such as joint positions, velocities,\nactuator forces, and sensory information. The <code>MjData</code> object is updated at each simulation step\nand can be used to inspect the real-time state of the robot during the simulation.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>mj.MjData\n    An object representing the current dynamic state of the simulation.</p>\n", "annotation": ": mujoco._structs.MjData"}, {"fullname": "robots.base_robot.BaseRobot.model", "modulename": "robots.base_robot", "qualname": "BaseRobot.model", "kind": "variable", "doc": "<p>Access the model of the MuJoCo simulation.</p>\n\n<p>This property returns an instance of the <code>MjModel</code> class, which describes the physical and\nmechanical properties of the simulation. The <code>MjModel</code> object contains static information about the\nrobot such as its kinematic tree, inertial properties, joint and actuator definitions, and geometry\nconfigurations. It is used to define the robot's structure and behavior within the simulation.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>mj.MjModel\n    An object representing the static model of the robot and overall MuJoCo simulation.</p>\n", "annotation": ": mujoco._structs.MjModel"}, {"fullname": "robots.base_robot.BaseRobot.info", "modulename": "robots.base_robot", "qualname": "BaseRobot.info", "kind": "variable", "doc": "<p>Get detailed information about the robot.</p>\n\n<p>This property returns an instance of the <code>RobotInfo</code> class, which provides comprehensive\ndetails about the robot's structure and components. This includes information on the robot's\nbodies, joints, actuators, and geometries, among other attributes. The <code>RobotInfo</code> instance\ncan be used to access various properties such as the number of joints, actuator limits, joint\nlimits, and more.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>RobotInfo\n    An object containing detailed information about the robot's configuration and components.</p>\n", "annotation": ": utils.mj.RobotInfo"}, {"fullname": "robots.base_robot.BaseRobot.step", "modulename": "robots.base_robot", "qualname": "BaseRobot.step", "kind": "function", "doc": "<p>Perform a step in the controller.</p>\n\n<p>This method calls the <code>step()</code> method of the controller object and\nbefore doing so it checks if there are any tasks to be performed in\nthe robot task queue</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "robots.base_robot.BaseRobot.set_ctrl", "modulename": "robots.base_robot", "qualname": "BaseRobot.set_ctrl", "kind": "function", "doc": "<p>This function sends the control signal to the simulated robot.</p>\n\n<h2 id=\"args\">Args</h2>\n\n<pre><code>    x (Union[list, np.ndarray]): control signal\n</code></pre>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">x</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">list</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "robots.base_robot.BaseRobot.ctrl", "modulename": "robots.base_robot", "qualname": "BaseRobot.ctrl", "kind": "variable", "doc": "<p>The control signal sent to the robot's actuator(s).</p>\n", "annotation": ": List[float]"}, {"fullname": "robots.base_robot.BaseRobot.Jp", "modulename": "robots.base_robot", "qualname": "BaseRobot.Jp", "kind": "variable", "doc": "<p>Get the position Jacobian in base frame.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<pre><code>    Position Jacobian as a numpy array.\n</code></pre>\n", "annotation": ": numpy.ndarray"}, {"fullname": "robots.base_robot.BaseRobot.Jo", "modulename": "robots.base_robot", "qualname": "BaseRobot.Jo", "kind": "variable", "doc": "<p>Get the orientation Jacobian in base frame.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<pre><code>    Orientation Jacobian as a numpy array.\n</code></pre>\n", "annotation": ": numpy.ndarray"}, {"fullname": "robots.base_robot.BaseRobot.J", "modulename": "robots.base_robot", "qualname": "BaseRobot.J", "kind": "variable", "doc": "<p>Get the full Jacobian in base frame.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<pre><code>    Full Jacobian as a numpy array.\n</code></pre>\n", "annotation": ": numpy.ndarray"}, {"fullname": "robots.base_robot.BaseRobot.c", "modulename": "robots.base_robot", "qualname": "BaseRobot.c", "kind": "variable", "doc": "<p>bias force: Coriolis, centrifugal, gravitational</p>\n", "annotation": ": numpy.ndarray"}, {"fullname": "robots.base_robot.BaseRobot.Mq", "modulename": "robots.base_robot", "qualname": "BaseRobot.Mq", "kind": "variable", "doc": "<p>Getter property for the inertia matrix M(q) in joint space.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<ul>\n<li>numpy.ndarray: Symmetric inertia matrix in joint space.</li>\n</ul>\n", "annotation": ": numpy.ndarray"}, {"fullname": "robots.base_robot.BaseRobot.Mx", "modulename": "robots.base_robot", "qualname": "BaseRobot.Mx", "kind": "variable", "doc": "<p>Getter property for the inertia matrix M(q) in task space.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<ul>\n<li>numpy.ndarray: Symmetric inertia matrix in task space.</li>\n</ul>\n", "annotation": ": numpy.ndarray"}, {"fullname": "robots.base_robot.BaseRobot.q", "modulename": "robots.base_robot", "qualname": "BaseRobot.q", "kind": "variable", "doc": "<p>Get the joint positions.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<pre><code>    Joint positions as a numpy array.\n</code></pre>\n", "annotation": ": numpy.ndarray"}, {"fullname": "robots.base_robot.BaseRobot.dq", "modulename": "robots.base_robot", "qualname": "BaseRobot.dq", "kind": "variable", "doc": "<p>Get the joint velocities.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<pre><code>    Joint velocities as a numpy array.\n</code></pre>\n", "annotation": ": numpy.ndarray"}, {"fullname": "robots.base_robot.BaseRobot.ddq", "modulename": "robots.base_robot", "qualname": "BaseRobot.ddq", "kind": "variable", "doc": "<p>Get the joint accelerations.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<pre><code>    Joint accelerations as a numpy array.\n</code></pre>\n", "annotation": ": numpy.ndarray"}, {"fullname": "robots.franka_emika_panda", "modulename": "robots.franka_emika_panda", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "robots.franka_emika_panda.FrankaPanda", "modulename": "robots.franka_emika_panda", "qualname": "FrankaPanda", "kind": "class", "doc": "<p>Base class for robot simulation in MuJoCo.</p>\n\n<p>This class provides a framework for simulating robots in MuJoCo environments. It defines\nkey properties and methods that should be implemented in child classes, including access\nto the robot's model, data, and control mechanisms.</p>\n", "bases": "robots.base_robot.BaseRobot"}, {"fullname": "robots.franka_emika_panda.FrankaPanda.__init__", "modulename": "robots.franka_emika_panda", "qualname": "FrankaPanda.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">model</span><span class=\"p\">:</span> <span class=\"n\">mujoco</span><span class=\"o\">.</span><span class=\"n\">_structs</span><span class=\"o\">.</span><span class=\"n\">MjModel</span>, </span><span class=\"param\"><span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"n\">mujoco</span><span class=\"o\">.</span><span class=\"n\">_structs</span><span class=\"o\">.</span><span class=\"n\">MjData</span></span>)</span>"}, {"fullname": "robots.franka_emika_panda.FrankaPanda.dt", "modulename": "robots.franka_emika_panda", "qualname": "FrankaPanda.dt", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "robots.franka_emika_panda.FrankaPanda.home_qpos", "modulename": "robots.franka_emika_panda", "qualname": "FrankaPanda.home_qpos", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "robots.franka_emika_panda.FrankaPanda.step", "modulename": "robots.franka_emika_panda", "qualname": "FrankaPanda.step", "kind": "function", "doc": "<p>Perform a step in the controller.</p>\n\n<p>This method calls the <code>step()</code> method of the controller object and\nbefore doing so it checks if there are any tasks to be performed in\nthe robot task queue</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "robots.franka_emika_panda.FrankaPanda.info", "modulename": "robots.franka_emika_panda", "qualname": "FrankaPanda.info", "kind": "variable", "doc": "<p>Get detailed information about the robot.</p>\n\n<p>This property returns an instance of the <code>RobotInfo</code> class, which provides comprehensive\ndetails about the robot's structure and components. This includes information on the robot's\nbodies, joints, actuators, and geometries, among other attributes. The <code>RobotInfo</code> instance\ncan be used to access various properties such as the number of joints, actuator limits, joint\nlimits, and more.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>RobotInfo\n    An object containing detailed information about the robot's configuration and components.</p>\n", "annotation": ": utils.mj.RobotInfo"}, {"fullname": "robots.franka_emika_panda.FrankaPanda.data", "modulename": "robots.franka_emika_panda", "qualname": "FrankaPanda.data", "kind": "variable", "doc": "<p>Access the current simulation data.</p>\n\n<p>This property provides access to an instance of the <code>MjData</code> class, which contains the dynamic\nsimulation state. This includes quantities such as joint positions, velocities,\nactuator forces, and sensory information. The <code>MjData</code> object is updated at each simulation step\nand can be used to inspect the real-time state of the robot during the simulation.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>mj.MjData\n    An object representing the current dynamic state of the simulation.</p>\n", "annotation": ": mujoco._structs.MjData"}, {"fullname": "robots.franka_emika_panda.FrankaPanda.model", "modulename": "robots.franka_emika_panda", "qualname": "FrankaPanda.model", "kind": "variable", "doc": "<p>Access the model of the MuJoCo simulation.</p>\n\n<p>This property returns an instance of the <code>MjModel</code> class, which describes the physical and\nmechanical properties of the simulation. The <code>MjModel</code> object contains static information about the\nrobot such as its kinematic tree, inertial properties, joint and actuator definitions, and geometry\nconfigurations. It is used to define the robot's structure and behavior within the simulation.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>mj.MjModel\n    An object representing the static model of the robot and overall MuJoCo simulation.</p>\n", "annotation": ": mujoco._structs.MjModel"}, {"fullname": "robots.franka_emika_panda.FrankaPanda.name", "modulename": "robots.franka_emika_panda", "qualname": "FrankaPanda.name", "kind": "variable", "doc": "<p>Get the name of the robot.</p>\n\n<p>This property returns the name of the robot as a string. The name is typically a unique identifier\nused to distinguish between different robots in the simulation environment.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>str\n    The name of the robot as a string.</p>\n", "annotation": ": str"}, {"fullname": "robots.franka_emika_panda.FrankaPanda.actuator_values", "modulename": "robots.franka_emika_panda", "qualname": "FrankaPanda.actuator_values", "kind": "variable", "doc": "<p>Get the values of the actuators.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<pre><code>    List of actuator values.\n</code></pre>\n", "annotation": ": List[float]"}, {"fullname": "robots.mocap", "modulename": "robots.mocap", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "robots.mocap.Mocap", "modulename": "robots.mocap", "qualname": "Mocap", "kind": "class", "doc": "<p>A controller class for handling motion capture (Mocap) data and robot transformations.</p>\n", "bases": "robots.base_robot.BaseRobot"}, {"fullname": "robots.mocap.Mocap.__init__", "modulename": "robots.mocap", "qualname": "Mocap.__init__", "kind": "function", "doc": "<p>Initialize the Mocap controller.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>args : Namespace\n    Arguments for the controller.\nrobot : Robot\n    Robot instance with model and data attributes.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">model</span><span class=\"p\">:</span> <span class=\"n\">mujoco</span><span class=\"o\">.</span><span class=\"n\">_structs</span><span class=\"o\">.</span><span class=\"n\">MjModel</span>,</span><span class=\"param\">\t<span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"n\">mujoco</span><span class=\"o\">.</span><span class=\"n\">_structs</span><span class=\"o\">.</span><span class=\"n\">MjData</span>,</span><span class=\"param\">\t<span class=\"n\">name</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;mocap&#39;</span></span>)</span>"}, {"fullname": "robots.mocap.Mocap.T_target", "modulename": "robots.mocap", "qualname": "Mocap.T_target", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "robots.mocap.Mocap.name", "modulename": "robots.mocap", "qualname": "Mocap.name", "kind": "variable", "doc": "<p>Get the name of the robot.</p>\n\n<p>This property returns the name of the robot as a string. The name is typically a unique identifier\nused to distinguish between different robots in the simulation environment.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>str\n    The name of the robot as a string.</p>\n", "annotation": ": str"}, {"fullname": "robots.mocap.Mocap.data", "modulename": "robots.mocap", "qualname": "Mocap.data", "kind": "variable", "doc": "<p>Access the current simulation data.</p>\n\n<p>This property provides access to an instance of the <code>MjData</code> class, which contains the dynamic\nsimulation state. This includes quantities such as joint positions, velocities,\nactuator forces, and sensory information. The <code>MjData</code> object is updated at each simulation step\nand can be used to inspect the real-time state of the robot during the simulation.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>mj.MjData\n    An object representing the current dynamic state of the simulation.</p>\n", "annotation": ": mujoco._structs.MjData"}, {"fullname": "robots.mocap.Mocap.model", "modulename": "robots.mocap", "qualname": "Mocap.model", "kind": "variable", "doc": "<p>Access the model of the MuJoCo simulation.</p>\n\n<p>This property returns an instance of the <code>MjModel</code> class, which describes the physical and\nmechanical properties of the simulation. The <code>MjModel</code> object contains static information about the\nrobot such as its kinematic tree, inertial properties, joint and actuator definitions, and geometry\nconfigurations. It is used to define the robot's structure and behavior within the simulation.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>mj.MjModel\n    An object representing the static model of the robot and overall MuJoCo simulation.</p>\n", "annotation": ": mujoco._structs.MjModel"}, {"fullname": "robots.mocap.Mocap.info", "modulename": "robots.mocap", "qualname": "Mocap.info", "kind": "variable", "doc": "<p>Get detailed information about the robot.</p>\n\n<p>This property returns an instance of the <code>RobotInfo</code> class, which provides comprehensive\ndetails about the robot's structure and components. This includes information on the robot's\nbodies, joints, actuators, and geometries, among other attributes. The <code>RobotInfo</code> instance\ncan be used to access various properties such as the number of joints, actuator limits, joint\nlimits, and more.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>RobotInfo\n    An object containing detailed information about the robot's configuration and components.</p>\n", "annotation": ": utils.mj.RobotInfo"}, {"fullname": "robots.mocap.Mocap.step", "modulename": "robots.mocap", "qualname": "Mocap.step", "kind": "function", "doc": "<p>Perform a step in the controller.</p>\n\n<p>This method calls the <code>step()</code> method of the controller object and\nbefore doing so it checks if there are any tasks to be performed in\nthe robot task queue</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "robots.mocap.Mocap.T_world_base", "modulename": "robots.mocap", "qualname": "Mocap.T_world_base", "kind": "variable", "doc": "<p>Get the transformation matrix from the world frame to the mocap system.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>sm.SE3\n    Transformation matrix from world to mocap system.</p>\n", "annotation": ": spatialmath.pose3d.SE3"}, {"fullname": "robots.mocap.Mocap.move_l", "modulename": "robots.mocap", "qualname": "Mocap.move_l", "kind": "function", "doc": "<p>Move to a given position in task-space (or cartesian space).\nThe robot guides the TCP at a defined velocity along a straight path to the end point defined by T.</p>\n\n<p>Args:\n    T (sm.SE3): The desired end-effector pose in the base frame.\n    velocity (Union[list, np.ndarray]): tool velocity [m/s]\n    acceleration (Union[list, np.ndarray]): tool acceleration [m/s^2]</p>\n\n<p>Returns:\n    success (bool): True if the move succeeds and False otherwise.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">T</span><span class=\"p\">:</span> <span class=\"n\">spatialmath</span><span class=\"o\">.</span><span class=\"n\">pose3d</span><span class=\"o\">.</span><span class=\"n\">SE3</span>,</span><span class=\"param\">\t<span class=\"n\">ss</span><span class=\"p\">:</span> <span class=\"n\">sims</span><span class=\"o\">.</span><span class=\"n\">base_sim</span><span class=\"o\">.</span><span class=\"n\">SimSync</span>,</span><span class=\"param\">\t<span class=\"n\">velocity</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">list</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mf\">0.25</span>,</span><span class=\"param\">\t<span class=\"n\">acceleration</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">list</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mf\">1.2</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "robots.mocap.Mocap.move_traj", "modulename": "robots.mocap", "qualname": "Mocap.move_traj", "kind": "function", "doc": "<p>Move the robot along a given trajectory.</p>\n\n<p>This function enqueues a series of task poses for the robot to follow sequentially.</p>\n\n<h2 id=\"args\">Args</h2>\n\n<pre><code>    T (Union[sm.SE3, List]): List of desired end-effector poses in the base frame.\n</code></pre>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">T</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">spatialmath</span><span class=\"o\">.</span><span class=\"n\">pose3d</span><span class=\"o\">.</span><span class=\"n\">SE3</span><span class=\"p\">,</span> <span class=\"n\">List</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">ss</span><span class=\"p\">:</span> <span class=\"n\">sims</span><span class=\"o\">.</span><span class=\"n\">base_sim</span><span class=\"o\">.</span><span class=\"n\">SimSync</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "robots.shadow_hand", "modulename": "robots.shadow_hand", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "robots.shadow_hand.ShadowHand", "modulename": "robots.shadow_hand", "qualname": "ShadowHand", "kind": "class", "doc": "<p>Base class for robot simulation in MuJoCo.</p>\n\n<p>This class provides a framework for simulating robots in MuJoCo environments. It defines\nkey properties and methods that should be implemented in child classes, including access\nto the robot's model, data, and control mechanisms.</p>\n", "bases": "robots.base_robot.BaseRobot"}, {"fullname": "robots.shadow_hand.ShadowHand.__init__", "modulename": "robots.shadow_hand", "qualname": "ShadowHand.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">model</span><span class=\"p\">:</span> <span class=\"n\">mujoco</span><span class=\"o\">.</span><span class=\"n\">_structs</span><span class=\"o\">.</span><span class=\"n\">MjModel</span>,</span><span class=\"param\">\t<span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"n\">mujoco</span><span class=\"o\">.</span><span class=\"n\">_structs</span><span class=\"o\">.</span><span class=\"n\">MjData</span>,</span><span class=\"param\">\t<span class=\"nb\">type</span><span class=\"p\">:</span> <span class=\"n\">robots</span><span class=\"o\">.</span><span class=\"n\">shadow_hand</span><span class=\"o\">.</span><span class=\"n\">ShadowHand</span><span class=\"o\">.</span><span class=\"n\">Type</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">Type</span><span class=\"o\">.</span><span class=\"n\">RIGHT</span><span class=\"p\">:</span> <span class=\"s1\">&#39;right&#39;</span><span class=\"o\">&gt;</span>,</span><span class=\"param\">\t<span class=\"n\">args</span><span class=\"o\">=</span><span class=\"kc\">None</span></span>)</span>"}, {"fullname": "robots.shadow_hand.ShadowHand.Type", "modulename": "robots.shadow_hand", "qualname": "ShadowHand.Type", "kind": "class", "doc": "<p></p>\n", "bases": "enum.Enum"}, {"fullname": "robots.shadow_hand.ShadowHand.Type.RIGHT", "modulename": "robots.shadow_hand", "qualname": "ShadowHand.Type.RIGHT", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;Type.RIGHT: &#x27;right&#x27;&gt;"}, {"fullname": "robots.shadow_hand.ShadowHand.Type.LEFT", "modulename": "robots.shadow_hand", "qualname": "ShadowHand.Type.LEFT", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;Type.LEFT: &#x27;left&#x27;&gt;"}, {"fullname": "robots.shadow_hand.ShadowHand.ShadowFinger", "modulename": "robots.shadow_hand", "qualname": "ShadowHand.ShadowFinger", "kind": "class", "doc": "<p>Base class for robot simulation in MuJoCo.</p>\n\n<p>This class provides a framework for simulating robots in MuJoCo environments. It defines\nkey properties and methods that should be implemented in child classes, including access\nto the robot's model, data, and control mechanisms.</p>\n", "bases": "robots.base_robot.BaseRobot"}, {"fullname": "robots.shadow_hand.ShadowHand.ShadowFinger.__init__", "modulename": "robots.shadow_hand", "qualname": "ShadowHand.ShadowFinger.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">sh</span><span class=\"p\">:</span> <span class=\"n\">robots</span><span class=\"o\">.</span><span class=\"n\">shadow_hand</span><span class=\"o\">.</span><span class=\"n\">ShadowHand</span>,</span><span class=\"param\">\t<span class=\"nb\">type</span><span class=\"p\">:</span> <span class=\"n\">robots</span><span class=\"o\">.</span><span class=\"n\">shadow_hand</span><span class=\"o\">.</span><span class=\"n\">ShadowHand</span><span class=\"o\">.</span><span class=\"n\">ShadowFinger</span><span class=\"o\">.</span><span class=\"n\">FingerType</span></span>)</span>"}, {"fullname": "robots.shadow_hand.ShadowHand.ShadowFinger.FingerType", "modulename": "robots.shadow_hand", "qualname": "ShadowHand.ShadowFinger.FingerType", "kind": "class", "doc": "<p></p>\n", "bases": "enum.Enum"}, {"fullname": "robots.shadow_hand.ShadowHand.ShadowFinger.FingerType.FF", "modulename": "robots.shadow_hand", "qualname": "ShadowHand.ShadowFinger.FingerType.FF", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;FingerType.FF: &#x27;FF&#x27;&gt;"}, {"fullname": "robots.shadow_hand.ShadowHand.ShadowFinger.FingerType.MF", "modulename": "robots.shadow_hand", "qualname": "ShadowHand.ShadowFinger.FingerType.MF", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;FingerType.MF: &#x27;MF&#x27;&gt;"}, {"fullname": "robots.shadow_hand.ShadowHand.ShadowFinger.FingerType.RF", "modulename": "robots.shadow_hand", "qualname": "ShadowHand.ShadowFinger.FingerType.RF", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;FingerType.RF: &#x27;RF&#x27;&gt;"}, {"fullname": "robots.shadow_hand.ShadowHand.ShadowFinger.FingerType.LF", "modulename": "robots.shadow_hand", "qualname": "ShadowHand.ShadowFinger.FingerType.LF", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;FingerType.LF: &#x27;LF&#x27;&gt;"}, {"fullname": "robots.shadow_hand.ShadowHand.ShadowFinger.FingerType.TH", "modulename": "robots.shadow_hand", "qualname": "ShadowHand.ShadowFinger.FingerType.TH", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;FingerType.TH: &#x27;TH&#x27;&gt;"}, {"fullname": "robots.shadow_hand.ShadowHand.ShadowFinger.J", "modulename": "robots.shadow_hand", "qualname": "ShadowHand.ShadowFinger.J", "kind": "variable", "doc": "<p>Get the full Jacobian in base frame.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<pre><code>    Full Jacobian as a numpy array.\n</code></pre>\n", "annotation": ": numpy.ndarray"}, {"fullname": "robots.shadow_hand.ShadowHand.ShadowFinger.data", "modulename": "robots.shadow_hand", "qualname": "ShadowHand.ShadowFinger.data", "kind": "variable", "doc": "<p>Access the current simulation data.</p>\n\n<p>This property provides access to an instance of the <code>MjData</code> class, which contains the dynamic\nsimulation state. This includes quantities such as joint positions, velocities,\nactuator forces, and sensory information. The <code>MjData</code> object is updated at each simulation step\nand can be used to inspect the real-time state of the robot during the simulation.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>mj.MjData\n    An object representing the current dynamic state of the simulation.</p>\n", "annotation": ": mujoco._structs.MjData"}, {"fullname": "robots.shadow_hand.ShadowHand.ShadowFinger.model", "modulename": "robots.shadow_hand", "qualname": "ShadowHand.ShadowFinger.model", "kind": "variable", "doc": "<p>Access the model of the MuJoCo simulation.</p>\n\n<p>This property returns an instance of the <code>MjModel</code> class, which describes the physical and\nmechanical properties of the simulation. The <code>MjModel</code> object contains static information about the\nrobot such as its kinematic tree, inertial properties, joint and actuator definitions, and geometry\nconfigurations. It is used to define the robot's structure and behavior within the simulation.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>mj.MjModel\n    An object representing the static model of the robot and overall MuJoCo simulation.</p>\n", "annotation": ": mujoco._structs.MjModel"}, {"fullname": "robots.shadow_hand.ShadowHand.ShadowFinger.info", "modulename": "robots.shadow_hand", "qualname": "ShadowHand.ShadowFinger.info", "kind": "variable", "doc": "<p>Get detailed information about the robot.</p>\n\n<p>This property returns an instance of the <code>RobotInfo</code> class, which provides comprehensive\ndetails about the robot's structure and components. This includes information on the robot's\nbodies, joints, actuators, and geometries, among other attributes. The <code>RobotInfo</code> instance\ncan be used to access various properties such as the number of joints, actuator limits, joint\nlimits, and more.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>RobotInfo\n    An object containing detailed information about the robot's configuration and components.</p>\n", "annotation": ": utils.mj.RobotInfo"}, {"fullname": "robots.shadow_hand.ShadowHand.ShadowFinger.name", "modulename": "robots.shadow_hand", "qualname": "ShadowHand.ShadowFinger.name", "kind": "variable", "doc": "<p>Get the name of the robot.</p>\n\n<p>This property returns the name of the robot as a string. The name is typically a unique identifier\nused to distinguish between different robots in the simulation environment.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>str\n    The name of the robot as a string.</p>\n", "annotation": ": str"}, {"fullname": "robots.shadow_hand.ShadowHand.ShadowFinger.step", "modulename": "robots.shadow_hand", "qualname": "ShadowHand.ShadowFinger.step", "kind": "variable", "doc": "<p>Perform a step in the controller.</p>\n\n<p>This method calls the <code>step()</code> method of the controller object and\nbefore doing so it checks if there are any tasks to be performed in\nthe robot task queue</p>\n", "annotation": ": None"}, {"fullname": "robots.shadow_hand.ShadowHand.ShadowFinger.set_ctrl", "modulename": "robots.shadow_hand", "qualname": "ShadowHand.ShadowFinger.set_ctrl", "kind": "function", "doc": "<p>This function sends the control signal to the simulated robot.</p>\n\n<h2 id=\"args\">Args</h2>\n\n<pre><code>    x (Union[list, np.ndarray]): control signal\n</code></pre>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">x</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">List</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">ss</span><span class=\"p\">:</span> <span class=\"n\">sims</span><span class=\"o\">.</span><span class=\"n\">base_sim</span><span class=\"o\">.</span><span class=\"n\">SimSync</span>,</span><span class=\"param\">\t<span class=\"n\">time</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">5.0</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "robots.shadow_hand.ShadowHand.ff", "modulename": "robots.shadow_hand", "qualname": "ShadowHand.ff", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "robots.shadow_hand.ShadowHand.mf", "modulename": "robots.shadow_hand", "qualname": "ShadowHand.mf", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "robots.shadow_hand.ShadowHand.rf", "modulename": "robots.shadow_hand", "qualname": "ShadowHand.rf", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "robots.shadow_hand.ShadowHand.lf", "modulename": "robots.shadow_hand", "qualname": "ShadowHand.lf", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "robots.shadow_hand.ShadowHand.th", "modulename": "robots.shadow_hand", "qualname": "ShadowHand.th", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "robots.shadow_hand.ShadowHand.data", "modulename": "robots.shadow_hand", "qualname": "ShadowHand.data", "kind": "variable", "doc": "<p>Access the current simulation data.</p>\n\n<p>This property provides access to an instance of the <code>MjData</code> class, which contains the dynamic\nsimulation state. This includes quantities such as joint positions, velocities,\nactuator forces, and sensory information. The <code>MjData</code> object is updated at each simulation step\nand can be used to inspect the real-time state of the robot during the simulation.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>mj.MjData\n    An object representing the current dynamic state of the simulation.</p>\n", "annotation": ": mujoco._structs.MjData"}, {"fullname": "robots.shadow_hand.ShadowHand.model", "modulename": "robots.shadow_hand", "qualname": "ShadowHand.model", "kind": "variable", "doc": "<p>Access the model of the MuJoCo simulation.</p>\n\n<p>This property returns an instance of the <code>MjModel</code> class, which describes the physical and\nmechanical properties of the simulation. The <code>MjModel</code> object contains static information about the\nrobot such as its kinematic tree, inertial properties, joint and actuator definitions, and geometry\nconfigurations. It is used to define the robot's structure and behavior within the simulation.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>mj.MjModel\n    An object representing the static model of the robot and overall MuJoCo simulation.</p>\n", "annotation": ": mujoco._structs.MjModel"}, {"fullname": "robots.shadow_hand.ShadowHand.name", "modulename": "robots.shadow_hand", "qualname": "ShadowHand.name", "kind": "variable", "doc": "<p>Get the name of the robot.</p>\n\n<p>This property returns the name of the robot as a string. The name is typically a unique identifier\nused to distinguish between different robots in the simulation environment.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>str\n    The name of the robot as a string.</p>\n", "annotation": ": str"}, {"fullname": "robots.shadow_hand.ShadowHand.info", "modulename": "robots.shadow_hand", "qualname": "ShadowHand.info", "kind": "variable", "doc": "<p>Get detailed information about the robot.</p>\n\n<p>This property returns an instance of the <code>RobotInfo</code> class, which provides comprehensive\ndetails about the robot's structure and components. This includes information on the robot's\nbodies, joints, actuators, and geometries, among other attributes. The <code>RobotInfo</code> instance\ncan be used to access various properties such as the number of joints, actuator limits, joint\nlimits, and more.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>RobotInfo\n    An object containing detailed information about the robot's configuration and components.</p>\n", "annotation": ": utils.mj.RobotInfo"}, {"fullname": "robots.shadow_hand.ShadowHand.step", "modulename": "robots.shadow_hand", "qualname": "ShadowHand.step", "kind": "function", "doc": "<p>Perform a step in the controller.</p>\n\n<p>This method calls the <code>step()</code> method of the controller object and\nbefore doing so it checks if there are any tasks to be performed in\nthe robot task queue</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "robots.twof85", "modulename": "robots.twof85", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "robots.twof85.Twof85", "modulename": "robots.twof85", "qualname": "Twof85", "kind": "class", "doc": "<p>Base class for robot simulation in MuJoCo.</p>\n\n<p>This class provides a framework for simulating robots in MuJoCo environments. It defines\nkey properties and methods that should be implemented in child classes, including access\nto the robot's model, data, and control mechanisms.</p>\n", "bases": "robots.base_robot.BaseRobot"}, {"fullname": "robots.twof85.Twof85.__init__", "modulename": "robots.twof85", "qualname": "Twof85.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">model</span><span class=\"p\">:</span> <span class=\"n\">mujoco</span><span class=\"o\">.</span><span class=\"n\">_structs</span><span class=\"o\">.</span><span class=\"n\">MjModel</span>,</span><span class=\"param\">\t<span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"n\">mujoco</span><span class=\"o\">.</span><span class=\"n\">_structs</span><span class=\"o\">.</span><span class=\"n\">MjData</span>,</span><span class=\"param\">\t<span class=\"n\">args</span><span class=\"o\">=</span><span class=\"kc\">None</span></span>)</span>"}, {"fullname": "robots.twof85.Twof85.tcp_name", "modulename": "robots.twof85", "qualname": "Twof85.tcp_name", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "robots.twof85.Twof85.step", "modulename": "robots.twof85", "qualname": "Twof85.step", "kind": "function", "doc": "<p>Perform a step in the controller.</p>\n\n<p>This method calls the <code>step()</code> method of the controller object and\nbefore doing so it checks if there are any tasks to be performed in\nthe robot task queue</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "robots.twof85.Twof85.info", "modulename": "robots.twof85", "qualname": "Twof85.info", "kind": "variable", "doc": "<p>Get detailed information about the robot.</p>\n\n<p>This property returns an instance of the <code>RobotInfo</code> class, which provides comprehensive\ndetails about the robot's structure and components. This includes information on the robot's\nbodies, joints, actuators, and geometries, among other attributes. The <code>RobotInfo</code> instance\ncan be used to access various properties such as the number of joints, actuator limits, joint\nlimits, and more.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>RobotInfo\n    An object containing detailed information about the robot's configuration and components.</p>\n", "annotation": ": utils.mj.RobotInfo"}, {"fullname": "robots.twof85.Twof85.data", "modulename": "robots.twof85", "qualname": "Twof85.data", "kind": "variable", "doc": "<p>Get the MuJoCo data object.</p>\n\n<p>This property returns the MuJoCo data object associated with the robot. The <code>mj.MjData</code>\nobject contains the dynamic state of the simulation, including positions, velocities, forces,\nand other simulation-specific data for the robot.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>mj.MjData\n    The MuJoCo data object containing the dynamic state of the simulation.</p>\n", "annotation": ": mujoco._structs.MjData"}, {"fullname": "robots.twof85.Twof85.model", "modulename": "robots.twof85", "qualname": "Twof85.model", "kind": "variable", "doc": "<p>Get the MuJoCo model object.</p>\n\n<p>This property returns the MuJoCo model object associated with the robot. The <code>mj.MjModel</code>\nobject represents the static model of the simulation, including the robot's physical\nstructure, joint configurations, and other model-specific parameters.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>mj.MjModel\n    The MuJoCo model object representing the robot's static configuration.</p>\n", "annotation": ": mujoco._structs.MjModel"}, {"fullname": "robots.twof85.Twof85.name", "modulename": "robots.twof85", "qualname": "Twof85.name", "kind": "variable", "doc": "<p>Get the name of the robot.</p>\n\n<p>This property returns the name of the robot as a string. The name is typically a unique identifier\nused to distinguish between different robots in the simulation environment.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>str\n    The name of the robot as a string.</p>\n", "annotation": ": str"}, {"fullname": "robots.twof85.Twof85.get_ee_pose", "modulename": "robots.twof85", "qualname": "Twof85.get_ee_pose", "kind": "function", "doc": "<p>Get the end-effector pose.</p>\n\n<p>This method retrieves the pose of the robot's end-effector, specifically the TCP (Tool Center\nPoint). The pose is returned as an instance of <code>sm.SE3</code>, representing the position and\norientation of the end-effector in 3D space.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>sm.SE3\n    The pose of the robot's end-effector (TCP) in 3D space.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">spatialmath</span><span class=\"o\">.</span><span class=\"n\">pose3d</span><span class=\"o\">.</span><span class=\"n\">SE3</span>:</span></span>", "funcdef": "def"}, {"fullname": "robots.ur_robot", "modulename": "robots.ur_robot", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "robots.ur_robot.URRobot", "modulename": "robots.ur_robot", "qualname": "URRobot", "kind": "class", "doc": "<p>Base class for robot simulation in MuJoCo.</p>\n\n<p>This class provides a framework for simulating robots in MuJoCo environments. It defines\nkey properties and methods that should be implemented in child classes, including access\nto the robot's model, data, and control mechanisms.</p>\n", "bases": "robots.base_robot.BaseRobot"}, {"fullname": "robots.ur_robot.URRobot.__init__", "modulename": "robots.ur_robot", "qualname": "URRobot.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">model</span><span class=\"p\">:</span> <span class=\"n\">mujoco</span><span class=\"o\">.</span><span class=\"n\">_structs</span><span class=\"o\">.</span><span class=\"n\">MjModel</span>,</span><span class=\"param\">\t<span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"n\">mujoco</span><span class=\"o\">.</span><span class=\"n\">_structs</span><span class=\"o\">.</span><span class=\"n\">MjData</span>,</span><span class=\"param\">\t<span class=\"n\">robot_type</span><span class=\"p\">:</span> <span class=\"n\">robots</span><span class=\"o\">.</span><span class=\"n\">ur_robot</span><span class=\"o\">.</span><span class=\"n\">URRobot</span><span class=\"o\">.</span><span class=\"n\">Type</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">Type</span><span class=\"o\">.</span><span class=\"n\">UR5e</span><span class=\"p\">:</span> <span class=\"s1\">&#39;ur5e&#39;</span><span class=\"o\">&gt;</span></span>)</span>"}, {"fullname": "robots.ur_robot.URRobot.Type", "modulename": "robots.ur_robot", "qualname": "URRobot.Type", "kind": "class", "doc": "<p></p>\n", "bases": "enum.Enum"}, {"fullname": "robots.ur_robot.URRobot.Type.UR3e", "modulename": "robots.ur_robot", "qualname": "URRobot.Type.UR3e", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;Type.UR3e: &#x27;ur3e&#x27;&gt;"}, {"fullname": "robots.ur_robot.URRobot.Type.UR5e", "modulename": "robots.ur_robot", "qualname": "URRobot.Type.UR5e", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;Type.UR5e: &#x27;ur5e&#x27;&gt;"}, {"fullname": "robots.ur_robot.URRobot.Type.UR10e", "modulename": "robots.ur_robot", "qualname": "URRobot.Type.UR10e", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;Type.UR10e: &#x27;ur10e&#x27;&gt;"}, {"fullname": "robots.ur_robot.URRobot.dt", "modulename": "robots.ur_robot", "qualname": "URRobot.dt", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "robots.ur_robot.URRobot.home_qpos", "modulename": "robots.ur_robot", "qualname": "URRobot.home_qpos", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "robots.ur_robot.URRobot.tcp_id", "modulename": "robots.ur_robot", "qualname": "URRobot.tcp_id", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "robots.ur_robot.URRobot.step", "modulename": "robots.ur_robot", "qualname": "URRobot.step", "kind": "function", "doc": "<p>Perform a step in the controller.</p>\n\n<p>This method calls the <code>step()</code> method of the controller object and\nbefore doing so it checks if there are any tasks to be performed in\nthe robot task queue (URRobot._task_queue)</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "robots.ur_robot.URRobot.controller", "modulename": "robots.ur_robot", "qualname": "URRobot.controller", "kind": "variable", "doc": "<p></p>\n", "annotation": ": Optional[ctrl.base_ctrl.BaseController]"}, {"fullname": "robots.ur_robot.URRobot.info", "modulename": "robots.ur_robot", "qualname": "URRobot.info", "kind": "variable", "doc": "<p>Get detailed information about the robot.</p>\n\n<p>This property returns an instance of the <code>RobotInfo</code> class, which provides comprehensive\ndetails about the robot's structure and components. This includes information on the robot's\nbodies, joints, actuators, and geometries, among other attributes. The <code>RobotInfo</code> instance\ncan be used to access various properties such as the number of joints, actuator limits, joint\nlimits, and more.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>RobotInfo\n    An object containing detailed information about the robot's configuration and components.</p>\n", "annotation": ": utils.mj.RobotInfo"}, {"fullname": "robots.ur_robot.URRobot.data", "modulename": "robots.ur_robot", "qualname": "URRobot.data", "kind": "variable", "doc": "<p>Access the current simulation data.</p>\n\n<p>This property provides access to an instance of the <code>MjData</code> class, which contains the dynamic\nsimulation state. This includes quantities such as joint positions, velocities,\nactuator forces, and sensory information. The <code>MjData</code> object is updated at each simulation step\nand can be used to inspect the real-time state of the robot during the simulation.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>mj.MjData\n    An object representing the current dynamic state of the simulation.</p>\n", "annotation": ": mujoco._structs.MjData"}, {"fullname": "robots.ur_robot.URRobot.model", "modulename": "robots.ur_robot", "qualname": "URRobot.model", "kind": "variable", "doc": "<p>Access the model of the MuJoCo simulation.</p>\n\n<p>This property returns an instance of the <code>MjModel</code> class, which describes the physical and\nmechanical properties of the simulation. The <code>MjModel</code> object contains static information about the\nrobot such as its kinematic tree, inertial properties, joint and actuator definitions, and geometry\nconfigurations. It is used to define the robot's structure and behavior within the simulation.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>mj.MjModel\n    An object representing the static model of the robot and overall MuJoCo simulation.</p>\n", "annotation": ": mujoco._structs.MjModel"}, {"fullname": "robots.ur_robot.URRobot.name", "modulename": "robots.ur_robot", "qualname": "URRobot.name", "kind": "variable", "doc": "<p>Get the name of the robot.</p>\n\n<p>This property returns the name of the robot as a string. The name is typically a unique identifier\nused to distinguish between different robots in the simulation environment.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>str\n    The name of the robot as a string.</p>\n", "annotation": ": str"}, {"fullname": "robots.ur_robot.URRobot.type", "modulename": "robots.ur_robot", "qualname": "URRobot.type", "kind": "variable", "doc": "<p>Get the type of the UR robot.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<pre><code>    Type of the UR robot.\n</code></pre>\n", "annotation": ": str"}, {"fullname": "robots.ur_robot.URRobot.actuator_values", "modulename": "robots.ur_robot", "qualname": "URRobot.actuator_values", "kind": "variable", "doc": "<p>Get the values of the actuators.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<pre><code>    List of actuator values.\n</code></pre>\n", "annotation": ": List[float]"}, {"fullname": "robots.ur_robot.URRobot.w", "modulename": "robots.ur_robot", "qualname": "URRobot.w", "kind": "variable", "doc": "<p>Get the sensor wrench (force,torque) data from the force and toque sensor.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<pre><code>    np.ndarray: The sensor data as a NumPy array.\n</code></pre>\n", "annotation": ": numpy.ndarray"}, {"fullname": "robots.ur_robot.URRobot.fk", "modulename": "robots.ur_robot", "qualname": "URRobot.fk", "kind": "function", "doc": "<p>Compute the forward kinematics of the UR robot given joint positions.</p>\n\n<h2 id=\"args\">Args</h2>\n\n<pre><code>    q (Union[list, np.ndarray]): Joint positions.\n</code></pre>\n\n<h2 id=\"returns\">Returns</h2>\n\n<pre><code>    sm.SE3: The pose of the end-effector in the base frame.\n</code></pre>\n\n<p>Raises:\n        ValueError: If the length of <code>q</code> does not match the number of actuators.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">q</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">list</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">spatialmath</span><span class=\"o\">.</span><span class=\"n\">pose3d</span><span class=\"o\">.</span><span class=\"n\">SE3</span>:</span></span>", "funcdef": "def"}, {"fullname": "robots.ur_robot.URRobot.ik", "modulename": "robots.ur_robot", "qualname": "URRobot.ik", "kind": "function", "doc": "<p>Compute the inverse kinematics for the given target pose.</p>\n\n<p>This function calculates the joint angles required to achieve the specified\nend-effector pose using inverse kinematics. It uses an analytic Jacobian\nand residual function to iteratively solve for the joint angles that minimize\nthe difference between the current end-effector pose and the target pose.</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p>T : sm.SE3\n    The target pose for the end-effector, represented as a transformation matrix.\niter : int\n    Maximum number of iterations for the solver.\nepsilon : float\n    Convergence threshold for the distance measure.</p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>Tuple[np.ndarray, bool]\n    The joint angles that achieve the target pose and a boolean indicating if the pose was reachable.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">T</span><span class=\"p\">:</span> <span class=\"n\">spatialmath</span><span class=\"o\">.</span><span class=\"n\">pose3d</span><span class=\"o\">.</span><span class=\"n\">SE3</span>,</span><span class=\"param\">\t<span class=\"nb\">iter</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">10</span>,</span><span class=\"param\">\t<span class=\"n\">iter_interpolation</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">3</span>,</span><span class=\"param\">\t<span class=\"n\">epsilon</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">1e-06</span>,</span><span class=\"param\">\t<span class=\"n\">radius</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.4</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"nb\">bool</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "robots.ur_robot.URRobot.get_ee_pose", "modulename": "robots.ur_robot", "qualname": "URRobot.get_ee_pose", "kind": "function", "doc": "<p>Get the end-effector pose for the UR robot.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<pre><code>    T (sm.SE3): The end-effector pose in the base frame.\n</code></pre>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">spatialmath</span><span class=\"o\">.</span><span class=\"n\">pose3d</span><span class=\"o\">.</span><span class=\"n\">SE3</span>:</span></span>", "funcdef": "def"}, {"fullname": "robots.ur_robot.URRobot.set_ee_pose", "modulename": "robots.ur_robot", "qualname": "URRobot.set_ee_pose", "kind": "function", "doc": "<p>Set the desired end-effector pose for the UR robot.</p>\n\n<h2 id=\"args\">Args</h2>\n\n<pre><code>    T (sm.SE3): The desired end-effector pose in the base frame.\n</code></pre>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">T</span><span class=\"p\">:</span> <span class=\"n\">spatialmath</span><span class=\"o\">.</span><span class=\"n\">pose3d</span><span class=\"o\">.</span><span class=\"n\">SE3</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "robots.ur_robot.URRobot.move_l", "modulename": "robots.ur_robot", "qualname": "URRobot.move_l", "kind": "function", "doc": "<p>Move to a given position in task-space (or cartesian space)</p>\n\n<p>The robot guides the TCP at a defined velocity along a straight path to the end point defined by T.</p>\n\n<p>Args:\n        T (sm.SE3): The desired end-effector pose in the base frame.\n        velocity (Union[list, np.ndarray]): tool velocity [m/s]\n        acceleration (Union[list, np.ndarray]): tool acceleration [m/s^2]</p>\n\n<p>Returns:\n        success (bool): True if the move succeeds and False otherwise.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">T</span><span class=\"p\">:</span> <span class=\"n\">spatialmath</span><span class=\"o\">.</span><span class=\"n\">pose3d</span><span class=\"o\">.</span><span class=\"n\">SE3</span>,</span><span class=\"param\">\t<span class=\"n\">ss</span><span class=\"p\">:</span> <span class=\"n\">sims</span><span class=\"o\">.</span><span class=\"n\">base_sim</span><span class=\"o\">.</span><span class=\"n\">SimSync</span>,</span><span class=\"param\">\t<span class=\"n\">velocity</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">list</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mf\">0.25</span>,</span><span class=\"param\">\t<span class=\"n\">acceleration</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">list</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mf\">1.2</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "robots.ur_robot.URRobot.move_j", "modulename": "robots.ur_robot", "qualname": "URRobot.move_j", "kind": "function", "doc": "<p>Move to a given joint position in joint-space.</p>\n\n<p>The robot moves the joints to achieve the fastest path to the end point. The fastest\npath is generally not the shortest path and is thus not a straight line. As the\nmotions of the robot axes are rotational, curved paths can be executed faster than\nstraight paths. The exact path of the motion cannot be predicted.</p>\n\n<p>Args:\n        q (Union[list, np.ndarray]): q specifies joint positions of the robot axes [radians].\n        velocity (Union[list, np.ndarray]): joint velocity [rad/s]\n        acceleration (Union[list, np.ndarray]): joint acceleration [rad/s^2]</p>\n\n<p>Returns:\n        success (bool): True if the move succeeds and False otherwise.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">q</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">list</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">ss</span><span class=\"p\">:</span> <span class=\"n\">sims</span><span class=\"o\">.</span><span class=\"n\">base_sim</span><span class=\"o\">.</span><span class=\"n\">SimSync</span>,</span><span class=\"param\">\t<span class=\"n\">velocity</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">list</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mf\">1.05</span>,</span><span class=\"param\">\t<span class=\"n\">acceleration</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">list</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mf\">1.4</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "robots.ur_robot.URRobot.move_traj", "modulename": "robots.ur_robot", "qualname": "URRobot.move_traj", "kind": "function", "doc": "<p>Move the robot along a given trajectory.</p>\n\n<p>This function enqueues a series of task poses for the robot to follow sequentially.</p>\n\n<h2 id=\"args\">Args</h2>\n\n<pre><code>    T (Union[sm.SE3, List]): List of desired end-effector poses in the base frame.\n</code></pre>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">T</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">spatialmath</span><span class=\"o\">.</span><span class=\"n\">pose3d</span><span class=\"o\">.</span><span class=\"n\">SE3</span><span class=\"p\">,</span> <span class=\"n\">List</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">ss</span><span class=\"p\">:</span> <span class=\"n\">sims</span><span class=\"o\">.</span><span class=\"n\">base_sim</span><span class=\"o\">.</span><span class=\"n\">SimSync</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "utils.mj", "modulename": "utils.mj", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "utils.mj.JointType", "modulename": "utils.mj", "qualname": "JointType", "kind": "class", "doc": "<p>Enumeration of joint types used in MuJoCo simulations.</p>\n\n<p>This class defines the types of joints that can be used in a MuJoCo simulation,\nincluding free, ball, slide, and hinge joints. These joint types are associated\nwith integer values that are used within the MuJoCo framework to specify the type\nof joint for different elements of the model.</p>\n\n<h2 id=\"attributes\">Attributes</h2>\n\n<p>FREE : int\n    A joint that allows for unrestricted movement in all translational and rotational\n    degrees of freedom. Represented by the integer value 0.\nBALL : int\n    A ball-and-socket joint that allows rotation in all directions, but no translational\n    movement. Represented by the integer value 1.\nSLIDE : int\n    A prismatic joint that allows translational movement along a single axis, with no\n    rotational freedom. Represented by the integer value 2.\nHINGE : int\n    A rotational joint that allows rotation around a single axis, similar to a door hinge.\n    Represented by the integer value 3.</p>\n", "bases": "enum.Enum"}, {"fullname": "utils.mj.JointType.FREE", "modulename": "utils.mj", "qualname": "JointType.FREE", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;JointType.FREE: 0&gt;"}, {"fullname": "utils.mj.JointType.BALL", "modulename": "utils.mj", "qualname": "JointType.BALL", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;JointType.BALL: 1&gt;"}, {"fullname": "utils.mj.JointType.SLIDE", "modulename": "utils.mj", "qualname": "JointType.SLIDE", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;JointType.SLIDE: 2&gt;"}, {"fullname": "utils.mj.JointType.HINGE", "modulename": "utils.mj", "qualname": "JointType.HINGE", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;JointType.HINGE: 3&gt;"}, {"fullname": "utils.mj.ObjType", "modulename": "utils.mj", "qualname": "ObjType", "kind": "class", "doc": "<p>Enumeration of object types used in MuJoCo simulations.</p>\n\n<p>This class defines various object types that can be used in a MuJoCo simulation,\nincluding bodies, joints, geoms, sites, actuators, and sensors. These object types\nare associated with integer values that are used within the MuJoCo framework to\nspecify the type of object for different elements of the model.</p>\n\n<h2 id=\"attributes\">Attributes</h2>\n\n<p>UNKNOWN : int\n    Represents an unknown object type. Used when the object type is not recognized.\n    Represented by the integer value 0.\nBODY : int\n    Represents a body in the simulation. Bodies are rigid objects that can be connected\n    by joints or other constraints. Represented by the integer value 1.\nXBODY : int\n    Represents a body but used to access the regular frame instead of the i-frame.\n    Represented by the integer value 2.\nJOINT : int\n    Represents a joint that connects two bodies and allows for relative movement.\n    Represented by the integer value 3.\nDOF : int\n    Represents a degree of freedom (DOF) of a joint, typically used to describe the\n    axes along which a joint can move or rotate. Represented by the integer value 4.\nGEOM : int\n    Represents a geometric shape associated with a body, used for collision detection\n    and visual rendering. Represented by the integer value 5.\nSITE : int\n    Represents a site, which is a fixed point or frame on a body used for specifying\n    positions or attaching sensors. Represented by the integer value 6.\nCAMERA : int\n    Represents a camera, which can be used to render views of the simulation environment.\n    Represented by the integer value 7.\nLIGHT : int\n    Represents a light source in the simulation environment. Represented by the integer\n    value 8.\nFLEX : int\n    Represents a flex object, typically used in simulations of flexible materials.\n    Represented by the integer value 9.\nMESH : int\n    Represents a mesh object, typically a more complex geometric shape defined by vertices\n    and faces. Represented by the integer value 10.\nSKIN : int\n    Represents a skin, usually used for rendering soft or flexible outer surfaces on bodies.\n    Represented by the integer value 11.\nHFIELD : int\n    Represents a heightfield, typically used to model uneven terrain or surfaces in the\n    simulation. Represented by the integer value 12.\nTEXTURE : int\n    Represents a texture, which can be applied to geometric shapes for visual realism.\n    Represented by the integer value 13.\nMATERIAL : int\n    Represents a material for rendering, which defines visual properties like color and\n    reflectiveness. Represented by the integer value 14.\nPAIR : int\n    Represents a geom pair to include in the simulation for collision detection.\n    Represented by the integer value 15.\nEXCLUDE : int\n    Represents a body pair to exclude from collision detection. Represented by the integer\n    value 16.\nEQUALITY : int\n    Represents an equality constraint, used to enforce specific relationships between\n    different elements in the simulation. Represented by the integer value 17.\nTENDON : int\n    Represents a tendon, typically used to model soft structures or actuators in biological\n    systems. Represented by the integer value 18.\nACTUATOR : int\n    Represents an actuator, which generates forces or torques to move bodies in the simulation.\n    Represented by the integer value 19.\nSENSOR : int\n    Represents a sensor, which is used to measure various aspects of the simulation such as\n    positions, velocities, or forces. Represented by the integer value 20.\nNUMERIC : int\n    Represents a numeric element, often used for user-defined values or parameters.\n    Represented by the integer value 21.\nTEXT : int\n    Represents a text element, used to store or display text in the simulation.\n    Represented by the integer value 22.\nTUPLE : int\n    Represents a tuple, often used to group multiple elements together.\n    Represented by the integer value 23.\nKEY : int\n    Represents a keyframe, used to save or restore the state of the simulation at specific\n    points in time. Represented by the integer value 24.\nPLUGIN : int\n    Represents a plugin instance, which can be used to extend the functionality of the\n    simulation with user-defined code. Represented by the integer value 25.</p>\n", "bases": "enum.Enum"}, {"fullname": "utils.mj.ObjType.UNKNOWN", "modulename": "utils.mj", "qualname": "ObjType.UNKNOWN", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;ObjType.UNKNOWN: 0&gt;"}, {"fullname": "utils.mj.ObjType.BODY", "modulename": "utils.mj", "qualname": "ObjType.BODY", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;ObjType.BODY: 1&gt;"}, {"fullname": "utils.mj.ObjType.XBODY", "modulename": "utils.mj", "qualname": "ObjType.XBODY", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;ObjType.XBODY: 2&gt;"}, {"fullname": "utils.mj.ObjType.JOINT", "modulename": "utils.mj", "qualname": "ObjType.JOINT", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;ObjType.JOINT: 3&gt;"}, {"fullname": "utils.mj.ObjType.DOF", "modulename": "utils.mj", "qualname": "ObjType.DOF", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;ObjType.DOF: 4&gt;"}, {"fullname": "utils.mj.ObjType.GEOM", "modulename": "utils.mj", "qualname": "ObjType.GEOM", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;ObjType.GEOM: 5&gt;"}, {"fullname": "utils.mj.ObjType.SITE", "modulename": "utils.mj", "qualname": "ObjType.SITE", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;ObjType.SITE: 6&gt;"}, {"fullname": "utils.mj.ObjType.CAMERA", "modulename": "utils.mj", "qualname": "ObjType.CAMERA", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;ObjType.CAMERA: 7&gt;"}, {"fullname": "utils.mj.ObjType.LIGHT", "modulename": "utils.mj", "qualname": "ObjType.LIGHT", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;ObjType.LIGHT: 8&gt;"}, {"fullname": "utils.mj.ObjType.FLEX", "modulename": "utils.mj", "qualname": "ObjType.FLEX", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;ObjType.FLEX: 9&gt;"}, {"fullname": "utils.mj.ObjType.MESH", "modulename": "utils.mj", "qualname": "ObjType.MESH", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;ObjType.MESH: 10&gt;"}, {"fullname": "utils.mj.ObjType.SKIN", "modulename": "utils.mj", "qualname": "ObjType.SKIN", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;ObjType.SKIN: 11&gt;"}, {"fullname": "utils.mj.ObjType.HFIELD", "modulename": "utils.mj", "qualname": "ObjType.HFIELD", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;ObjType.HFIELD: 12&gt;"}, {"fullname": "utils.mj.ObjType.TEXTURE", "modulename": "utils.mj", "qualname": "ObjType.TEXTURE", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;ObjType.TEXTURE: 13&gt;"}, {"fullname": "utils.mj.ObjType.MATERIAL", "modulename": "utils.mj", "qualname": "ObjType.MATERIAL", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;ObjType.MATERIAL: 14&gt;"}, {"fullname": "utils.mj.ObjType.PAIR", "modulename": "utils.mj", "qualname": "ObjType.PAIR", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;ObjType.PAIR: 15&gt;"}, {"fullname": "utils.mj.ObjType.EXCLUDE", "modulename": "utils.mj", "qualname": "ObjType.EXCLUDE", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;ObjType.EXCLUDE: 16&gt;"}, {"fullname": "utils.mj.ObjType.EQUALITY", "modulename": "utils.mj", "qualname": "ObjType.EQUALITY", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;ObjType.EQUALITY: 17&gt;"}, {"fullname": "utils.mj.ObjType.TENDON", "modulename": "utils.mj", "qualname": "ObjType.TENDON", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;ObjType.TENDON: 18&gt;"}, {"fullname": "utils.mj.ObjType.ACTUATOR", "modulename": "utils.mj", "qualname": "ObjType.ACTUATOR", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;ObjType.ACTUATOR: 19&gt;"}, {"fullname": "utils.mj.ObjType.SENSOR", "modulename": "utils.mj", "qualname": "ObjType.SENSOR", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;ObjType.SENSOR: 20&gt;"}, {"fullname": "utils.mj.ObjType.NUMERIC", "modulename": "utils.mj", "qualname": "ObjType.NUMERIC", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;ObjType.NUMERIC: 21&gt;"}, {"fullname": "utils.mj.ObjType.TEXT", "modulename": "utils.mj", "qualname": "ObjType.TEXT", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;ObjType.TEXT: 22&gt;"}, {"fullname": "utils.mj.ObjType.TUPLE", "modulename": "utils.mj", "qualname": "ObjType.TUPLE", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;ObjType.TUPLE: 23&gt;"}, {"fullname": "utils.mj.ObjType.KEY", "modulename": "utils.mj", "qualname": "ObjType.KEY", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;ObjType.KEY: 24&gt;"}, {"fullname": "utils.mj.ObjType.PLUGIN", "modulename": "utils.mj", "qualname": "ObjType.PLUGIN", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;ObjType.PLUGIN: 25&gt;"}, {"fullname": "utils.mj.ObjType.NOOBJECT", "modulename": "utils.mj", "qualname": "ObjType.NOOBJECT", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;ObjType.NOOBJECT: 26&gt;"}, {"fullname": "utils.mj.ObjType.FRAME", "modulename": "utils.mj", "qualname": "ObjType.FRAME", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;ObjType.FRAME: 100&gt;"}, {"fullname": "utils.mj.get_number_of", "modulename": "utils.mj", "qualname": "get_number_of", "kind": "function", "doc": "<p>Retrieves the count of objects of a specified type in a MuJoCo model.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>model : mj.MjModel\n    The MuJoCo model from which to count objects.\nobj_type : ObjType\n    The type of objects to count, e.g., actuators, bodies, joints.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>int\n    The number of objects of the specified type in the model.</p>\n\n<h2 id=\"raises\">Raises</h2>\n\n<p>ValueError\n    If the specified object type is not recognized.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">model</span><span class=\"p\">:</span> <span class=\"n\">mujoco</span><span class=\"o\">.</span><span class=\"n\">_structs</span><span class=\"o\">.</span><span class=\"n\">MjModel</span>, </span><span class=\"param\"><span class=\"n\">obj_type</span><span class=\"p\">:</span> <span class=\"n\">utils</span><span class=\"o\">.</span><span class=\"n\">mj</span><span class=\"o\">.</span><span class=\"n\">ObjType</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span>:</span></span>", "funcdef": "def"}, {"fullname": "utils.mj.get_names", "modulename": "utils.mj", "qualname": "get_names", "kind": "function", "doc": "<p>Retrieves the names of all objects of a specified type in a MuJoCo model.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>model : mj.MjModel\n    The MuJoCo model containing the objects.\nobj_type : ObjType\n    The type of objects to retrieve names for, e.g., actuators, bodies.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>List[str]\n    A list of names for all objects of the specified type in the model.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">model</span><span class=\"p\">:</span> <span class=\"n\">mujoco</span><span class=\"o\">.</span><span class=\"n\">_structs</span><span class=\"o\">.</span><span class=\"n\">MjModel</span>, </span><span class=\"param\"><span class=\"n\">obj_type</span><span class=\"p\">:</span> <span class=\"n\">utils</span><span class=\"o\">.</span><span class=\"n\">mj</span><span class=\"o\">.</span><span class=\"n\">ObjType</span></span><span class=\"return-annotation\">) -> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "utils.mj.get_ids", "modulename": "utils.mj", "qualname": "get_ids", "kind": "function", "doc": "<p>Retrieves the IDs of all objects of a specified type in a MuJoCo model.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>model : mj.MjModel\n    The MuJoCo model containing the objects.\nobj_type : ObjType\n    The type of objects to retrieve IDs for.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>List[int]\n    A list of IDs for all objects of the specified type in the model.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">model</span><span class=\"p\">:</span> <span class=\"n\">mujoco</span><span class=\"o\">.</span><span class=\"n\">_structs</span><span class=\"o\">.</span><span class=\"n\">MjModel</span>, </span><span class=\"param\"><span class=\"n\">obj_type</span><span class=\"p\">:</span> <span class=\"n\">utils</span><span class=\"o\">.</span><span class=\"n\">mj</span><span class=\"o\">.</span><span class=\"n\">ObjType</span></span><span class=\"return-annotation\">) -> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "utils.mj.name2id", "modulename": "utils.mj", "qualname": "name2id", "kind": "function", "doc": "<p>Retrieves the ID of an object by its name and type in a MuJoCo model.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>model : mj.MjModel\n    The MuJoCo model containing the object.\nname : str\n    The name of the object.\nobj_type : ObjType\n    The type of the object, e.g., body, joint.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>int\n    The ID of the object if it exists.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">model</span><span class=\"p\">:</span> <span class=\"n\">mujoco</span><span class=\"o\">.</span><span class=\"n\">_structs</span><span class=\"o\">.</span><span class=\"n\">MjModel</span>,</span><span class=\"param\">\t<span class=\"n\">name</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">obj_type</span><span class=\"p\">:</span> <span class=\"n\">utils</span><span class=\"o\">.</span><span class=\"n\">mj</span><span class=\"o\">.</span><span class=\"n\">ObjType</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span>:</span></span>", "funcdef": "def"}, {"fullname": "utils.mj.id2name", "modulename": "utils.mj", "qualname": "id2name", "kind": "function", "doc": "<p>Retrieves the name of an object by its ID and type in a MuJoCo model.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>model : mj.MjModel\n    The MuJoCo model containing the object.\nid : int\n    The ID of the object.\nobj_type : ObjType\n    The type of the object, e.g., actuator, site.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>str\n    The name of the object if it exists.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">model</span><span class=\"p\">:</span> <span class=\"n\">mujoco</span><span class=\"o\">.</span><span class=\"n\">_structs</span><span class=\"o\">.</span><span class=\"n\">MjModel</span>,</span><span class=\"param\">\t<span class=\"nb\">id</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">obj_type</span><span class=\"p\">:</span> <span class=\"n\">utils</span><span class=\"o\">.</span><span class=\"n\">mj</span><span class=\"o\">.</span><span class=\"n\">ObjType</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">str</span>:</span></span>", "funcdef": "def"}, {"fullname": "utils.mj.does_exist", "modulename": "utils.mj", "qualname": "does_exist", "kind": "function", "doc": "<p>Checks if an object with a given name or ID exists in a MuJoCo model.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>model : mj.MjModel\n    The MuJoCo model to check within.\nidentifier : int or str\n    The ID or name of the object.\nobj_type : ObjType\n    The type of the object, e.g., geom, sensor.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>bool\n    True if the object exists, False otherwise.</p>\n\n<h2 id=\"raises\">Raises</h2>\n\n<p>ValueError\n    If the object type is unrecognized or if the specified identifier type is invalid.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">model</span><span class=\"p\">:</span> <span class=\"n\">mujoco</span><span class=\"o\">.</span><span class=\"n\">_structs</span><span class=\"o\">.</span><span class=\"n\">MjModel</span>,</span><span class=\"param\">\t<span class=\"n\">identifier</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">obj_type</span><span class=\"p\">:</span> <span class=\"n\">utils</span><span class=\"o\">.</span><span class=\"n\">mj</span><span class=\"o\">.</span><span class=\"n\">ObjType</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "utils.mj.get_pose", "modulename": "utils.mj", "qualname": "get_pose", "kind": "function", "doc": "<p>Retrieves the pose (position and orientation) of an object in a MuJoCo model.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>model : mj.MjModel\n    The MuJoCo model containing the object.\ndata : mj.MjData\n    The simulation data containing the pose information.\nidentifier : int or str\n    The ID or name of the object.\nobj_type : ObjType\n    The type of the object, e.g., body, site, camera.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>sm.SE3\n    The pose of the object as an SE3 transformation matrix.</p>\n\n<h2 id=\"raises\">Raises</h2>\n\n<p>ValueError\n    If the object type does not support pose retrieval.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">model</span><span class=\"p\">:</span> <span class=\"n\">mujoco</span><span class=\"o\">.</span><span class=\"n\">_structs</span><span class=\"o\">.</span><span class=\"n\">MjModel</span>,</span><span class=\"param\">\t<span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"n\">mujoco</span><span class=\"o\">.</span><span class=\"n\">_structs</span><span class=\"o\">.</span><span class=\"n\">MjData</span>,</span><span class=\"param\">\t<span class=\"n\">identifier</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">obj_type</span><span class=\"p\">:</span> <span class=\"n\">utils</span><span class=\"o\">.</span><span class=\"n\">mj</span><span class=\"o\">.</span><span class=\"n\">ObjType</span></span><span class=\"return-annotation\">) -> <span class=\"n\">spatialmath</span><span class=\"o\">.</span><span class=\"n\">pose3d</span><span class=\"o\">.</span><span class=\"n\">SE3</span>:</span></span>", "funcdef": "def"}, {"fullname": "utils.mj.set_pose", "modulename": "utils.mj", "qualname": "set_pose", "kind": "function", "doc": "<p>Sets the pose (position and orientation) of an object in a MuJoCo model, if allowed.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>model : mj.MjModel\n    The MuJoCo model containing the object.\ndata : mj.MjData\n    The simulation data where the pose is set.\nidentifier : int or str\n    The ID or name of the object.\nobj_type : ObjType\n    The type of the object, e.g., body, joint.\nT : sm.SE3\n    The desired pose as an SE3 transformation matrix.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">model</span><span class=\"p\">:</span> <span class=\"n\">mujoco</span><span class=\"o\">.</span><span class=\"n\">_structs</span><span class=\"o\">.</span><span class=\"n\">MjModel</span>,</span><span class=\"param\">\t<span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"n\">mujoco</span><span class=\"o\">.</span><span class=\"n\">_structs</span><span class=\"o\">.</span><span class=\"n\">MjData</span>,</span><span class=\"param\">\t<span class=\"n\">identifier</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">obj_type</span><span class=\"p\">:</span> <span class=\"n\">utils</span><span class=\"o\">.</span><span class=\"n\">mj</span><span class=\"o\">.</span><span class=\"n\">ObjType</span>,</span><span class=\"param\">\t<span class=\"n\">T</span><span class=\"p\">:</span> <span class=\"n\">spatialmath</span><span class=\"o\">.</span><span class=\"n\">pose3d</span><span class=\"o\">.</span><span class=\"n\">SE3</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "utils.mj.get_joint_qpos_addr", "modulename": "utils.mj", "qualname": "get_joint_qpos_addr", "kind": "function", "doc": "<p>Retrieves the address of the generalized position (qpos) for a specific joint in the MuJoCo model.</p>\n\n<p>This function returns the index of the joint's generalized position in the <code>qpos</code> array\nof the MuJoCo model. This index can be used to access or modify the joint's position\ndirectly in the simulation data.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>model : mj.MjModel\n    The MuJoCo model object from which to retrieve the joint's qpos address.\njoint_name : Union[int, str]\n    The name or ID of the joint whose qpos address is being retrieved. Can be specified\n    either as a string (name) or an integer (ID).</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>int\n    The address (index) of the joint's generalized position in the <code>qpos</code> array.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>Ensure that the specified <code>joint_name</code> corresponds to a valid joint in the MuJoCo model.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">model</span><span class=\"p\">:</span> <span class=\"n\">mujoco</span><span class=\"o\">.</span><span class=\"n\">_structs</span><span class=\"o\">.</span><span class=\"n\">MjModel</span>, </span><span class=\"param\"><span class=\"n\">joint_name</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span>:</span></span>", "funcdef": "def"}, {"fullname": "utils.mj.set_joint_q", "modulename": "utils.mj", "qualname": "set_joint_q", "kind": "function", "doc": "<p>Sets the position(s) (angle(s)) of a joint in the MuJoCo simulation.</p>\n\n<p>This function updates the generalized position (<code>qpos</code>) of a specified joint in\nthe MuJoCo simulation. The joint's position can be set in radians or degrees,\ndepending on the <code>unit</code> parameter. If degrees are provided, they will be converted\nto radians before being applied. The positions are assigned to the joint's indices\nin the <code>qpos</code> array of the simulation data.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>data : mj.MjData\n    The MuJoCo data object associated with the simulation.\nmodel : mj.MjModel\n    The MuJoCo model object containing the simulation model.\njoint_name : Union[int, str]\n    The name or ID of the joint whose position is being set.\nq : Union[np.ndarray, float]\n    The position(s) (angle(s)) to be set for the joint. Can be a single value or an array\n    of values, depending on the type of joint.\nunit : str, optional\n    The unit of the position value, either \"rad\" (radians) or \"deg\" (degrees). Defaults to \"rad\".</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>None</p>\n\n<h2 id=\"raises\">Raises</h2>\n\n<p>ValueError\n    If the dimensions of <code>q</code> do not match the number of positions for the specified joint.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<ul>\n<li>The <code>joint_name</code> can be specified as either a string (name) or an integer (ID).</li>\n<li>If the unit is \"deg\", the function will convert the angles from degrees to radians before applying.</li>\n<li>Ensure that the <code>q</code> values match the dimensions expected for the joint.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"n\">mujoco</span><span class=\"o\">.</span><span class=\"n\">_structs</span><span class=\"o\">.</span><span class=\"n\">MjData</span>,</span><span class=\"param\">\t<span class=\"n\">model</span><span class=\"p\">:</span> <span class=\"n\">mujoco</span><span class=\"o\">.</span><span class=\"n\">_structs</span><span class=\"o\">.</span><span class=\"n\">MjModel</span>,</span><span class=\"param\">\t<span class=\"n\">joint_name</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">q</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">unit</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;rad&#39;</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "utils.mj.set_joint_dq", "modulename": "utils.mj", "qualname": "set_joint_dq", "kind": "function", "doc": "<p>Sets the velocity of a joint in the MuJoCo simulation.</p>\n\n<p>This function updates the generalized velocity (<code>qvel</code>) of a specified joint\nin the MuJoCo simulation. The velocity can be specified in radians or degrees,\nand will be converted to radians if necessary. The velocities are assigned to the\njoint's degrees of freedom in the <code>qvel</code> array of the simulation data.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>data : mj.MjData\n    The MuJoCo data object associated with the simulation.\nmodel : mj.MjModel\n    The MuJoCo model object containing the simulation model.\njoint_name : Union[int, str]\n    The name or ID of the joint whose velocity is being set.\ndq : Union[np.ndarray, float]\n    The velocity value(s) to be set for the joint. This can be a single value or\n    an array of values, depending on the type of joint.\nunit : str, optional\n    The unit of the velocity value, either \"rad\" (radians) or \"deg\" (degrees). Defaults to \"rad\".</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>None</p>\n\n<h2 id=\"raises\">Raises</h2>\n\n<p>ValueError\n    If the dimensions of <code>dq</code> do not match the number of degrees of freedom for the specified joint.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<ul>\n<li>The <code>joint_name</code> can be specified as either a string (name) or an integer (ID).</li>\n<li>If the unit is \"deg\", the function will convert the velocities from degrees to radians before applying.</li>\n<li>Ensure that the <code>dq</code> values match the dimensions expected for the joint.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"n\">mujoco</span><span class=\"o\">.</span><span class=\"n\">_structs</span><span class=\"o\">.</span><span class=\"n\">MjData</span>,</span><span class=\"param\">\t<span class=\"n\">model</span><span class=\"p\">:</span> <span class=\"n\">mujoco</span><span class=\"o\">.</span><span class=\"n\">_structs</span><span class=\"o\">.</span><span class=\"n\">MjModel</span>,</span><span class=\"param\">\t<span class=\"n\">joint_name</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">dq</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">unit</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;rad&#39;</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "utils.mj.set_joint_ddq", "modulename": "utils.mj", "qualname": "set_joint_ddq", "kind": "function", "doc": "<p>Sets the acceleration of a joint in the MuJoCo simulation.</p>\n\n<p>This function updates the generalized acceleration (<code>qacc</code>) of a specified joint\nin the MuJoCo simulation. The acceleration can be specified in radians or degrees,\nand will be converted to radians if necessary. The accelerations are assigned to the\njoint's degrees of freedom in the <code>qacc</code> array of the simulation data.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>data : mj.MjData\n    The MuJoCo data object associated with the simulation.\nmodel : mj.MjModel\n    The MuJoCo model object containing the simulation model.\njoint_name : Union[int, str]\n    The name or ID of the joint whose acceleration is being set.\nddq : Union[np.ndarray, float]\n    The acceleration value(s) to be set for the joint. This can be a single value or\n    an array of values, depending on the type of joint.\nunit : str, optional\n    The unit of the acceleration value, either \"rad\" (radians) or \"deg\" (degrees). Defaults to \"rad\".</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>None</p>\n\n<h2 id=\"raises\">Raises</h2>\n\n<p>ValueError\n    If the dimensions of <code>ddq</code> do not match the number of degrees of freedom for the specified joint.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<ul>\n<li>The <code>joint_name</code> can be specified as either a string (name) or an integer (ID).</li>\n<li>If the unit is \"deg\", the function will convert the accelerations from degrees to radians before applying.</li>\n<li>Ensure that the <code>ddq</code> values match the dimensions expected for the joint.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"n\">mujoco</span><span class=\"o\">.</span><span class=\"n\">_structs</span><span class=\"o\">.</span><span class=\"n\">MjData</span>,</span><span class=\"param\">\t<span class=\"n\">model</span><span class=\"p\">:</span> <span class=\"n\">mujoco</span><span class=\"o\">.</span><span class=\"n\">_structs</span><span class=\"o\">.</span><span class=\"n\">MjModel</span>,</span><span class=\"param\">\t<span class=\"n\">joint_name</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">ddq</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">unit</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;rad&#39;</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "utils.mj.get_joint_q", "modulename": "utils.mj", "qualname": "get_joint_q", "kind": "function", "doc": "<p>Retrieves the position (angle) of a joint in the MuJoCo simulation.</p>\n\n<p>This function extracts the current position (or angle) of a specified joint\nfrom the MuJoCo simulation data. The joint position is obtained from the\n<code>qpos</code> array, which holds the generalized positions for all joints in the model.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>data : mj.MjData\n    The MuJoCo data object associated with the simulation.\nmodel : mj.MjModel\n    The MuJoCo model object containing the simulation model.\njoint_name : Union[int, str]\n    The name or ID of the joint whose position is being retrieved.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>np.ndarray\n    An array containing the position (or angle) of the specified joint.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<ul>\n<li>The <code>joint_name</code> can be specified as either a string (name) or an integer (ID).</li>\n<li>The returned array includes the position values corresponding to the joint's degrees of freedom.</li>\n<li>Ensure that the joint_name is valid and corresponds to an existing joint in the model.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"n\">mujoco</span><span class=\"o\">.</span><span class=\"n\">_structs</span><span class=\"o\">.</span><span class=\"n\">MjData</span>,</span><span class=\"param\">\t<span class=\"n\">model</span><span class=\"p\">:</span> <span class=\"n\">mujoco</span><span class=\"o\">.</span><span class=\"n\">_structs</span><span class=\"o\">.</span><span class=\"n\">MjModel</span>,</span><span class=\"param\">\t<span class=\"n\">joint_name</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "utils.mj.get_joint_dq", "modulename": "utils.mj", "qualname": "get_joint_dq", "kind": "function", "doc": "<p>Retrieves the velocity of a joint in the MuJoCo simulation.</p>\n\n<p>This function extracts the current velocity of a specified joint from the\nMuJoCo simulation data. The joint's velocity is obtained from the <code>qvel</code> array,\nwhich holds the generalized velocities for all joints in the model.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>data : mj.MjData\n    The MuJoCo data object associated with the simulation.\nmodel : mj.MjModel\n    The MuJoCo model object containing the simulation model.\njoint_name : Union[int, str]\n    The name or ID of the joint whose velocity is being retrieved.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>np.ndarray\n    An array containing the velocity values of the specified joint.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<ul>\n<li>The <code>joint_name</code> can be specified as either a string (name) or an integer (ID).</li>\n<li>The returned array includes the velocity values corresponding to the joint's degrees of freedom.</li>\n<li>Ensure that the <code>joint_name</code> is valid and corresponds to an existing joint in the model.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"n\">mujoco</span><span class=\"o\">.</span><span class=\"n\">_structs</span><span class=\"o\">.</span><span class=\"n\">MjData</span>,</span><span class=\"param\">\t<span class=\"n\">model</span><span class=\"p\">:</span> <span class=\"n\">mujoco</span><span class=\"o\">.</span><span class=\"n\">_structs</span><span class=\"o\">.</span><span class=\"n\">MjModel</span>,</span><span class=\"param\">\t<span class=\"n\">joint_name</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "utils.mj.get_joint_ddq", "modulename": "utils.mj", "qualname": "get_joint_ddq", "kind": "function", "doc": "<p>Retrieves the acceleration of a joint in the MuJoCo simulation.</p>\n\n<p>This function extracts the current acceleration of a specified joint from the\nMuJoCo simulation data. The joint's acceleration is obtained from the <code>qacc</code> array,\nwhich holds the generalized accelerations for all joints in the model.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>data : mj.MjData\n    The MuJoCo data object associated with the simulation.\nmodel : mj.MjModel\n    The MuJoCo model object containing the simulation model.\njoint_name : Union[int, str]\n    The name or ID of the joint whose acceleration is being retrieved.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>np.ndarray\n    An array containing the acceleration values of the specified joint.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<ul>\n<li>The <code>joint_name</code> can be specified as either a string (name) or an integer (ID).</li>\n<li>The returned array includes the acceleration values corresponding to the joint's degrees of freedom.</li>\n<li>Ensure that the <code>joint_name</code> is valid and corresponds to an existing joint in the model.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"n\">mujoco</span><span class=\"o\">.</span><span class=\"n\">_structs</span><span class=\"o\">.</span><span class=\"n\">MjData</span>,</span><span class=\"param\">\t<span class=\"n\">model</span><span class=\"p\">:</span> <span class=\"n\">mujoco</span><span class=\"o\">.</span><span class=\"n\">_structs</span><span class=\"o\">.</span><span class=\"n\">MjModel</span>,</span><span class=\"param\">\t<span class=\"n\">joint_name</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "utils.mj.get_joint_qpos_indxs", "modulename": "utils.mj", "qualname": "get_joint_qpos_indxs", "kind": "function", "doc": "<p>Retrieves the indices in the <code>qpos</code> array corresponding to the specified joint in the MuJoCo model.</p>\n\n<p>This function determines the indices in the <code>qpos</code> array where the position(s) of the specified joint are stored.\nThe indices are computed based on the joint's position address and its dimension.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>data : mj.MjData\n    The MuJoCo data object associated with the simulation.\nmodel : mj.MjModel\n    The MuJoCo model object containing the simulation model.\njoint_name : Union[int, str]\n    The name or ID of the joint whose <code>qpos</code> indices are to be retrieved.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>np.ndarray\n    An array of indices in the <code>qpos</code> array that correspond to the specified joint.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<ul>\n<li>The <code>joint_name</code> can be provided as either a string (name) or an integer (ID).</li>\n<li>Ensure that the <code>joint_name</code> is valid and corresponds to an existing joint in the model.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"n\">mujoco</span><span class=\"o\">.</span><span class=\"n\">_structs</span><span class=\"o\">.</span><span class=\"n\">MjModel</span>,</span><span class=\"param\">\t<span class=\"n\">model</span><span class=\"p\">:</span> <span class=\"n\">mujoco</span><span class=\"o\">.</span><span class=\"n\">_structs</span><span class=\"o\">.</span><span class=\"n\">MjModel</span>,</span><span class=\"param\">\t<span class=\"n\">joint_name</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "utils.mj.get_joint_dof_indxs", "modulename": "utils.mj", "qualname": "get_joint_dof_indxs", "kind": "function", "doc": "<p>Retrieves the degrees of freedom (DOF) indices for a specified joint in the MuJoCo model.</p>\n\n<p>This function obtains the indices of the degrees of freedom for a given joint, which represent\nthe joint's DOF in the MuJoCo model.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>model : mj.MjModel\n    The MuJoCo model object containing the simulation model.\njoint_name : Union[int, str]\n    The name or ID of the joint whose DOF indices are to be retrieved.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>np.ndarray\n    An array of indices corresponding to the degrees of freedom of the specified joint.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<ul>\n<li>The <code>joint_name</code> can be provided as either a string (name) or an integer (ID).</li>\n<li>Ensure that the <code>joint_name</code> is valid and corresponds to an existing joint in the model.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">model</span><span class=\"p\">:</span> <span class=\"n\">mujoco</span><span class=\"o\">.</span><span class=\"n\">_structs</span><span class=\"o\">.</span><span class=\"n\">MjModel</span>,</span><span class=\"param\">\t<span class=\"n\">joint_name</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "utils.mj.get_joint_dim", "modulename": "utils.mj", "qualname": "get_joint_dim", "kind": "function", "doc": "<p>Retrieves the dimensionality (number of <code>qpos</code> elements) of the specified joint in the MuJoCo simulation.</p>\n\n<p>This function determines the number of position elements (<code>qpos</code>) associated with a given joint,\nwhich reflects the joint's degrees of freedom or configuration.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>data : mj.MjData\n    The MuJoCo data object associated with the simulation.\nmodel : mj.MjModel\n    The MuJoCo model object containing the simulation model.\njoint_name : Union[str, int]\n    The name or ID of the joint whose dimensionality is to be retrieved.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>int\n    The number of <code>qpos</code> elements for the specified joint, representing its dimensionality.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<ul>\n<li>The <code>joint_name</code> can be specified as either a string (name) or an integer (ID).</li>\n<li>Ensure that the <code>joint_name</code> is valid and corresponds to an existing joint in the model.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"n\">mujoco</span><span class=\"o\">.</span><span class=\"n\">_structs</span><span class=\"o\">.</span><span class=\"n\">MjData</span>,</span><span class=\"param\">\t<span class=\"n\">model</span><span class=\"p\">:</span> <span class=\"n\">mujoco</span><span class=\"o\">.</span><span class=\"n\">_structs</span><span class=\"o\">.</span><span class=\"n\">MjModel</span>,</span><span class=\"param\">\t<span class=\"n\">joint_name</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span>:</span></span>", "funcdef": "def"}, {"fullname": "utils.mj.load_keyframe", "modulename": "utils.mj", "qualname": "load_keyframe", "kind": "function", "doc": "<p>Load a MuJoCo simulation state from a specified keyframe in an XML file or string.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>model : mj.MjModel\n    The MuJoCo model object which defines the simulation.\ndata : mj.MjData\n    The MuJoCo data object to load the state into.\nkeyframe_name : str\n    The name of the keyframe state to load.\nreturn_xml : bool, optional\n    If True, return the XML content as a string instead of loading it into the model. Defaults to False.\nfile_path : str, optional\n    Path to the XML file to load from. If None, defaults to \"keyframes/<file_name>.xml\".\nlog : bool, optional\n    Whether to log the loading action. Defaults to True.\nstep : bool, optional\n    Whether to step the simulation after loading the state. Defaults to True.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>Optional[str]\n    If return_xml is True, returns the XML content as a string. Otherwise, returns None.</p>\n\n<h2 id=\"raises\">Raises</h2>\n\n<p>ValueError\n    If the specified state_name does not correspond to a valid keyframe.\nFileNotFoundError\n    If the specified file_path does not exist.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">model</span><span class=\"p\">:</span> <span class=\"n\">mujoco</span><span class=\"o\">.</span><span class=\"n\">_structs</span><span class=\"o\">.</span><span class=\"n\">MjModel</span>,</span><span class=\"param\">\t<span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"n\">mujoco</span><span class=\"o\">.</span><span class=\"n\">_structs</span><span class=\"o\">.</span><span class=\"n\">MjData</span>,</span><span class=\"param\">\t<span class=\"n\">keyframe_name</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">file_path</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">return_xml</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">log</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">step</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "utils.mj.save_keyframe", "modulename": "utils.mj", "qualname": "save_keyframe", "kind": "function", "doc": "<p>Save the current state of a MuJoCo simulation to an XML file as a keyframe.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>model : mj.MjModel\n    The MuJoCo model object.\ndata : mj.MjData\n    The MuJoCo data object containing the current simulation state.\nkeyframe_name : str\n    The name to associate with the saved state.\nsave_path : str\n    The file path where the keyframes XML will be saved.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<ul>\n<li>If the file doesn't exist, it is created with a root <code>&lt;mujoco&gt;</code> tag.</li>\n<li>If a keyframe with the same name already exists, it will be overwritten.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">model</span><span class=\"p\">:</span> <span class=\"n\">mujoco</span><span class=\"o\">.</span><span class=\"n\">_structs</span><span class=\"o\">.</span><span class=\"n\">MjModel</span>,</span><span class=\"param\">\t<span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"n\">mujoco</span><span class=\"o\">.</span><span class=\"n\">_structs</span><span class=\"o\">.</span><span class=\"n\">MjData</span>,</span><span class=\"param\">\t<span class=\"n\">keyframe_name</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">save_path</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "utils.mj.apply_wrench", "modulename": "utils.mj", "qualname": "apply_wrench", "kind": "function", "doc": "<p>Applies a wrench (force and torque) to a specific body in the MuJoCo simulation.</p>\n\n<p>The wrench is a 6-dimensional vector that includes both force (fx, fy, fz) and torque (tx, ty, tz).\nThis function allows you to apply the wrench to a body in the simulation using its name.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>data : mj.MjData\n    The MuJoCo data object associated with the current simulation state.\nmodel : mj.MjModel\n    The MuJoCo model object containing the simulation model.\nbody_name : str\n    The name of the body to which the wrench will be applied.\nwrench : Union[np.ndarray, List, Tuple]\n    The wrench to be applied, provided as a 6-dimensional vector in any of the following formats:\n    - numpy array\n    - list\n    - tuple</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>None</p>\n\n<h2 id=\"raises\">Raises</h2>\n\n<p>ValueError\n    If the wrench is not a 6-dimensional vector or if the body name does not exist in the model.\nTypeError\n    If the wrench is not a type that can be converted to a numpy array.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"n\">mujoco</span><span class=\"o\">.</span><span class=\"n\">_structs</span><span class=\"o\">.</span><span class=\"n\">MjData</span>,</span><span class=\"param\">\t<span class=\"n\">model</span><span class=\"p\">:</span> <span class=\"n\">mujoco</span><span class=\"o\">.</span><span class=\"n\">_structs</span><span class=\"o\">.</span><span class=\"n\">MjModel</span>,</span><span class=\"param\">\t<span class=\"n\">body_name</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">wrench</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"n\">List</span><span class=\"p\">,</span> <span class=\"n\">Tuple</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "utils.mj.get_geoms_in_contact", "modulename": "utils.mj", "qualname": "get_geoms_in_contact", "kind": "function", "doc": "<p>Retrieve a list of geometry pairs currently in contact in the MuJoCo simulation.</p>\n\n<p>This function iterates through all contacts in the MuJoCo simulation data and\ncollects the names of geometries that are in contact. It returns a list of tuples,\nwhere each tuple contains the names of two geometries that are in contact.</p>\n\n<h2 id=\"args\">Args</h2>\n\n<p>data : mj.MjData\n    The MuJoCo data object containing the current state of the simulation.\nmodel : mj.MjModel\n    The MuJoCo model object containing the simulation model.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>List[Tuple[str, str]]:\n    A list of tuples, where each tuple contains the names of two geometries that are in contact.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>Ensure that the MuJoCo model and data are correctly initialized before calling this function.\nThe function assumes that all contact pairs are relevant and does not filter them.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"n\">mujoco</span><span class=\"o\">.</span><span class=\"n\">_structs</span><span class=\"o\">.</span><span class=\"n\">MjData</span>,</span><span class=\"param\">\t<span class=\"n\">model</span><span class=\"p\">:</span> <span class=\"n\">mujoco</span><span class=\"o\">.</span><span class=\"n\">_structs</span><span class=\"o\">.</span><span class=\"n\">MjModel</span></span><span class=\"return-annotation\">) -> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "utils.mj.get_bodies_in_contact", "modulename": "utils.mj", "qualname": "get_bodies_in_contact", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"n\">mujoco</span><span class=\"o\">.</span><span class=\"n\">_structs</span><span class=\"o\">.</span><span class=\"n\">MjData</span>,</span><span class=\"param\">\t<span class=\"n\">model</span><span class=\"p\">:</span> <span class=\"n\">mujoco</span><span class=\"o\">.</span><span class=\"n\">_structs</span><span class=\"o\">.</span><span class=\"n\">MjModel</span></span><span class=\"return-annotation\">) -> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "utils.mj.get_joint_pos", "modulename": "utils.mj", "qualname": "get_joint_pos", "kind": "function", "doc": "<p>Retrieve the position of a specified joint in the MuJoCo simulation.</p>\n\n<p>This function returns the anchor position of the specified joint.</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p>data : mj.MjData\n    The MuJoCo data object containing simulation data.\nmodel : mj.MjModel\n    The MuJoCo model object containing the simulation model.\njoint_name : str\n    The name of the joint whose position is to be retrieved.</p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>np.ndarray:\n    The anchor position of the specified joint as a NumPy array.</p>\n\n<h2 id=\"notes\">Notes:</h2>\n\n<p>Ensure that the specified joint name exists in the MuJoCo model.\nRaises a ValueError if the joint name is not found.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"n\">mujoco</span><span class=\"o\">.</span><span class=\"n\">_structs</span><span class=\"o\">.</span><span class=\"n\">MjData</span>,</span><span class=\"param\">\t<span class=\"n\">model</span><span class=\"p\">:</span> <span class=\"n\">mujoco</span><span class=\"o\">.</span><span class=\"n\">_structs</span><span class=\"o\">.</span><span class=\"n\">MjModel</span>,</span><span class=\"param\">\t<span class=\"n\">joint_name</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "utils.mj.get_geom_distance", "modulename": "utils.mj", "qualname": "get_geom_distance", "kind": "function", "doc": "<p>Calculate the smallest signed distance between two geometries (geoms) and the segment from one geom to the other.</p>\n\n<p>This function computes the distance between two specified geoms and provides the segment vector between them.\nThe distance is computed within a specified maximum distance, <code>distmax</code>. If the distance is greater than\n<code>distmax</code>, the function will return <code>distmax</code>.</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p>data : mj.MjData\n    The MuJoCo data object containing the current state of the simulation.\nmodel : mj.MjModel\n    The MuJoCo model object containing the simulation model.\ngeom1 : Union[int, str]\n    The ID or name of the first geometry.\ngeom2 : Union[int, str]\n    The ID or name of the second geometry.\ndistmax : float, optional\n    The maximum distance for the distance calculation. Defaults to 10.0.</p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>Tuple[float, np.ndarray]\n    A tuple where the first element is the smallest signed distance between the two geoms, and the second\n    element is the segment vector from <code>geom1</code> to <code>geom2</code>.</p>\n\n<h2 id=\"raises\">Raises:</h2>\n\n<p>ValueError\n    If <code>geom1</code> or <code>geom2</code> is not a valid geometry ID or name, or if <code>distmax</code> is not a positive number.</p>\n\n<h2 id=\"notes\">Notes:</h2>\n\n<ul>\n<li>Ensure that both <code>geom1</code> and <code>geom2</code> are valid geometry IDs or names within the MuJoCo model.</li>\n<li>The distance calculation is sensitive to the model and simulation state. Ensure that the simulation is updated\nif necessary before calling this function.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"n\">mujoco</span><span class=\"o\">.</span><span class=\"n\">_structs</span><span class=\"o\">.</span><span class=\"n\">MjData</span>,</span><span class=\"param\">\t<span class=\"n\">model</span><span class=\"p\">:</span> <span class=\"n\">mujoco</span><span class=\"o\">.</span><span class=\"n\">_structs</span><span class=\"o\">.</span><span class=\"n\">MjModel</span>,</span><span class=\"param\">\t<span class=\"n\">geom1</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">geom2</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">distmax</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">10.0</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "utils.mj.ContactState", "modulename": "utils.mj", "qualname": "ContactState", "kind": "class", "doc": "<p>A class to represent the state of a contact in a MuJoCo simulation.</p>\n\n<h2 id=\"attributes\">Attributes</h2>\n\n<p>H : np.ndarray\n    A 36-element cone Hessian, set by <code>mj_updateConstraint</code>.\ndim : int\n    The contact space dimensionality: 1, 3, 4, or 6.\ndist : float\n    The distance between the nearest points; negative values indicate penetration.\nefc_address : int\n    The address in the constraint force Jacobian.\nelem : np.ndarray\n    A 2-element array of integers representing element IDs; -1 for geom or flex vertex.\nexclude : int\n    Exclusion flag for the contact: 0 (include), 1 (in gap), 2 (fused), 3 (no dofs).\nflex : np.ndarray\n    A 2-element array of integers representing flex IDs; -1 for geom.\nframe : np.ndarray\n    A 9-element array representing the contact frame. The normal is in [0-2] and points from geom[0] to geom[1].\nfriction : np.ndarray\n    A 5-element array representing friction parameters: tangent1, 2, spin, roll1, roll2.\ngeom : np.ndarray\n    A 2-element array of integers representing the IDs of the geometries in contact; -1 for flex.\ngeom1 : int\n    The first geometry index.\ngeom2 : int\n    The second geometry index.\ngeom_names : np.ndarray\n    A 2-element array of strings representing the names of the geometries in contact.\ngeom1_name : str\n    The name of the first geometry.\ngeom2_name : str\n    The name of the second geometry.\nincludemargin : float\n    The inclusion margin for the contact; includes if dist &lt; includemargin = margin - gap.\nmu : float\n    The coefficient of friction.\npos : np.ndarray\n    A 3-element array representing the position of the contact point, typically the midpoint between geometries.\nsolimp : np.ndarray\n    A 5-element array for solver impedance parameters.\nsolref : np.ndarray\n    A 2-element array for solver reference parameters for the normal direction.\nsolreffriction : np.ndarray\n    A 2-element array for solver reference parameters related to friction directions.\nvert : np.ndarray\n    A 2-element array of integers representing vertex IDs; -1 for geom or flex element.\nindex : int\n    The index of the contact in the simulation.\nmodel : mj.MjModel\n    The MuJoCo model object.\ndata : mj.MjData\n    The MuJoCo data object.\nc_wrench : np.ndarray\n    A 6-element array representing the wrench (force and torque) at the contact in the contact frame.\nw_wrench : np.ndarray\n    A 6-element array representing the wrench (force and torque) at the contact in the world frame.</p>\n\n<h2 id=\"methods\">Methods</h2>\n\n<p>_compute_wrench():\n    Computes the wrench for the contact based on the model, data, and contact index.</p>\n\n<p>_transform_wrench_to_global(wrench: np.ndarray):\n    Transforms the contact wrench from the contact frame to the world frame.</p>\n\n<p>from_mjcontact(cls, mjcontact, model, data, index=-1):\n    Creates a ContactState instance from a given MjContact object.</p>\n"}, {"fullname": "utils.mj.ContactState.__init__", "modulename": "utils.mj", "qualname": "ContactState.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"n\">mujoco</span><span class=\"o\">.</span><span class=\"n\">_structs</span><span class=\"o\">.</span><span class=\"n\">MjData</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">model</span><span class=\"p\">:</span> <span class=\"n\">mujoco</span><span class=\"o\">.</span><span class=\"n\">_structs</span><span class=\"o\">.</span><span class=\"n\">MjModel</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">H</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">factory</span><span class=\"o\">&gt;</span>,</span><span class=\"param\">\t<span class=\"n\">dim</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">dist</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.0</span>,</span><span class=\"param\">\t<span class=\"n\">efc_address</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">elem</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">factory</span><span class=\"o\">&gt;</span>,</span><span class=\"param\">\t<span class=\"n\">exclude</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">flex</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">factory</span><span class=\"o\">&gt;</span>,</span><span class=\"param\">\t<span class=\"n\">frame</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">factory</span><span class=\"o\">&gt;</span>,</span><span class=\"param\">\t<span class=\"n\">friction</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">factory</span><span class=\"o\">&gt;</span>,</span><span class=\"param\">\t<span class=\"n\">geom</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">factory</span><span class=\"o\">&gt;</span>,</span><span class=\"param\">\t<span class=\"n\">geom1</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">geom2</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">geom_names</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">factory</span><span class=\"o\">&gt;</span>,</span><span class=\"param\">\t<span class=\"n\">geom1_name</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">geom2_name</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">includemargin</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.0</span>,</span><span class=\"param\">\t<span class=\"n\">mu</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.0</span>,</span><span class=\"param\">\t<span class=\"n\">pos</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">factory</span><span class=\"o\">&gt;</span>,</span><span class=\"param\">\t<span class=\"n\">solimp</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">factory</span><span class=\"o\">&gt;</span>,</span><span class=\"param\">\t<span class=\"n\">solref</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">factory</span><span class=\"o\">&gt;</span>,</span><span class=\"param\">\t<span class=\"n\">solreffriction</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">factory</span><span class=\"o\">&gt;</span>,</span><span class=\"param\">\t<span class=\"n\">vert</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">factory</span><span class=\"o\">&gt;</span>,</span><span class=\"param\">\t<span class=\"n\">index</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"o\">-</span><span class=\"mi\">1</span></span>)</span>"}, {"fullname": "utils.mj.ContactState.data", "modulename": "utils.mj", "qualname": "ContactState.data", "kind": "variable", "doc": "<p></p>\n", "annotation": ": mujoco._structs.MjData", "default_value": "None"}, {"fullname": "utils.mj.ContactState.model", "modulename": "utils.mj", "qualname": "ContactState.model", "kind": "variable", "doc": "<p></p>\n", "annotation": ": mujoco._structs.MjModel", "default_value": "None"}, {"fullname": "utils.mj.ContactState.H", "modulename": "utils.mj", "qualname": "ContactState.H", "kind": "variable", "doc": "<p></p>\n", "annotation": ": numpy.ndarray"}, {"fullname": "utils.mj.ContactState.dim", "modulename": "utils.mj", "qualname": "ContactState.dim", "kind": "variable", "doc": "<p></p>\n", "annotation": ": int", "default_value": "0"}, {"fullname": "utils.mj.ContactState.dist", "modulename": "utils.mj", "qualname": "ContactState.dist", "kind": "variable", "doc": "<p></p>\n", "annotation": ": float", "default_value": "0.0"}, {"fullname": "utils.mj.ContactState.efc_address", "modulename": "utils.mj", "qualname": "ContactState.efc_address", "kind": "variable", "doc": "<p></p>\n", "annotation": ": int", "default_value": "0"}, {"fullname": "utils.mj.ContactState.elem", "modulename": "utils.mj", "qualname": "ContactState.elem", "kind": "variable", "doc": "<p></p>\n", "annotation": ": numpy.ndarray"}, {"fullname": "utils.mj.ContactState.exclude", "modulename": "utils.mj", "qualname": "ContactState.exclude", "kind": "variable", "doc": "<p></p>\n", "annotation": ": int", "default_value": "0"}, {"fullname": "utils.mj.ContactState.flex", "modulename": "utils.mj", "qualname": "ContactState.flex", "kind": "variable", "doc": "<p></p>\n", "annotation": ": numpy.ndarray"}, {"fullname": "utils.mj.ContactState.frame", "modulename": "utils.mj", "qualname": "ContactState.frame", "kind": "variable", "doc": "<p></p>\n", "annotation": ": numpy.ndarray"}, {"fullname": "utils.mj.ContactState.friction", "modulename": "utils.mj", "qualname": "ContactState.friction", "kind": "variable", "doc": "<p></p>\n", "annotation": ": numpy.ndarray"}, {"fullname": "utils.mj.ContactState.geom", "modulename": "utils.mj", "qualname": "ContactState.geom", "kind": "variable", "doc": "<p></p>\n", "annotation": ": numpy.ndarray"}, {"fullname": "utils.mj.ContactState.geom1", "modulename": "utils.mj", "qualname": "ContactState.geom1", "kind": "variable", "doc": "<p></p>\n", "annotation": ": int", "default_value": "0"}, {"fullname": "utils.mj.ContactState.geom2", "modulename": "utils.mj", "qualname": "ContactState.geom2", "kind": "variable", "doc": "<p></p>\n", "annotation": ": int", "default_value": "0"}, {"fullname": "utils.mj.ContactState.geom_names", "modulename": "utils.mj", "qualname": "ContactState.geom_names", "kind": "variable", "doc": "<p></p>\n", "annotation": ": numpy.ndarray"}, {"fullname": "utils.mj.ContactState.geom1_name", "modulename": "utils.mj", "qualname": "ContactState.geom1_name", "kind": "variable", "doc": "<p></p>\n", "annotation": ": str", "default_value": "None"}, {"fullname": "utils.mj.ContactState.geom2_name", "modulename": "utils.mj", "qualname": "ContactState.geom2_name", "kind": "variable", "doc": "<p></p>\n", "annotation": ": str", "default_value": "None"}, {"fullname": "utils.mj.ContactState.includemargin", "modulename": "utils.mj", "qualname": "ContactState.includemargin", "kind": "variable", "doc": "<p></p>\n", "annotation": ": float", "default_value": "0.0"}, {"fullname": "utils.mj.ContactState.mu", "modulename": "utils.mj", "qualname": "ContactState.mu", "kind": "variable", "doc": "<p></p>\n", "annotation": ": float", "default_value": "0.0"}, {"fullname": "utils.mj.ContactState.pos", "modulename": "utils.mj", "qualname": "ContactState.pos", "kind": "variable", "doc": "<p></p>\n", "annotation": ": numpy.ndarray"}, {"fullname": "utils.mj.ContactState.solimp", "modulename": "utils.mj", "qualname": "ContactState.solimp", "kind": "variable", "doc": "<p></p>\n", "annotation": ": numpy.ndarray"}, {"fullname": "utils.mj.ContactState.solref", "modulename": "utils.mj", "qualname": "ContactState.solref", "kind": "variable", "doc": "<p></p>\n", "annotation": ": numpy.ndarray"}, {"fullname": "utils.mj.ContactState.solreffriction", "modulename": "utils.mj", "qualname": "ContactState.solreffriction", "kind": "variable", "doc": "<p></p>\n", "annotation": ": numpy.ndarray"}, {"fullname": "utils.mj.ContactState.vert", "modulename": "utils.mj", "qualname": "ContactState.vert", "kind": "variable", "doc": "<p></p>\n", "annotation": ": numpy.ndarray"}, {"fullname": "utils.mj.ContactState.index", "modulename": "utils.mj", "qualname": "ContactState.index", "kind": "variable", "doc": "<p></p>\n", "annotation": ": int", "default_value": "-1"}, {"fullname": "utils.mj.ContactState.c_wrench", "modulename": "utils.mj", "qualname": "ContactState.c_wrench", "kind": "variable", "doc": "<p></p>\n", "annotation": ": numpy.ndarray"}, {"fullname": "utils.mj.ContactState.w_wrench", "modulename": "utils.mj", "qualname": "ContactState.w_wrench", "kind": "variable", "doc": "<p></p>\n", "annotation": ": numpy.ndarray"}, {"fullname": "utils.mj.ContactState.from_mjcontact", "modulename": "utils.mj", "qualname": "ContactState.from_mjcontact", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">cls</span>,</span><span class=\"param\">\t<span class=\"n\">mjcontact</span>,</span><span class=\"param\">\t<span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"n\">mujoco</span><span class=\"o\">.</span><span class=\"n\">_structs</span><span class=\"o\">.</span><span class=\"n\">MjData</span>,</span><span class=\"param\">\t<span class=\"n\">model</span><span class=\"p\">:</span> <span class=\"n\">mujoco</span><span class=\"o\">.</span><span class=\"n\">_structs</span><span class=\"o\">.</span><span class=\"n\">MjModel</span>,</span><span class=\"param\">\t<span class=\"n\">index</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"o\">-</span><span class=\"mi\">1</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "utils.mj.RobotInfo", "modulename": "utils.mj", "qualname": "RobotInfo", "kind": "class", "doc": "<p></p>\n"}, {"fullname": "utils.mj.RobotInfo.__init__", "modulename": "utils.mj", "qualname": "RobotInfo.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">model</span><span class=\"p\">:</span> <span class=\"n\">mujoco</span><span class=\"o\">.</span><span class=\"n\">_structs</span><span class=\"o\">.</span><span class=\"n\">MjModel</span>, </span><span class=\"param\"><span class=\"n\">name</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span>)</span>"}, {"fullname": "utils.mj.RobotInfo.name", "modulename": "utils.mj", "qualname": "RobotInfo.name", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "utils.mj.RobotInfo.m", "modulename": "utils.mj", "qualname": "RobotInfo.m", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "utils.mj.RobotInfo.print", "modulename": "utils.mj", "qualname": "RobotInfo.print", "kind": "function", "doc": "<p>Print the robot's information in a formatted and indented list.</p>\n\n<p>This method outputs the robot's detailed information, including base body name,\nnumber of bodies, actuators, joints, geometries, joint limits, and actuator limits.\nEach component's name and ID are listed with proper indentation to provide a clear,\norganized view of the robot's structure and components.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "utils.mj.RobotInfo.body_ids", "modulename": "utils.mj", "qualname": "RobotInfo.body_ids", "kind": "variable", "doc": "<p>List of body IDs associated with the robot model.</p>\n", "annotation": ": List[int]"}, {"fullname": "utils.mj.RobotInfo.body_names", "modulename": "utils.mj", "qualname": "RobotInfo.body_names", "kind": "variable", "doc": "<p>List of body names associated with the robot model.</p>\n", "annotation": ": List[str]"}, {"fullname": "utils.mj.RobotInfo.actuator_ids", "modulename": "utils.mj", "qualname": "RobotInfo.actuator_ids", "kind": "variable", "doc": "<p>List of actuator IDs associated with the robot model.</p>\n", "annotation": ": List[int]"}, {"fullname": "utils.mj.RobotInfo.actuator_names", "modulename": "utils.mj", "qualname": "RobotInfo.actuator_names", "kind": "variable", "doc": "<p>List of actuator names associated with the robot model.</p>\n", "annotation": ": List[str]"}, {"fullname": "utils.mj.RobotInfo.geom_ids", "modulename": "utils.mj", "qualname": "RobotInfo.geom_ids", "kind": "variable", "doc": "<p>List of geometry IDs associated with the robot model.</p>\n", "annotation": ": List[int]"}, {"fullname": "utils.mj.RobotInfo.geom_names", "modulename": "utils.mj", "qualname": "RobotInfo.geom_names", "kind": "variable", "doc": "<p>List of geometry names associated with the robot model.</p>\n", "annotation": ": List[str]"}, {"fullname": "utils.mj.RobotInfo.joint_indxs", "modulename": "utils.mj", "qualname": "RobotInfo.joint_indxs", "kind": "variable", "doc": "<p>List of indices for joint positions in the robot model.</p>\n", "annotation": ": List[int]"}, {"fullname": "utils.mj.RobotInfo.dof_indxs", "modulename": "utils.mj", "qualname": "RobotInfo.dof_indxs", "kind": "variable", "doc": "<p>List of indices for degrees of freedom in the robot model.</p>\n", "annotation": ": List[int]"}, {"fullname": "utils.mj.RobotInfo.joint_ids", "modulename": "utils.mj", "qualname": "RobotInfo.joint_ids", "kind": "variable", "doc": "<p>List of joint IDs associated with the robot model.</p>\n", "annotation": ": List[int]"}, {"fullname": "utils.mj.RobotInfo.joint_names", "modulename": "utils.mj", "qualname": "RobotInfo.joint_names", "kind": "variable", "doc": "<p>List of joint names associated with the robot model.</p>\n", "annotation": ": List[str]"}, {"fullname": "utils.mj.RobotInfo.n_actuators", "modulename": "utils.mj", "qualname": "RobotInfo.n_actuators", "kind": "variable", "doc": "<p>Get the number of actuators.</p>\n", "annotation": ": int"}, {"fullname": "utils.mj.RobotInfo.n_joints", "modulename": "utils.mj", "qualname": "RobotInfo.n_joints", "kind": "variable", "doc": "<p>Get the number of joints.</p>\n", "annotation": ": int"}, {"fullname": "utils.mj.RobotInfo.joint_limits", "modulename": "utils.mj", "qualname": "RobotInfo.joint_limits", "kind": "variable", "doc": "<p>Get the joint limits as a numpy array.</p>\n", "annotation": ": numpy.ndarray"}, {"fullname": "utils.mj.RobotInfo.actuator_limits", "modulename": "utils.mj", "qualname": "RobotInfo.actuator_limits", "kind": "variable", "doc": "<p>Get the actuator limits as a numpy array.</p>\n", "annotation": ": numpy.ndarray"}, {"fullname": "utils.mj.RobotInfo.site_ids", "modulename": "utils.mj", "qualname": "RobotInfo.site_ids", "kind": "variable", "doc": "<p>List of site IDs associated with the robot model.</p>\n", "annotation": ": List[int]"}, {"fullname": "utils.mj.RobotInfo.site_names", "modulename": "utils.mj", "qualname": "RobotInfo.site_names", "kind": "variable", "doc": "<p>List of site names associated with the robot model.</p>\n", "annotation": ": List[str]"}, {"fullname": "utils.mj.RobotInfo.sensor_ids", "modulename": "utils.mj", "qualname": "RobotInfo.sensor_ids", "kind": "variable", "doc": "<p>List of sensor IDs associated with the robot model.</p>\n", "annotation": ": List[int]"}, {"fullname": "utils.mj.RobotInfo.sensor_names", "modulename": "utils.mj", "qualname": "RobotInfo.sensor_names", "kind": "variable", "doc": "<p>List of sensor names associated with the robot model.</p>\n", "annotation": ": List[str]"}, {"fullname": "utils.mj.RobotInfo.camera_ids", "modulename": "utils.mj", "qualname": "RobotInfo.camera_ids", "kind": "variable", "doc": "<p>List of camera IDs associated with the robot model.</p>\n", "annotation": ": List[int]"}, {"fullname": "utils.mj.RobotInfo.camera_names", "modulename": "utils.mj", "qualname": "RobotInfo.camera_names", "kind": "variable", "doc": "<p>List of camera names associated with the robot model.</p>\n", "annotation": ": List[str]"}, {"fullname": "utils.mj.get_contact_states", "modulename": "utils.mj", "qualname": "get_contact_states", "kind": "function", "doc": "<p>Retrieves the contact states for specified geometries in the MuJoCo simulation.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>data : mj.MjData\n    The MuJoCo data object containing the current state of the simulation, including contact information.\nmodel : mj.MjModel\n    The MuJoCo model object, which defines the structure of the simulation including geometries.\ngeom_names1 : Union[int, str, List[int], List[str], np.ndarray], optional\n    The name or ID of the first geometry (or a list/array of them) to check for contact.\n    If provided, the function filters the contact states to include only those involving this geometry.\n    Default is None.\ngeom_names2 : Union[int, str, List[int], List[str], np.ndarray], optional\n    The name or ID of the second geometry (or a list/array of them) to check for contact.\n    If provided, the function filters the contact states to include only those involving both specified geometries.\n    Default is None.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>Tuple[bool, List[ContactState]]\n    - A boolean indicating whether any contact was found (<code>True</code> if there are contact states, <code>False</code> otherwise).\n    - A list of ContactState objects representing the states of the contacts in the simulation.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<ul>\n<li>If both <code>geom_names1</code> and <code>geom_names2</code> are provided, the function returns only the contacts involving both geometries.</li>\n<li>If only one geometry (either name or ID or list of them) is provided, the function returns all contacts involving that geometry.</li>\n<li>If no geometry names or IDs are provided, the function returns all contact states in the simulation.</li>\n</ul>\n\n<h2 id=\"examples\">Examples</h2>\n\n<h1 id=\"example-1-get-all-contact-states-in-the-simulation\">Example 1: Get all contact states in the simulation</h1>\n\n<p>in_contact, contact_states = get_contact_states(data, model)</p>\n\n<h1 id=\"example-2-get-contact-states-involving-a-specific-geometry-by-name\">Example 2: Get contact states involving a specific geometry by name</h1>\n\n<p>in_contact, contact_states = get_contact_states(data, model, geom_names1='geom1')</p>\n\n<h1 id=\"example-3-get-contact-states-involving-two-specific-geometries-by-ids\">Example 3: Get contact states involving two specific geometries by IDs</h1>\n\n<p>in_contact, contact_states = get_contact_states(data, model, geom_names1=3, geom_names2=5)</p>\n\n<h1 id=\"example-4-get-contact-states-involving-any-of-multiple-geometries\">Example 4: Get contact states involving any of multiple geometries</h1>\n\n<p>in_contact, contact_states = get_contact_states(data, model, geom_names1=['geom1', 'geom2'])</p>\n\n<h1 id=\"example-5-get-contact-states-involving-pairs-of-geometries-from-two-lists\">Example 5: Get contact states involving pairs of geometries from two lists</h1>\n\n<p>in_contact, contact_states = get_contact_states(data, model, geom_names1=[3, 5], geom_names2=['geom6', 'geom7'])</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"n\">mujoco</span><span class=\"o\">.</span><span class=\"n\">_structs</span><span class=\"o\">.</span><span class=\"n\">MjData</span>,</span><span class=\"param\">\t<span class=\"n\">model</span><span class=\"p\">:</span> <span class=\"n\">mujoco</span><span class=\"o\">.</span><span class=\"n\">_structs</span><span class=\"o\">.</span><span class=\"n\">MjModel</span>,</span><span class=\"param\">\t<span class=\"n\">geom_names1</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">]],</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">geom_names2</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">]],</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">bool</span><span class=\"p\">,</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">utils</span><span class=\"o\">.</span><span class=\"n\">mj</span><span class=\"o\">.</span><span class=\"n\">ContactState</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "utils.helpers", "modulename": "utils.helpers", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "utils.helpers.Bool", "modulename": "utils.helpers", "qualname": "Bool", "kind": "function", "doc": "<p>Convert a value to a boolean-like string.</p>\n\n<p>This function interprets the input value and returns a boolean value based on common\nrepresentations of <code>True</code>. It recognizes the strings \"true\", \"1\", and \"yes\" as\n<code>True</code> and everything else as <code>False</code>.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>x : any\n    The value to convert to a boolean-like string. This can be of any type, as it will be\n    converted to a string for comparison.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>bool\n    <code>True</code> if the value is one of [\"true\", \"1\", \"yes\"], otherwise <code>False</code>.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "utils.helpers.Callable", "modulename": "utils.helpers", "qualname": "Callable", "kind": "function", "doc": "<p>Retrieve a callable object from the global namespace by its name.</p>\n\n<p>This function searches for a callable object in the global namespace using its name.\nIf the callable is found, it is returned; otherwise, an exception is raised.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>callable_name : str\n    The name of the callable object to retrieve from the global namespace.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>callable\n    The callable object if it is found in the global namespace.</p>\n\n<h2 id=\"raises\">Raises</h2>\n\n<p>argparse.ArgumentTypeError\n    If the callable name does not correspond to a callable object in the global namespace.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">callable_name</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "utils.helpers.timer", "modulename": "utils.helpers", "qualname": "timer", "kind": "function", "doc": "<p>Context manager to measure and print the elapsed time of a code block.</p>\n\n<p>This context manager allows for the measurement of execution time within a code block.\nIt prints the elapsed time upon exiting the context, optionally with a provided\ndescription.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>context : str, optional\n    A description to include in the printout alongside the elapsed time. If not provided,\n    only the elapsed time will be printed.</p>\n\n<h2 id=\"yields\">Yields</h2>\n\n<p>None\n    The context manager does not yield any value; it only measures and prints elapsed time.</p>\n\n<h2 id=\"prints\">Prints</h2>\n\n<p>Elapsed time\n    The time taken to execute the code block, optionally with the provided context description.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">context</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "utils.learning", "modulename": "utils.learning", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "utils.learning.create_data_directory", "modulename": "utils.learning", "qualname": "create_data_directory", "kind": "function", "doc": "<p>Create a directory structure for storing data related to a specific environment and session.</p>\n\n<p>Args:\n    environment_name (str): The name of the environment.\n    session_name (str): The name of the session.</p>\n\n<p>Returns:\n    Path: The path to the created session directory.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">environment_name</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">session_name</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pathlib</span><span class=\"o\">.</span><span class=\"n\">Path</span>:</span></span>", "funcdef": "def"}, {"fullname": "utils.learning.get_dimensions_from_params", "modulename": "utils.learning", "qualname": "get_dimensions_from_params", "kind": "function", "doc": "<p>Extract observation and action dimensions from model parameters.</p>\n\n<p>Args:\n    params (Tuple[RunningStatisticsState, dict]):\n        A tuple containing the running statistics state and a dictionary of model parameters.</p>\n\n<p>Returns:\n    Tuple[int, int]: A tuple where the first element is the observation dimension (o_dim)\n                     and the second element is the action dimension (a_dim).</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">params</span><span class=\"p\">:</span> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">brax</span><span class=\"o\">.</span><span class=\"n\">training</span><span class=\"o\">.</span><span class=\"n\">acme</span><span class=\"o\">.</span><span class=\"n\">running_statistics</span><span class=\"o\">.</span><span class=\"n\">RunningStatisticsState</span><span class=\"p\">,</span> <span class=\"n\">Dict</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "utils.learning.generate_demo_video", "modulename": "utils.learning", "qualname": "generate_demo_video", "kind": "function", "doc": "<p>Generates a demonstration video of a reinforcement learning agent's performance.</p>\n\n<p>This function creates a video by simulating an environment and rendering frames\nat specified intervals. The agent's actions are determined using a provided\ninference function and trained model parameters.</p>\n\n<p>Args:\n    args (Args): Command-line arguments or configuration for the environment.\n    make_inference_fn (Callable): A function that generates an inference function\n                                   from model parameters.\n    params (tuple): Placeholder for model parameters (unused; parameters are loaded\n                    from the session path).\n    session_path (Path): Path to the directory containing the trained model parameters.\n    n_steps (int): Number of simulation steps to run. Defaults to 500.\n    render_every (int): Frequency of rendering frames (every <code>render_every</code> steps).\n                        Defaults to 2.</p>\n\n<p>Returns:\n    list[np.ndarray]: A list of rendered video frames, where each frame is a NumPy\n                      array representing the image in RGB format.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">args</span><span class=\"p\">:</span> <span class=\"n\">utils</span><span class=\"o\">.</span><span class=\"n\">args</span><span class=\"o\">.</span><span class=\"n\">Args</span>,</span><span class=\"param\">\t<span class=\"n\">make_inference_fn</span><span class=\"p\">:</span> <span class=\"n\">Callable</span>,</span><span class=\"param\">\t<span class=\"n\">params</span><span class=\"p\">:</span> <span class=\"nb\">tuple</span>,</span><span class=\"param\">\t<span class=\"n\">session_path</span><span class=\"p\">:</span> <span class=\"n\">pathlib</span><span class=\"o\">.</span><span class=\"n\">Path</span>,</span><span class=\"param\">\t<span class=\"n\">n_steps</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">500</span>,</span><span class=\"param\">\t<span class=\"n\">render_every</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">2</span>,</span><span class=\"param\">\t<span class=\"n\">camera_name</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;side&#39;</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "utils.math", "modulename": "utils.math", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "utils.math.Vector", "modulename": "utils.math", "qualname": "Vector", "kind": "variable", "doc": "<p></p>\n", "default_value": "typing.Union[typing.List[float], typing.Tuple[float, ...], numpy.ndarray]"}, {"fullname": "utils.math.rotate_vector_2d", "modulename": "utils.math", "qualname": "rotate_vector_2d", "kind": "function", "doc": "<p>Rotate a 2D vector by a given angle in radians.</p>\n\n<p>This function applies a rotation matrix to a 2D vector to achieve the rotation.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>vector : Tuple[float, float]\n    The 2D vector to rotate.\nangle : float\n    The angle in radians to rotate the vector by.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>np.ndarray\n    The rotated 2D vector.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">vector</span><span class=\"p\">:</span> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">]</span>, </span><span class=\"param\"><span class=\"n\">angle</span><span class=\"p\">:</span> <span class=\"nb\">float</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "utils.math.dotproduct", "modulename": "utils.math", "qualname": "dotproduct", "kind": "function", "doc": "<p>Calculate the dot product of two vectors.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>v1 : Vector\n    The first vector.\nv2 : Vector\n    The second vector.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>float\n    The dot product of v1 and v2.</p>\n\n<h2 id=\"raises\">Raises</h2>\n\n<p>TypeError\n    If either v1 or v2 is not a list or tuple of floats.\nValueError\n    If the lengths of v1 and v2 are not equal.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">v1</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">],</span> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"o\">...</span><span class=\"p\">],</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">v2</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">],</span> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"o\">...</span><span class=\"p\">],</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "utils.math.length", "modulename": "utils.math", "qualname": "length", "kind": "function", "doc": "<p>Calculate the length (magnitude) of a vector.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>v : Vector\n    The vector.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>float\n    The length of the vector.</p>\n\n<h2 id=\"raises\">Raises</h2>\n\n<p>TypeError\n    If v is not a list or tuple of floats.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">v</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">],</span> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"o\">...</span><span class=\"p\">],</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "utils.math.angle", "modulename": "utils.math", "qualname": "angle", "kind": "function", "doc": "<p>Calculate the angle between two vectors in radians.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>v1 : Vector\n    The first vector.\nv2 : Vector\n    The second vector.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>float\n    The angle between v1 and v2 in radians.</p>\n\n<h2 id=\"raises\">Raises</h2>\n\n<p>TypeError\n    If either v1 or v2 is not a list or tuple of floats.\nValueError\n    If the lengths of v1 and v2 are not equal.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">v1</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">],</span> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"o\">...</span><span class=\"p\">],</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">v2</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">],</span> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"o\">...</span><span class=\"p\">],</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "utils.math.flip", "modulename": "utils.math", "qualname": "flip", "kind": "function", "doc": "<p>Flip a vector (list or numpy array) element-wise by multiplying it with -1.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>v : Union[List[float], np.ndarray]\n    The vector to flip.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>np.ndarray\n    The flipped vector.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">v</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">],</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "utils.math.gcd", "modulename": "utils.math", "qualname": "gcd", "kind": "function", "doc": "<p>Compute the greatest common divisor (GCD) of two numbers using the Euclidean algorithm.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>a : float\n    The first number.\nb : float\n    The second number.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>float\n    The GCD of a and b.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">a</span><span class=\"p\">:</span> <span class=\"nb\">float</span>, </span><span class=\"param\"><span class=\"n\">b</span><span class=\"p\">:</span> <span class=\"nb\">float</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "utils.math.lcm", "modulename": "utils.math", "qualname": "lcm", "kind": "function", "doc": "<p>Compute the least common multiple (LCM) of two numbers or a list of numbers.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>a : Union[float, List[float]]\n    The first number or a list of numbers.\nb : float, optional\n    The second number (if a is a single number).</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>float\n    The LCM of the input numbers.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">a</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">]]</span>, </span><span class=\"param\"><span class=\"n\">b</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "utils.math.arbitrary_orthogonal_vector", "modulename": "utils.math", "qualname": "arbitrary_orthogonal_vector", "kind": "function", "doc": "<p>Find an arbitrary vector orthogonal to the given vector.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>vec : np.ndarray\n    The input vector.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>np.ndarray\n    An orthogonal vector.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">vec</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "utils.math.normalize_vector", "modulename": "utils.math", "qualname": "normalize_vector", "kind": "function", "doc": "<p>Normalize a vector.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>v : np.ndarray\n    The vector to normalize.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>np.ndarray\n    The normalized vector.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">v</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "utils.math.calculate_rotation_between_vectors", "modulename": "utils.math", "qualname": "calculate_rotation_between_vectors", "kind": "function", "doc": "<p>Calculate the rotation matrix that rotates one vector to another.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>v_from : np.ndarray\n    The initial vector.\nv_to : np.ndarray\n    The target vector.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>np.ndarray\n    The rotation matrix.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">v_from</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">v_to</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "utils.math.npq2np", "modulename": "utils.math", "qualname": "npq2np", "kind": "function", "doc": "<p>Convert a numpy quaternion to a numpy array.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>npq : np.quaternion\n    A quaternion from the numpy.quaternion library.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>np.ndarray\n    A numpy array with 4 elements representing the quaternion (w, x, y, z).</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">npq</span><span class=\"p\">:</span> <span class=\"n\">quaternion</span><span class=\"o\">.</span><span class=\"n\">quaternion</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "utils.math.random_unit_quaternion", "modulename": "utils.math", "qualname": "random_unit_quaternion", "kind": "function", "doc": "<p>Generate a random unit quaternion.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>UnitQuaternion\n    A random unit quaternion.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">) -> <span class=\"n\">spatialmath</span><span class=\"o\">.</span><span class=\"n\">quaternion</span><span class=\"o\">.</span><span class=\"n\">UnitQuaternion</span>:</span></span>", "funcdef": "def"}, {"fullname": "utils.math.quat_to_axang", "modulename": "utils.math", "qualname": "quat_to_axang", "kind": "function", "doc": "<p>Convert a quaternion or an array of quaternions to a 4D axis-angle representation.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>q : np.ndarray\n    A numpy array of shape (4,) representing a single quaternion (w, x, y, z)\n    or of shape (N, 4) representing N quaternions.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>np.ndarray\n    A numpy array of shape (4,) representing the axis-angle of a single quaternion\n    (x, y, z, angle) or of shape (N, 4) representing the axis-angle representations\n    of N quaternions.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">q</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "utils.math.conj", "modulename": "utils.math", "qualname": "conj", "kind": "function", "doc": "<p>Compute the conjugate of an array of quaternions.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>q : Union[np.ndarray, list, sm.UnitQuaternion]\n    Input quaternion(s) which can be a list, numpy array, or sm.UnitQuaternion.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>np.ndarray\n    The conjugated array of quaternions.</p>\n\n<h2 id=\"raises\">Raises</h2>\n\n<p>ValueError\n    If the input cannot be converted to a valid quaternion array.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">q</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"nb\">list</span><span class=\"p\">,</span> <span class=\"n\">spatialmath</span><span class=\"o\">.</span><span class=\"n\">quaternion</span><span class=\"o\">.</span><span class=\"n\">UnitQuaternion</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "utils.math.euclidean_distance", "modulename": "utils.math", "qualname": "euclidean_distance", "kind": "function", "doc": "<p>Calculate the Euclidean distance between the translation components of two SE3 poses.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>T1 : sm.SE3\n    The first SE3 pose.\nT2 : sm.SE3\n    The second SE3 pose.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>float\n    The Euclidean distance between the translation components of T1 and T2.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">T1</span><span class=\"p\">:</span> <span class=\"n\">spatialmath</span><span class=\"o\">.</span><span class=\"n\">pose3d</span><span class=\"o\">.</span><span class=\"n\">SE3</span>, </span><span class=\"param\"><span class=\"n\">T2</span><span class=\"p\">:</span> <span class=\"n\">spatialmath</span><span class=\"o\">.</span><span class=\"n\">pose3d</span><span class=\"o\">.</span><span class=\"n\">SE3</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "utils.math.angular_distance", "modulename": "utils.math", "qualname": "angular_distance", "kind": "function", "doc": "<p>Calculate the angular distance between the rotation components of two SE3 poses.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>T1 : sm.SE3\n    The first SE3 pose.\nT2 : sm.SE3\n    The second SE3 pose.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>float\n    The angular distance between the rotation components of T1 and T2 in radians.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">T1</span><span class=\"p\">:</span> <span class=\"n\">spatialmath</span><span class=\"o\">.</span><span class=\"n\">pose3d</span><span class=\"o\">.</span><span class=\"n\">SE3</span>, </span><span class=\"param\"><span class=\"n\">T2</span><span class=\"p\">:</span> <span class=\"n\">spatialmath</span><span class=\"o\">.</span><span class=\"n\">pose3d</span><span class=\"o\">.</span><span class=\"n\">SE3</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "utils.math.frobenius_norm", "modulename": "utils.math", "qualname": "frobenius_norm", "kind": "function", "doc": "<p>Calculate the Frobenius norm of the difference between two SE3 transformation matrices.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>T1 : sm.SE3\n    The first SE3 pose.\nT2 : sm.SE3\n    The second SE3 pose.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>float\n    The Frobenius norm of the difference between the transformation matrices of T1 and T2.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">T1</span><span class=\"p\">:</span> <span class=\"n\">spatialmath</span><span class=\"o\">.</span><span class=\"n\">pose3d</span><span class=\"o\">.</span><span class=\"n\">SE3</span>, </span><span class=\"param\"><span class=\"n\">T2</span><span class=\"p\">:</span> <span class=\"n\">spatialmath</span><span class=\"o\">.</span><span class=\"n\">pose3d</span><span class=\"o\">.</span><span class=\"n\">SE3</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "utils.math.geodesic_distance", "modulename": "utils.math", "qualname": "geodesic_distance", "kind": "function", "doc": "<p>Calculate the geodesic distance between two SE3 poses.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>T1 : sm.SE3\n    The first SE3 pose.\nT2 : sm.SE3\n    The second SE3 pose.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>float\n    The geodesic distance between T1 and T2.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">T1</span><span class=\"p\">:</span> <span class=\"n\">spatialmath</span><span class=\"o\">.</span><span class=\"n\">pose3d</span><span class=\"o\">.</span><span class=\"n\">SE3</span>, </span><span class=\"param\"><span class=\"n\">T2</span><span class=\"p\">:</span> <span class=\"n\">spatialmath</span><span class=\"o\">.</span><span class=\"n\">pose3d</span><span class=\"o\">.</span><span class=\"n\">SE3</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "utils.math.hausdorff_distance", "modulename": "utils.math", "qualname": "hausdorff_distance", "kind": "function", "doc": "<p>Calculate the Hausdorff distance between two SE3 poses given a set of points.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>T1 : sm.SE3\n    The first SE3 pose.\nT2 : sm.SE3\n    The second SE3 pose.\npoints : np.ndarray\n    A set of points to compare the transformed poses.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>float\n    The Hausdorff distance between T1 and T2.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">T1</span><span class=\"p\">:</span> <span class=\"n\">spatialmath</span><span class=\"o\">.</span><span class=\"n\">pose3d</span><span class=\"o\">.</span><span class=\"n\">SE3</span>,</span><span class=\"param\">\t<span class=\"n\">T2</span><span class=\"p\">:</span> <span class=\"n\">spatialmath</span><span class=\"o\">.</span><span class=\"n\">pose3d</span><span class=\"o\">.</span><span class=\"n\">SE3</span>,</span><span class=\"param\">\t<span class=\"n\">points</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "utils.math.cint", "modulename": "utils.math", "qualname": "cint", "kind": "function", "doc": "<p>Computes the contour integral of a complex function along a parameterized curve.</p>\n\n<p>This function performs numerical integration of a complex function F(z) along a curve C(t),\nwhere t is the parameter along the curve, and dC(t) is the derivative of the curve with respect\nto t. The integral is calculated from t_start to t_end using Gaussian quadrature.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>F : Callable[[complex], complex]\n    The complex function to integrate.\nC : Callable[[float], complex]\n    A parameterized function representing the curve along which to integrate.\ndC : Callable[[float], complex]\n    The derivative of the curve with respect to the parameter t.\nt_start : float, optional\n    The starting value of the parameter t, by default 0.0.\nt_end : float, optional\n    The ending value of the parameter t, by default 2 * np.pi.\nmax_iter : int, optional\n    The maximum number of iterations for the numerical integration, by default 100.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>tuple\n    A tuple (I, I_e) where I is the result of the contour integral, and I_e is the estimated error.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">F</span><span class=\"p\">:</span> <span class=\"n\">Callable</span><span class=\"p\">[[</span><span class=\"nb\">complex</span><span class=\"p\">],</span> <span class=\"nb\">complex</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">C</span><span class=\"p\">:</span> <span class=\"n\">Callable</span><span class=\"p\">[[</span><span class=\"nb\">float</span><span class=\"p\">],</span> <span class=\"nb\">complex</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">dC</span><span class=\"p\">:</span> <span class=\"n\">Callable</span><span class=\"p\">[[</span><span class=\"nb\">float</span><span class=\"p\">],</span> <span class=\"nb\">complex</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">t_start</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.0</span>,</span><span class=\"param\">\t<span class=\"n\">t_end</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">6.283185307179586</span>,</span><span class=\"param\">\t<span class=\"n\">max_iter</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">100</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "utils.math.homotopy_class", "modulename": "utils.math", "qualname": "homotopy_class", "kind": "function", "doc": "<p>Computes the homotopy class of a curve by integrating a complex function along the curve.</p>\n\n<p>This function numerically evaluates the contour integral of a complex function F along a curve\ndefined by a set of 2D points. The integral result provides information about the homotopy class\nof the curve with respect to the function F.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>F : Callable[[complex], complex]\n    The complex function to integrate along the curve.\npoints : np.ndarray\n    A NumPy array of shape (N, 2) representing the curve as a sequence of 2D points.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>tuple\n    A tuple (I, I_e) where I is the result of the contour integral, and I_e is the estimated error.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">F</span><span class=\"p\">:</span> <span class=\"n\">Callable</span><span class=\"p\">[[</span><span class=\"nb\">complex</span><span class=\"p\">],</span> <span class=\"nb\">complex</span><span class=\"p\">]</span>, </span><span class=\"param\"><span class=\"n\">points</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "utils.physics", "modulename": "utils.physics", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "utils.physics.Constants", "modulename": "utils.physics", "qualname": "Constants", "kind": "class", "doc": "<p></p>\n"}, {"fullname": "utils.physics.Constants.mu_0", "modulename": "utils.physics", "qualname": "Constants.mu_0", "kind": "variable", "doc": "<p></p>\n", "default_value": "1.2566370614359173e-06"}, {"fullname": "utils.physics.YoungsModulus", "modulename": "utils.physics", "qualname": "YoungsModulus", "kind": "class", "doc": "<p>Enum representing Young's modulus (E) for different materials.</p>\n\n<h2 id=\"attributes\">Attributes</h2>\n\n<p>STEEL : float\n    Young's modulus of steel in Pascals (Pa).\nRUBBER : float\n    Young's modulus of rubber in Pascals (Pa).\nCOPPER : float\n    Young's modulus of copper in Pascals (Pa).</p>\n", "bases": "enum.Enum"}, {"fullname": "utils.physics.YoungsModulus.STEEL", "modulename": "utils.physics", "qualname": "YoungsModulus.STEEL", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;YoungsModulus.STEEL: 200000000000.0&gt;"}, {"fullname": "utils.physics.YoungsModulus.RUBBER", "modulename": "utils.physics", "qualname": "YoungsModulus.RUBBER", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;YoungsModulus.RUBBER: 100000000.0&gt;"}, {"fullname": "utils.physics.YoungsModulus.COPPER", "modulename": "utils.physics", "qualname": "YoungsModulus.COPPER", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;YoungsModulus.COPPER: 110000000000.0&gt;"}, {"fullname": "utils.physics.ShearModulus", "modulename": "utils.physics", "qualname": "ShearModulus", "kind": "class", "doc": "<p>Enum representing Shear modulus (G) for different materials.</p>\n\n<h2 id=\"attributes\">Attributes</h2>\n\n<p>STEEL : float\n    Shear modulus of steel in Pascals (Pa).\nRUBBER : float\n    Shear modulus of rubber in Pascals (Pa).\nCOPPER : float\n    Shear modulus of copper in Pascals (Pa).</p>\n", "bases": "enum.Enum"}, {"fullname": "utils.physics.ShearModulus.STEEL", "modulename": "utils.physics", "qualname": "ShearModulus.STEEL", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;ShearModulus.STEEL: 79300000000.0&gt;"}, {"fullname": "utils.physics.ShearModulus.RUBBER", "modulename": "utils.physics", "qualname": "ShearModulus.RUBBER", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;ShearModulus.RUBBER: 600000.0&gt;"}, {"fullname": "utils.physics.ShearModulus.COPPER", "modulename": "utils.physics", "qualname": "ShearModulus.COPPER", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;ShearModulus.COPPER: 44700000000.0&gt;"}, {"fullname": "utils.physics.Material", "modulename": "utils.physics", "qualname": "Material", "kind": "class", "doc": "<p>Enum representing material types.</p>\n\n<h2 id=\"attributes\">Attributes</h2>\n\n<p>STEEL : int\n    Represents the material as steel.\nRUBBER : int\n    Represents the material as rubber.\nCOPPER : int\n    Represents the material as copper.</p>\n", "bases": "enum.Enum"}, {"fullname": "utils.physics.Material.STEEL", "modulename": "utils.physics", "qualname": "Material.STEEL", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;Material.STEEL: 0&gt;"}, {"fullname": "utils.physics.Material.RUBBER", "modulename": "utils.physics", "qualname": "Material.RUBBER", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;Material.RUBBER: 1&gt;"}, {"fullname": "utils.physics.Material.COPPER", "modulename": "utils.physics", "qualname": "Material.COPPER", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;Material.COPPER: 2&gt;"}, {"fullname": "utils.physics.cable_properties", "modulename": "utils.physics", "qualname": "cable_properties", "kind": "function", "doc": "<p>Computes the twist and bend stiffness for a given material.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>material : Material\n    The material of the cable. Use the Material enum (e.g., STEEL, RUBBER, COPPER).</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>dict\n    A dictionary containing:\n    - 'twist': The shear modulus (representing twist stiffness) in Pascals (Pa).\n    - 'bend': The Young's modulus (representing bend stiffness) in Pascals (Pa).</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<ul>\n<li>The twist stiffness is directly represented by the shear modulus (G) of the material.</li>\n<li>The bend stiffness is directly represented by Young's modulus (E) of the material.</li>\n<li>The calculation assumes normalized stiffnesses without explicit dependence on cross-section dimensions.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">material</span><span class=\"p\">:</span> <span class=\"n\">utils</span><span class=\"o\">.</span><span class=\"n\">physics</span><span class=\"o\">.</span><span class=\"n\">Material</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">dict</span>:</span></span>", "funcdef": "def"}, {"fullname": "utils.physics.biot_savarts_law", "modulename": "utils.physics", "qualname": "biot_savarts_law", "kind": "function", "doc": "<p>Compute the magnetic field at a point due to a current-carrying wire.</p>\n\n<p>This function calculates the magnetic field at a given point in space, assuming an infinitely long wire\ncarrying a steady current. The magnetic field is computed using the Biot-Savart law.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>point : np.ndarray\n    The coordinates of the point where the magnetic field is computed. Can be 2D (x, y) or 3D (x, y, z).\nI_wire : float\n    The current flowing through the wire located at the origin or a custom position.\nwire_position : np.ndarray, optional\n    The coordinates of the wire (default is at the origin). Should be of the same dimension as <code>point</code>.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>np.ndarray\n    A vector representing the magnetic field components at the given point. Returns a 2D vector for 2D inputs\n    and a 3D vector for 3D inputs.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<ul>\n<li>If the point is located at the wire's position (r = 0), the magnetic field is undefined and returns [0, 0] or [0, 0, 0].</li>\n<li>For 2D inputs, the magnetic field is directed perpendicular to the radial vector in the xy-plane.</li>\n<li>For 3D inputs, the wire is assumed to be infinitely long along the z-axis, and the field is calculated in the xy-plane.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">point</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">I_wire</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">wire_position</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "utils.physics.amperes_law", "modulename": "utils.physics", "qualname": "amperes_law", "kind": "function", "doc": "<p>Compute the current enclosed by a closed loop using Amp\u00e8re's law.</p>\n\n<p>This function calculates the total current enclosed by a loop of points in space, based on the circulation of\nthe magnetic field along the loop. The magnetic field is generated by a current-carrying wire, and the current\nis computed using Amp\u00e8re's law.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>loop_points : np.ndarray\n    An array of shape (N, 2) or (N, 3) containing the coordinates of points forming a closed loop.\nI_wire : float\n    The current through the wire generating the magnetic field.\nwire_position : np.ndarray, optional\n    The position of the wire (default is at the origin). Should be of the same dimension as <code>loop_points</code>.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>float\n    The total enclosed current through the loop.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<ul>\n<li>The magnetic field at each point in the loop is calculated using the Biot-Savart law.</li>\n<li>Amp\u00e8re's law relates the circulation of the magnetic field around the loop to the total current enclosed by the loop.</li>\n<li>This function supports both 2D and 3D loops, depending on the dimensionality of <code>loop_points</code>.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">loop_points</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">I_wire</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">wire_position</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "utils.sm", "modulename": "utils.sm", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "utils.sm.make_tf", "modulename": "utils.sm", "qualname": "make_tf", "kind": "function", "doc": "<p>Create an SE3 transformation matrix from the provided position and orientation.</p>\n\n<p>This function constructs a SE3 transformation matrix that combines a translation vector\nand an orientation. The orientation can be specified in various formats including rotation\nmatrices, quaternions, or SE3 objects. The function handles conversion between these formats\nand constructs the final SE3 transformation matrix.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>pos : Union[np.ndarray, list], optional\n    The translation vector as a list or ndarray with shape (3,). Defaults to [0, 0, 0].\nori : Union[np.ndarray, sm.SE3, sm.SO3], optional\n    The orientation can be a rotation matrix (3x3), quaternion (4,), or SE3 object.\n    Defaults to [1, 0, 0, 0].</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>sm.SE3\n    The resulting SE3 transformation matrix combining the provided position and orientation.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<ul>\n<li>The function handles various input formats for orientation and performs necessary conversions.</li>\n<li>The position and orientation must be compatible with SE3 transformation.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">pos</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"nb\">list</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">ori</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"n\">spatialmath</span><span class=\"o\">.</span><span class=\"n\">pose3d</span><span class=\"o\">.</span><span class=\"n\">SE3</span><span class=\"p\">,</span> <span class=\"n\">spatialmath</span><span class=\"o\">.</span><span class=\"n\">pose3d</span><span class=\"o\">.</span><span class=\"n\">SO3</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">spatialmath</span><span class=\"o\">.</span><span class=\"n\">pose3d</span><span class=\"o\">.</span><span class=\"n\">SE3</span>:</span></span>", "funcdef": "def"}, {"fullname": "utils.sm.is_R_valid", "modulename": "utils.sm", "qualname": "is_R_valid", "kind": "function", "doc": "<p>Check if the given matrix is a valid 3x3 rotation matrix.</p>\n\n<p>This function verifies that the provided matrix is a valid rotation matrix by checking\nits orthogonality and ensuring that its determinant is close to 1. The function uses a\ntolerance level to account for numerical inaccuracies.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>R : np.ndarray\n    The matrix to be checked.\ntol : float, optional\n    Tolerance for numerical comparison. Defaults to 1e-8.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>bool\n    True if the matrix is a valid rotation matrix, False otherwise.</p>\n\n<h2 id=\"raises\">Raises</h2>\n\n<p>ValueError\n    If the input matrix is not 3x3.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<ul>\n<li>The function performs orthogonality check and determinant check.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">R</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">tol</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">1e-08</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "utils.sm.is_ori_valid", "modulename": "utils.sm", "qualname": "is_ori_valid", "kind": "function", "doc": "<p>Check if the input orientation representation is valid.</p>\n\n<p>This function verifies if the provided orientation is valid, which can be in the form of\na rotation matrix, quaternion, or Euler angles. It checks the validity of the rotation\nmatrix derived from these representations.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>ori : Union[np.ndarray, sm.SE3], optional\n    The orientation representation to be checked. Could be a rotation matrix (3x3),\n    quaternion (4,), or Euler angles (3,). Defaults to [1, 0, 0, 0].</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>bool\n    True if the orientation representation is valid, False otherwise.</p>\n\n<h2 id=\"raises\">Raises</h2>\n\n<p>ValueError\n    If the input orientation is not of a recognized format or invalid dimensions.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<ul>\n<li>The function performs conversion to rotation matrix if necessary and validates it.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">ori</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"n\">spatialmath</span><span class=\"o\">.</span><span class=\"n\">pose3d</span><span class=\"o\">.</span><span class=\"n\">SE3</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "utils.sm.make_R_valid", "modulename": "utils.sm", "qualname": "make_R_valid", "kind": "function", "doc": "<p>Make the input matrix a valid 3x3 rotation matrix.</p>\n\n<p>This function corrects the input matrix to ensure it is a valid rotation matrix. It\nuses Gram-Schmidt orthogonalization and adjusts the determinant to be positive.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>R : np.ndarray\n    The matrix to be corrected.\ntol : float, optional\n    Tolerance for numerical comparison. Defaults to 1e-6.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>np.ndarray\n    A valid 3x3 rotation matrix derived from the input matrix.</p>\n\n<h2 id=\"raises\">Raises</h2>\n\n<p>ValueError\n    If the input matrix cannot be made a valid rotation matrix.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<ul>\n<li>The function performs orthogonalization and adjusts the determinant if necessary.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">R</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">tol</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">1e-06</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "utils.sm.csvread", "modulename": "utils.sm", "qualname": "csvread", "kind": "function", "doc": "<p>Read a CSV file and build SE3 homogeneous transformation matrices.</p>\n\n<p>This function reads a CSV file containing columns for translation and rotation (in roll,\npitch, yaw) and constructs a sequence of SE3 transformation matrices from the data.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>path : str\n    The path to the CSV file containing the transformation data.\nheaders : List[str], optional\n    The headers of the CSV file columns that correspond to the translation and rotation data.\n    Defaults to a predefined set of headers.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>sm.SE3\n    A sequence of SE3 transformation matrices built from the CSV data.</p>\n\n<h2 id=\"raises\">Raises</h2>\n\n<p>ValueError\n    If the CSV file does not contain the required columns.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<ul>\n<li>The CSV file must include columns specified in the <code>headers</code> parameter.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">path</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">headers</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"s1\">&#39;target_TCP_pose_0&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;target_TCP_pose_1&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;target_TCP_pose_2&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;target_TCP_pose_3&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;target_TCP_pose_4&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;target_TCP_pose_5&#39;</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">spatialmath</span><span class=\"o\">.</span><span class=\"n\">pose3d</span><span class=\"o\">.</span><span class=\"n\">SE3</span>:</span></span>", "funcdef": "def"}, {"fullname": "utils.sm.trapezoidal_times", "modulename": "utils.sm", "qualname": "trapezoidal_times", "kind": "function", "doc": "<p>Generate trapezoidal profile timing steps.</p>\n\n<p>This function creates a time array that represents a trapezoidal velocity profile, including\nacceleration, constant velocity, and deceleration phases.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>steps : int\n    The total number of steps for the trapezoidal profile.\naccel_ratio : float, optional\n    The ratio of the acceleration phase duration to the total duration. Defaults to 0.1.\ndecel_ratio : float, optional\n    The ratio of the deceleration phase duration to the total duration. Defaults to 0.1.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>np.ndarray\n    An array of times normalized to [0, 1] representing the trapezoidal profile.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<ul>\n<li>The time array includes segments for acceleration, constant velocity, and deceleration.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">steps</span>, </span><span class=\"param\"><span class=\"n\">accel_ratio</span><span class=\"o\">=</span><span class=\"mf\">0.1</span>, </span><span class=\"param\"><span class=\"n\">decel_ratio</span><span class=\"o\">=</span><span class=\"mf\">0.1</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "utils.sm.ctraj", "modulename": "utils.sm", "qualname": "ctraj", "kind": "function", "doc": "<p>Interpolate between two SE3 homogeneous transformation matrices.</p>\n\n<p>This function generates a list of SE3 transformation matrices by interpolating between\na start and end transformation matrix over a specified set of time steps or a defined number of steps.\nIf a list of time steps is provided, the function uses those directly; otherwise, it generates\na trapezoidal profile based on the number of steps.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>T_start : sm.SE3\n    The starting SE3 transformation matrix.\nT_end : sm.SE3\n    The ending SE3 transformation matrix.\nt : Union[int, List[float]]\n    Either an integer specifying the number of steps, or a list of time steps for interpolation.\naccel_ratio : float, optional\n    The ratio of the acceleration phase duration to the total duration when using trapezoidal profile. Defaults to 0.1.\ndecel_ratio : float, optional\n    The ratio of the deceleration phase duration to the total duration when using trapezoidal profile. Defaults to 0.1.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>List[sm.SE3]\n    A list of interpolated SE3 transformation matrices.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<ul>\n<li>Interpolation includes both translation and rotation components.</li>\n<li>The function uses spherical linear interpolation (SLERP) for rotation.</li>\n<li>If <code>t</code> is an integer, a trapezoidal profile is used to generate the time steps.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">T_start</span><span class=\"p\">:</span> <span class=\"n\">spatialmath</span><span class=\"o\">.</span><span class=\"n\">pose3d</span><span class=\"o\">.</span><span class=\"n\">SE3</span>,</span><span class=\"param\">\t<span class=\"n\">T_end</span><span class=\"p\">:</span> <span class=\"n\">spatialmath</span><span class=\"o\">.</span><span class=\"n\">pose3d</span><span class=\"o\">.</span><span class=\"n\">SE3</span>,</span><span class=\"param\">\t<span class=\"n\">t</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">]]</span>,</span><span class=\"param\">\t<span class=\"n\">accel_ratio</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.1</span>,</span><span class=\"param\">\t<span class=\"n\">decel_ratio</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.1</span></span><span class=\"return-annotation\">) -> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">spatialmath</span><span class=\"o\">.</span><span class=\"n\">pose3d</span><span class=\"o\">.</span><span class=\"n\">SE3</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "utils.sm.save_traj", "modulename": "utils.sm", "qualname": "save_traj", "kind": "function", "doc": "<p>Save a list of SE3 transformation matrices to a CSV file with labeled columns.</p>\n\n<p>This function converts a list of SE3 objects into 4x4 numpy arrays, flattens them,\nand saves them to a CSV file with each rotational component labeled as r11, r12, ..., r33,\nand each translational component labeled as t1, t2, t3.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>Traj : List[sm.SE3]\n    A list of SE3 objects representing the trajectory to be saved.\nsave_path : str\n    The file path where the trajectory will be saved as a CSV file.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>None</p>\n\n<h2 id=\"raises\">Raises</h2>\n\n<p>TypeError\n    If Traj is not a list of SE3 objects or save_path is not a string.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">Traj</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">spatialmath</span><span class=\"o\">.</span><span class=\"n\">pose3d</span><span class=\"o\">.</span><span class=\"n\">SE3</span><span class=\"p\">]</span>, </span><span class=\"param\"><span class=\"n\">save_path</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "utils.sm.load_traj", "modulename": "utils.sm", "qualname": "load_traj", "kind": "function", "doc": "<p>Load a trajectory from a CSV file with labeled columns and return it as a list of SE3 objects.</p>\n\n<p>This function reads a CSV file containing a sequence of flattened SE3 transformation matrices\n(with labeled columns) and converts them into a list of SE3 objects representing the trajectory.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>load_path : str\n    The file path from which the trajectory will be loaded.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>List[sm.SE3]\n    A list of SE3 objects representing the loaded trajectory.</p>\n\n<h2 id=\"raises\">Raises</h2>\n\n<p>TypeError\n    If load_path is not a string.\nValueError\n    If the file content cannot be correctly interpreted as SE3 matrices.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<ul>\n<li>Ensure that load_path points to a valid CSV file containing the expected format of flattened SE3 matrices.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">load_path</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">spatialmath</span><span class=\"o\">.</span><span class=\"n\">pose3d</span><span class=\"o\">.</span><span class=\"n\">SE3</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "utils.sm.cubic_interpolation", "modulename": "utils.sm", "qualname": "cubic_interpolation", "kind": "function", "doc": "<p>Compute cubic interpolation between two joint configurations.</p>\n\n<p>This function generates an interpolated joint configuration at a given time <code>t</code>\nusing cubic interpolation. It ensures a smooth transition between the initial and\nfinal configurations over the specified time interval.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>t : float\n    The current time at which to compute the joint configuration.\nt0 : float\n    The start time of the trajectory.\ntf : float\n    The end time of the trajectory.\nq0 : np.ndarray\n    The initial joint configuration as a 1D array.\nqf : np.ndarray\n    The final joint configuration as a 1D array.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>np.ndarray\n    The interpolated joint configuration at time <code>t</code>.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<ul>\n<li>The function uses Hermite cubic polynomials for smooth interpolation.</li>\n<li>The input joint configurations <code>q0</code> and <code>qf</code> must have the same dimensions.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">t</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">t0</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">tf</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">q0</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">qf</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "utils.sm.jtraj", "modulename": "utils.sm", "qualname": "jtraj", "kind": "function", "doc": "<p>Generate a joint space trajectory using cubic interpolation.</p>\n\n<p>This function creates a smooth trajectory between two joint configurations over a specified\ntime array. It generates a sequence of joint configurations by applying cubic interpolation\nfor each time step in the array.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>q0 : np.ndarray\n    The initial joint configuration as a 1D array.\nqf : np.ndarray\n    The final joint configuration as a 1D array.\nt_array : np.ndarray\n    An array of time steps over which the trajectory is computed.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>np.ndarray\n    A 2D array where each row represents a joint configuration at a corresponding time step.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<ul>\n<li>The initial and final joint configurations <code>q0</code> and <code>qf</code> must have the same dimensions.</li>\n<li>The function assumes uniform time steps within <code>t_array</code>.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">q0</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">qf</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">t_array</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&_'"=,()]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.pipeline.remove(elasticlunr.stemmer);
            this.pipeline.remove(elasticlunr.stopWordFilter);
            this.addField("qualname");
            this.addField("fullname");
            this.addField("annotation");
            this.addField("default_value");
            this.addField("signature");
            this.addField("bases");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            annotation: {boost: 2},
            default_value: {boost: 2},
            signature: {boost: 2},
            bases: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();