# DMPCartesian Documentation

The `DMPCartesian` class implements a Cartesian Dynamic Movement Primitive (DMP) for controlling the position and orientation of a robotic end-effector. This README explains the mathematical principles behind the class.

## Dynamic Movement Primitives Overview

Dynamic Movement Primitives (DMPs) are a framework for encoding, learning, and reproducing complex movements. They combine a set of differential equations to model the desired trajectory.

## Mathematical Formulation

### Canonical System

The canonical system is a single differential equation that drives the phase of the movement:

$$ \dot{s} = -\alpha_s s $$

where $s$ is the phase variable and $\alpha_s$ is a constant that determines the speed of decay.

### Position DMP

Position DMPs control the Cartesian position of the end-effector. The equations governing the position DMP are:

$$ \tau \dot{p} = v $$
$$ \tau \dot{v} = K (g - p) - D v + f(s) $$

where:
- $p$ is the position.
- $v$ is the velocity.
- $\tau$ is a temporal scaling factor.
- $K$ and $D$ are the spring and damper coefficients, respectively.
- $g$ is the goal position.
- $f(s)$ is a nonlinear forcing term.

The forcing term $f(s)$ is a weighted sum of Gaussian basis functions:

$$ f(s) = \sum_{i=1}^N \psi_i(s) w_i $$

where $\psi_i(s)$ are Gaussian basis functions and $w_i$ are the learned weights.

### Orientation DMP

Orientation DMPs control the orientation of the end-effector using quaternions. The equations governing the orientation DMP are:

$$ \tau \dot{q} = \frac{1}{2} \omega \otimes q $$
$$ \tau \dot{\omega} = K (q_g \otimes q^{-1})_v - D \omega + f(s) $$

where:
- $q$ is the quaternion representing orientation.
- $\omega$ is the angular velocity.
- $\tau$ is a temporal scaling factor.
- $K$ and $D$ are the spring and damper coefficients, respectively.
- $q_g$ is the goal quaternion.
- $(q_g \otimes q^{-1})_v$ represents the vector part of the quaternion error.
- $f(s)$ is a nonlinear forcing term similar to the position DMP.

The forcing term $f(s)$ is also a weighted sum of Gaussian basis functions:

$$ f(s) = \sum_{i=1}^N \psi_i(s) w_i $$

### Forcing Term

The forcing term for both position and orientation DMPs is defined as:

$$ f(s) = \sum_{i=1}^N \psi_i(s) w_i $$

where $\psi_i(s)$ are Gaussian basis functions:

$$ \psi_i(s) = \exp \left( -\frac{1}{2} \left( \frac{s - c_i}{h_i} \right)^2 \right) $$

with centers $c_i$ and widths $h_i$.

### Training

Training the DMP involves finding the weights $w_i$ that minimize the error between the desired trajectory and the trajectory generated by the DMP. This is typically done using regression techniques.

## Usage

To use the `DMPCartesian`:

1. **Initialization**: Instantiate the `DMPCartesian` with appropriate parameters.
2. **Training**: Use the `train` method to train the DMP with desired position and orientation trajectories.
3. **Execution**: Use the `step` or `rollout` methods to generate the position and orientation trajectories based on the trained model.

## Example

A real demonstration was recorded and can be found in [demonstration.csv](public/demonstration.csv). This demonstration can be seen plotted and execution in MuJoCo below.

| <div style="width:870px">Execution of trajectory in MuJoCo</div>                                     | <div style="width:300px">Plot of 3D position trajectory</div>                                       |
| ------------------------------------------------------ | --------------------------------------------------------- |
| ![here](/public/docs/ur5e_dmp_cartesianonline-video-cutter.com-ezgif.com-video-to-gif-converter.gif) | ![here](/public/docs/3d-plot-cartesian.png) |


The errors when executing this trajectory can be seen below for the position and orientation

|  Positional error   | Orientational error     |
| --- | --- |
| ![here](/public/docs/dmp_cartesian_position_error.png)    | ![here](/public/docs/dmp_cartesian_orientation_error.png)    |


To run a demo, stand in the root and run this simulation
```python
python -m sims.dmp_cartesian_ur5e
```

You can apply the `DMPCartesian` class as shown below

```python
# initialize DMPCartesian
dmp = DMPCartesian()

# load in teh trajectory 
Traj = load_path(path)

# load in the trajecotry
dmp.load(Traj)
```
You now have two options

 1. Perform a rollout and gain the entire DMP generated trajectory
    ```python
    p, v, a, q, w, dw = self.dmp.rollout(self.dmp.ts, self.dmp.tau)
    ```
    here each of these elements are lists of positions, velocities, accelerations etc.

 2. Step through the DMP generated trajectory 
    ```python
    # steo the canonical system
    x = self.dmp.cs.step(self.dmp.dt, self.dmp.tau)
    # use phase variable x to step the DMP. The output is one position, velocity, acceleration etc.
    # you can also introduce optional force disturbances to the DMP
    p, v, a, q, w, dw = self.dmp.step(
        x,
        self.dmp.dt,
        self.dmp.tau,
        # force_disturbance=np.array([0, 0, 0]),
        # torque_disturbance=np.array([0, 0, 0]),
    )
    ```

